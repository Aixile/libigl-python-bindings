{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"igl_docs/","text":"adjacency_list(f: array) -> handle \u00b6 Constructs the graph adjacency list of a given mesh (v, f) Parameters f : #f by dim array of fixed dimensional (e.g. triangle (#f by 3), tet (#f by 4), quad (#f by 4), etc\u2026) mesh faces Returns list of lists containing at index i the adjacent vertices of vertex i See also adjacency_matrix Notes Examples Mesh in (v, f) a = mesh_adjacency_list(f) adjacency_matrix(f: array) -> object \u00b6 Constructs the graph adjacency matrix of a given mesh (v, f). Parameters f : #f by dim list of mesh simplices Returns a : max(f) by max(f) cotangent matrix, each row i corresponding to v(i, :) See also adjacency_list, edges, cotmatrix, diag Notes None Examples Mesh in (v, f) a = adjacency_matrix(f) Sum each row a_sum = np.sum(a, axis=1) Convert row sums into diagonal of sparse matrix a_diag = diag(a_sum) Build uniform laplacian u = a - a_diag ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -> object \u00b6 Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of ambient occusion values between 1 (fully occluded) and 0 (not occluded) See also Notes None Examples arap_linear_block(v: array, f: array, d: int, energy: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns #v by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples arap_linear_block_elements(v: array, f: array, d: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns #v by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples arap_linear_block_spokes(v: array, f: array, d: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns #v by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns #v by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples arap_rhs(v: array, f: array, d: int, energy: int) -> object \u00b6 Guild right-hand side constructor of global poisson solve for various ARAP energies Inputs: Outputs: K #V*dim by #(FV)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); Parameters v : #v by Vdim list of initial domain positions f : #f by 3 list of triangle indices into v d : dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2 energy : ARAPEnergyType enum value defining which energy is being used. See igl.ARAPEnergyType for valid options and explanations. Returns #v*d by #(fv)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); See also arap_linear_block, arap Notes Examples average_onto_vertices(v: array, f: array, s: array) -> object \u00b6 Move a scalar field defined on faces to vertices by averaging Parameters v : #v by vdim array of mesh vertices f : #f by simplex_count array of simplex indices s : #f by dim scalar field defined on simplices Returns #v by dim scalar field defined on vertices See also average_onto_faces Notes Examples avg_edge_length(v: array, f: array) -> float \u00b6 Compute the average edge length for the given triangle mesh. Parameters v : array_like #v by 3 vertex array f : f #f by simplex-size list of mesh faces (must be simplex) Returns l : average edge length See also adjacency_matrix Notes None Examples Mesh in (v, f) length = avg_edge_length(v, f) barycenter(v: array, f: array) -> object \u00b6 Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V Returns A #f x dim matrix where each row is the barycenter of each simplex See also Notes None Examples barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -> object \u00b6 Compute barycentric coordinates in a tet corresponding to the Euclidean coordinates in p . The input arrays a , b , c and d are the vertices of each tet. I.e. one tet is a[i, :], b[i, :], c[i, :], d[:, i] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tet corners in 3d b : #P by 3 Tet corners in 3d c : #P by 3 Tet corners in 3d d : #P by 3 Tet corners in 3d Returns #P by 4 list of barycentric coordinates See also Notes Examples barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -> object \u00b6 Compute barycentric coordinates in a triangle corresponding to the Euclidean coordinates in p . The input arrays a , b , and c are the vertices of each triangle. I.e. one triangle is a[i, :], b[i, :], c[i, :] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tri corners in 3d b : #P by 3 Tri corners in 3d c : #P by 3 Tri corners in 3d Returns #P by 3 list of barycentric coordinates See also Notes Examples bfs(A: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, s: int) -> Tuple[object, object] \u00b6 Construct an array indexing into a directed graph represented by an adjacency list using breadth first search. I.e. the output is an array of vertices in breadth-first order. Parameters A : #V list of adjacency lists or #V by #V adjacency matrix s : starting node (index into A) Returns A tuple, (d, p) where: d is a #V list of indices into rows of A in the order in which graph nodes are discovered p is a #V list of indices of A of predecsors where -1 indicates root/not discovered. I.e. p[i] is the index of the vertex v which preceded d[i] in the breadth first traversal. Note that together, (d, p) form a spanning tree of the input graph See also Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) A = igl.adjacency_matrix(V, F) d, p = igl.bfs(A, V[0]) bfs_orient(f: array) -> Tuple[object, object] \u00b6 Consistently orient faces in orientable patches using BFS. Parameters f : #F by 3 list of faces Returns A tuple, (ff, c) where: ff is a #F by 3 list of faces which are consistently oriented with c is a #F array of connected component ids See also Notes Examples v, f, _ = igl.readOFF(\u201ctest.off) ff, c = igl.bfs_orient(f) bone_parents(be: array) -> object \u00b6 BONE_PARENTS Recover \u201cparent\u201d bones from directed graph representation. Parameters BE #BE by 2 list of directed bone edges Returns P #BE by 1 list of parent indices into BE, -1 means root. See also Notes None Examples boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -> Tuple[bool, object, object] \u00b6 Compute boundary conditions for automatic weights computation. This function expects that the given mesh (V,Ele) has sufficient samples (vertices) exactly at point handle locations and exactly along bone and cage edges. Parameters V #V by dim list of domain vertices Ele #Ele by simplex-size list of simplex indices C #C by dim list of handle positions P #P by 1 list of point handle indices into C BE #BE by 2 list of bone edge indices into C CE #CE by 2 list of cage edge indices into P Returns b #b list of boundary indices (indices into V of vertices which have known, fixed values) bc #b by #weights list of known/fixed values for boundary vertices (notice the #b != #weights in general because #b will include all the intermediary samples along each bone, etc.. The ordering of the weights corresponds to [P;BE] Returns false if boundary conditions are suspicious: P and BE are empty bc is empty some column of bc doesn\u2019t have a 0 (assuming bc has >1 columns) some column of bc doesn\u2019t have a 1 (assuming bc has >1 columns) See also Notes None Examples boundary_facets(t: array) -> object \u00b6 Determine boundary faces (edges) of tetrahedra (triangles). Parameters t : tetrahedron or triangle index list, m by 4/3, where m is the number of tetrahedra/triangles Returns f : list of boundary faces, n by 3/2, where n is the number of boundary faces/edges See also None Notes None Examples Mesh in (v, f) b = boundary_facets(f) boundary_loop(f: array) -> object \u00b6 Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. Parameters f : #v by dim array of mesh faces Returns l : ordered list of boundary vertices of longest boundary loop See also Notes None Examples Mesh in (v, f) l = boundary_loop(f) bounding_box(*args, **kwargs) \u00b6 bounding_box(v: array) -> Tuple[object, object] \u00b6 Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples bounding_box(v: array, pad: float) -> Tuple[object, object] \u00b6 Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples bounding_box_diagonal(v: array) -> float \u00b6 Compute the length of the diagonal of a given meshes axis-aligned bounding Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V Returns Returns length of bounding box diagonal See also Notes None Examples centroid(v: array, f: array) -> Tuple[object] \u00b6 Computes the centroid of a closed mesh using a surface integral. Parameters v : #v by dim array of rest domain positions f : #f by 3 array of triangle indices into v Returns c : dim array of centroid coordinates vol : total volume of solid See also None Notes None Examples Mesh in (v, f) c, vol = centroid(v, f) circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -> List[int] \u00b6 Return list of faces around the end point of an edge. Assumes data-structures are built from an edge-manifold closed mesh. Parameters e index into E of edge to circulate ccw whether to continue in ccw direction of edge (circulate around EMAP #F*3 list of indices into E, mapping each directed edge to unique \u00b6 unique edge in E EF #E by 2 list of edge flaps, EF(e,0)=f means e=(i\u2192j) is the edge of e=(j->i) \u00b6 EI #E by 2 list of edge flap corners (see above). Returns Returns list of faces touched by circulation (in cyclically order). See also Notes None Examples circumradius(v: array, f: array) -> object \u00b6 Compute the circumradius of each triangle in a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of triangle indices into V Returns R #F list of circumradii See also Notes None Examples R = circumradius(V, F) collapse_small_triangles(v: array, f: array, eps: float) -> object \u00b6 Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the original faces and vertices of (V,F) except any small triangles have been removed via collapse. We are not following the rules in \u201cMesh Optimization\u201d [Hoppe et al] Section 4.2. But for our purposes we don\u2019t care about this criteria. Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V eps epsilon for smallest allowed area treated as fraction of squared bounding box diagonal Returns FF #FF by 3 list of triangle indices into V See also Notes None Examples connect_boundary_to_infinity(f: array) -> object \u00b6 Connect all boundary edges to a fictitious point at infinity. Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into [V;inf inf inf], original F are guaranteed to come first. If (V,F) was a manifold mesh, now it is closed with a possibly non-manifold vertex at infinity (but it will be edge-manifold). See also Notes None Examples connect_boundary_to_infinity_face(v: array, f: array) -> Tuple[object, object] \u00b6 Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into VO See also Notes None Examples connect_boundary_to_infinity_index(f: array, inf_index: int) -> object \u00b6 Parameters inf_index index of point at infinity (usually V.rows() or F.maxCoeff()) Returns See also Notes None Examples cotmatrix(v: array, f: array) -> object \u00b6 Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (v, f). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) Returns l : #v by #v cotangent matrix, each row i corresponding to v(i, :) See also adjacency_matrix Notes This Laplacian uses the convention that diagonal entries are minus the sum of off-diagonal entries. The diagonal entries are therefore in general negative and the matrix is negative semi-definite (immediately, -L is positive semi-definite) Examples Mesh in (v, f) l = cotmatrix(v, f) cotmatrix_entries(v: array, f: array) -> object \u00b6 COTMATRIX_ENTRIES compute the cotangents of each angle in mesh (V,F) Parameters V #V by dim list of rest domain positions F #F by {34} list of {triangletetrahedra} indices into V Returns C #F by 3 list of \u00bd*cotangents corresponding angles for triangles, columns correspond to edges [1,2],[2,0],[0,1] OR C #F by 6 list of \u2159*cotangents of dihedral angles*edge lengths for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2] See also Notes None Examples crouzeix_raviart_cotmatrix(v: array, f: array) -> Tuple[object, object, object] \u00b6 CROUZEIX_RAVIART_COTMATRIX Compute the Crouzeix-Raviart cotangent stiffness matrix. Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns L #E by #E edge/face-based diagonal cotangent matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also See also: crouzeix_raviart_massmatrix Notes None Examples See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -> object \u00b6 wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples crouzeix_raviart_massmatrix(v: array, f: array) -> Tuple[object, object, object] \u00b6 CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where edge e. \u00b6 Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns M #E by #E edge/face-based diagonal mass matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also crouzeix_raviart_cotmatrix Notes See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] Examples crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -> object \u00b6 wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples cut_mesh(v: array, f: array, cuts: array) -> Tuple[object, object] \u00b6 Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V cuts : #F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) Returns A pair (vcut, fcut) where: vcut is a #v by 3 list of the vertex positions of the cut mesh. This matrix will be similar to the original vertices except some rows will be duplicated. fcut is a #f by 3 list of the faces of the cut mesh (must be triangles). This matrix will be similar to the original face matrix except some indices will be redirected to point to the newly duplicated vertices. See also Notes Examples cut_mesh_from_singularities(v: array, f: array, mismatch: array) -> object \u00b6 Given a mesh (v,f) and the integer mismatch of a cross field per edge (mismatch), finds and returns the cut_graph connecting the singularities (seams) Parameters v : #v by 3 array of triangle vertices (each row is a vertex) f : #f by 3 array of triangle indices into v mismatch : #f by 3 array of per-corner integer mismatches Returns seams : #f by 3 array of per corner booleans that de**notes if an edge is a** seam or not See also cut_mesh Notes Examples cylinder(axis_devisions: int, height_devisions: int) -> Tuple[object, object] \u00b6 Construct a triangle mesh of a cylinder (without caps) Parameters axis_devisions number of vertices around the cylinder height_devisions number of vertices up the cylinder Returns V #V by 3 list of mesh vertex positions F #F by 3 list of triangle indices into V See also Notes None Examples decimate(v: array, f: array, max_m: int) -> Tuple[bool, object, object, object, object] \u00b6 Assumes (V,F) is a manifold mesh (possibly with boundary) Collapses edges until desired number of faces is achieved. This uses default edge cost and merged vertex placement functions {edge length, edge midpoint}. Parameters V #V by dim list of vertex positions F #F by 3 list of face indices into V. max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices Returns true if m was reached (otherwise #G > m) See also Notes None Examples dihedral_angles(v: array, t: array) -> Tuple[object, object] \u00b6 Compute dihedral angles for all tets of a given tet mesh (v, t). Parameters v : #v by dim list of vertex positions t : #v by 4 list of tet indices Returns theta : #t by 6 list of dihedral angles (in radians) cos_theta : #t by 6 list of cosine of dihedral angles (in radians) See also Notes None Examples TetMesh in (v, t) theta, cos_theta = dihedral_angles(v, t) dihedral_angles_intrinsic(l: array, a: array) -> Tuple[object, object] \u00b6 See dihedral_angles for the documentation. directed_edge_parents(e: array) -> object \u00b6 Recover \u201cparents\u201d (preceding edges) in a tree given just directed edges. Parameters e : #e by 2 list of directed edges Returns p : #e list of parent indices into e. (-1) means root See also Notes None Examples p = edges(e) doublearea(v: array, f: array) -> object \u00b6 Computes twice the area for each input triangle[quad] Parameters v : #v by dim array of mesh vertex positions f : #f by simplex_size array of mesh faces (must be triangles or quads) Returns d_area : #f list of triangle[quad] double areas (SIGNED only for 2D input) See also None Notes Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal if you have 1million unreferenced vertices and 1 face Examples Mesh in (v, f) dbl_area = doublearea(v, f) ears(f: array) -> Tuple[object, object] \u00b6 FIND_EARS Find all ears (faces with two boundary edges) in a given mesh Parameters F #F by 3 list of triangle mesh indices Returns ears #ears list of indices into F of ears ear_opp #ears list of indices indicating which edge is non-boundary (connecting to flops) See also Notes None Examples ears,ear_opp = find_ears(F) edge_topology(v: array, f: array) -> Tuple[object, object, object] \u00b6 Initialize Edges and their topological relations (assumes an edge-manifold mesh) Parameters v : #v by dim, list of mesh vertex positions (unused) f : #f by 3, list of triangle indices into V Returns ev : #e by 2, list of edges described as pair of vertices. fe : #f by 3, list storing triangle-edge relation. ef : #e by w, list storing edge-triangle relation, uses -1 to indicate boundaries. See also Notes None Examples Mesh in (v, f) ev, fe, ef = edge_topology(v, f) edges(f: array) -> object \u00b6 Constructs a list of unique edges represented in a given mesh (v, f) Parameters f : #F by dim list of mesh faces (must be triangles or tets) Returns #e by 2 list of edges in no particular order See also adjacency_matrix Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) E = igl.edges(F) euler_characteristic(f: array) -> int \u00b6 Computes the Euler characteristic of a given mesh (V,F) Parameters F #F by dim list of mesh faces (must be triangles) Returns Returns An int containing the Euler characteristic See also Notes None Examples euler_characteristic_complete(v: array, f: array) -> int \u00b6 Parameters V #V by dim list of mesh vertex positions Returns See also Notes None Examples exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array None = None, ft: numpy.array None = None) -> object \u00b6 Exact geodesic algorithm for the calculation of geodesics on a triangular mesh. Parameters v : #v by 3 array of 3D vertex positions f : #f by 3 array of mesh faces vs : #vs by 1 array specifying indices of source vertices fs : #fs by 1 array specifying indices of source faces vt : #vt by 1 array specifying indices of target vertices ft : #ft by 1 array specifying indices of target faces Returns d : #vt+#ft by 1 array of geodesic distances of each target w.r.t. the nearest one in the source set See also Notes Specifying a face as target/source means its center. Implementation from https:code.google.com/archive/p/geodesic/ with the algorithm first described by Mitchell, Mount and Papadimitriou in 1987. Examples face_components(f: array) -> object \u00b6 Compute connected components of facets based on edge-edge adjacency, Parameters f : #f x 3 array of triangle indices Returns An array, c, with shape (#f,), of component ids See also vertex_components vertex_components_from_adjacency_matrix Notes Examples fit_plane(v: array) -> Tuple[object, object] \u00b6 This function fits a plane to a point cloud. Parameters V #Vx3 matrix. The 3D point cloud, one row for each vertex. Returns N 1x3 Vector. The normal of the fitted plane. C 1x3 Vector. A point that lies in the fitted plane. See also Notes From http:missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html Examples flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function<double (Eigen::Matrix<double, -1, -1, 0, -1, -1>)>, cur_energy: float) -> Tuple[float, object] \u00b6 A bisection line search for a mesh based energy that avoids triangle flips as suggested in \u201cBijective Parameterization with Free Boundaries\u201d (Smith J. and Schaefer S., 2015). The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles). This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see igl::line_search). Supports both triangle and tet meshes. Parameters F #F by \u00be list of mesh faces or tets cur_v #V by dim list of variables dst_v #V by dim list of target vertices. This mesh may have flipped triangles energy A function to compute the mesh-based energy (return an energy that is bigger than 0) cur_energy(OPTIONAL) The energy at the given point. Helps save redundant c omputations. This is optional. If not specified, the function will compute it. \u00b6 Returns cur_v #V by dim list of variables at the new location Returns the energy at the new point See also Notes None Examples gaussian_curvature(v: array, f: array) -> object \u00b6 Compute discrete local integral gaussian curvature (angle deficit, without averaging by local area). Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices Returns k : #v by 1 array of discrete gaussian curvature values See also principal_curvature Notes None Examples Mesh in (v, f) k = gaussian_curvature(v, f) grad(v: array, f: array, uniform: bool = False) -> object \u00b6 Compute the numerical gradient operator. Parameters v : #v by 3 list of mesh vertex positions f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices] uniform : boolean (default false). Use a uniform mesh instead of the vertices v Returns g : #faces * dim by #v gradient operator See also cotmatrix, massmatrix Notes Gradient of a scalar function defined on piecewise linear elements (mesh) is constant on each triangle [tetrahedron] i,j,k: grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A \u00b6 where Xi is the scalar value at vertex i, Vi is the 3D position of vertex i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of 90 degrees. Examples Mesh in (v, f) g = grad(v, f) harmonic(l: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, b: array, bc: array, k: int) -> object \u00b6 Compute a harmonic map using a given Laplacian and mass matrix Parameters L #V by #V discrete (integrated) Laplacian M #V by #V mass matrix b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #V list of weights See also Notes Examples harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, k: int) -> object \u00b6 Build the discrete k-harmonic operator (computing integrated quantities). That is, if the k-harmonic PDE is Q x = 0, then this minimizes x\u2019 Q x Parameters L #V by #V discrete (integrated) Laplacian M #V by #V mass matrix k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns Q #V by #V discrete (integrated) k-Laplacian See also Notes Examples harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -> object \u00b6 Compute harmonic map using uniform laplacian operator Parameters F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -> object \u00b6 Compute k-harmonic weight functions \u201ccoordinates\u201d. Parameters V #V by dim vertex positions F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples hausdorff(va: array, fa: array, vb: array, fb: array) -> float \u00b6 HAUSDORFF compute the Hausdorff distance between mesh (VA,FA) and mesh (VB,FB). This is the a\u2208A b\u2208B b\u2208B a\u2208A \u00b6 Parameters VA #VA by 3 list of vertex positions FA #FA by 3 list of face indices into VA VB #VB by 3 list of vertex positions FB #FB by 3 list of face indices into VB Returns d hausdorff distance pair 2 by 3 list of \u201cdeterminer points\u201d so that pair(1,:) is from A and pair(2,:) is from B See also Notes Known issue: This is only computing max(min(va,B),min(vb,A)). This is better than max(min(va,Vb),min(vb,Va)). This (at least) is missing \u201cedge-edge\u201d cases like the distance between the two different triangulations of a non-planar quad in 3D. Even simpler, consider the Hausdorff distance between the non-convex, block letter V polygon (with 7 vertices) in 2D and its convex hull. The Hausdorff distance is defined by the midpoint in the middle of the segment across the concavity and some non-vertex point on the edge of the V. Examples internal_angles(v: array, f: array) -> object \u00b6 Computes internal angles for a triangle mesh. Parameters v : #v by dim array of mesh vertex nD positions f : #f by poly-size array of face (triangle) indices Returns k : #f by poly-size array of internal angles. For triangles, columns correspond to edges [1,2],[2,0],[0,1]. See also None Notes If poly-size \u2260 3 then dim must equal 3. Examples is_edge_manifold(f: array) -> bool \u00b6 See is_edge_manifold for the documentation. is_irregular_vertex(v: array, f: array) -> std::__1::vector<bool, std::__1::allocator<bool> > \u00b6 Determine if a vertex is irregular, i.e. it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored. Parameters v : #v by dim array of vertex positions f : #f by 3[4] array of triangle[quads] indices Returns s : #v list of bools revealing whether vertices are singular See also None Notes None Examples isolines(v: array, f: array, z: array, n: int) -> Tuple[object, object] \u00b6 Constructs isolines for a function z given on a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of mesh faces (must be triangles) z #V by 1 list of function values evaluated at vertices n the number of desired isolines Returns isoV #isoV by dim list of isoline vertex positions isoE #isoE by 2 list of isoline edge positions See also Notes None Examples lscm(v: array, f: array, b: array, bc: array) -> Tuple[bool, object] \u00b6 Compute a Least-squares conformal map parametrization. Parameters v : #v by 3 array of mesh vertex positions f : #f by 3 array of mesh faces (must be triangles) b : #b boundary indices into v bc : #b by 3 list of boundary values Returns uv #v by 2 list of 2D mesh vertex positions in UV space See also None Notes Derived in \u201cIntrinsic Parameterizations of Surface Meshes\u201d [Desbrun et al. 2002] and \u201cLeast Squares Conformal Maps for Automatic Texture Atlas Generation\u201d [L\u00e9vy et al. 2002]), though this implementation follows the derivation in: \u201cSpectral Conformal Parameterization\u201d [Mullen et al. 2008] (note, this does not implement the Eigen-decomposition based method in [Mullen et al. 2008], which is not equivalent. Input should be a manifold mesh (also no unreferenced vertices) and \u201cboundary\u201d (fixed vertices) b should contain at least two vertices per connected component. Returns true only on solver success. Examples map_vertices_to_circle(v: array, bnd: array) -> object \u00b6 Map the vertices whose indices are in a given boundary loop (bnd) on the unit circle with spacing proportional to the original boundary edge lengths. Parameters v : #v by dim array of mesh vertex positions b : #w list of vertex ids Returns uv : #w by 2 list of 2D positions on the unit circle for the vertices in b See also None Notes None Examples massmatrix(v: array, f: array, type: int = 1) -> object \u00b6 Constructs the mass (area) matrix for a given mesh (V,F). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) type : one of the following types: -igl.MASSMATRIX_TYPE_BARYCENTRIC barycentric -igl.MASSMATRIX_TYPE_VORONOI voronoi-hybrid (default) -igl.MASSMATRIX_TYPE_FULL full (not implemented) Returns m : #v by #v mass matrix See also adjacency_matrix, cotmatrix, grad Notes Examples min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -> object \u00b6 MIN_QUAD_WITH_FIXED Minimize quadratic energy Z\u2019*A*Z + Z\u2019*B + C subject to linear constraints Aeq*Z = Beq Parameters A n by n matrix of quadratic coefficients B n by 1 column of linear coefficients Aeq m by n list of linear equality constraint coefficients Beq m by 1 list of linear equality constraint constant values use_lu_decomposition use lu rather than SVD Returns S n by (n + m) \u201csolve\u201d matrix, such that S*[B\u2019, Beq\u2019] is a solution See also Notes None Examples orientable_patches(f: array) -> Tuple[object, object] \u00b6 Compute connected components of facets connected by manifold edges. Parameters f : n by dim array of face ids Returns A tuple (c, A) where c is an array of component ids (starting with 0) and A is a #f x #f adjacency matri See also components Notes Known bugs: This will detect a moebius strip as a single patch (manifold, non-orientable) and also non-manfiold, yet orientable patches. Examples oriented_facets(f: array) -> object \u00b6 Determines all \u2018directed facets \u2018 of a given set of simplicial elements. For a manifold triangle mesh, this computes all half-edges. For a manifold tetrahedral mesh, this computes all half-faces. Parameters f : #F by simplex_size list of simplices Returns #E : by simplex_size-1 list of half-edges/facets See also edges Notes This is not the same as igl::edges because this includes every directed edge including repeats (meaning interior edges on a surface will show up once for each direction and non-manifold edges may appear more than once for each direction). Examples per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -> Tuple[object, object, object] \u00b6 Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices weight weighting type FN #F by 3 matrix of 3D face normals per face Returns N #2 by 3 matrix of mesh edge 3D normals per row E #E by 2 matrix of edge indices per row EMAP #E by 1 matrix of indices from all edges to E See also Notes None Examples per_face_normals(v: array, f: array, z: array) -> object \u00b6 Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices Z 3 vector normal given to faces with degenerate normal. Returns N #F by 3 eigen Matrix of mesh face (triangle) 3D normals See also Notes None Examples Give degenerate faces (\u2153,\u2153,\u2153)^0.5 per_face_normals(V,F,Vector3d(1,1,1).normalized(),N); \u00b6 per_vertex_attribute_smoothing(ain: array, f: array) -> object \u00b6 Smooth vertex attributes using uniform Laplacian Parameters Ain #V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes) F #F by 3 eigne Matrix of face (triangle) indices Returns Aout #V by #A eigen Matrix of mesh vertex attributes See also Notes None Examples per_vertex_normals(v: array, f: array, weighting: int = 0) -> object \u00b6 Compute vertex normals via vertex position list, face list. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices weighting : Weighting type, one of the following -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM uniform influence -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA area weighted -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE angle weighted Returns n #v by 3 array of mesh vertex 3D normals See also per_face_normals, per_edge_normals Notes None Examples Mesh in (v, f) n = per_vertex_normals(v, f) piecewise_constant_winding_number(f: array) -> bool \u00b6 PIECEWISE_CONSTANT_WINDING_NUMBER Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input to solid set operations. Assumes that (V,F) contains no -intersections (including degeneracies and co-incidences). If there are co-planar and co-incident vertex placements, a mesh could fail this combinatorial test but still induce a piecewise-constant winding number geometrically . For example, consider a hemisphere with boundary and then pinch the boundary \u201cshut\u201d along a line segment. The bullet-proof check is to first resolve all -intersections in (V,F) -> (SV,SF) (i.e. what the igl::copyleft::cgal::piecewise_constant_winding_number overload does). Parameters F #F by 3 list of triangle indices into some (abstract) list of vertices V Returns Returns true if the mesh combinatorially induces a piecewise constant winding number field. See also Notes None Examples principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -> Tuple[object, object, object, object] \u00b6 Compute the principal curvature directions and magnitude of the given triangle mesh. Parameters v : vertex array of size #V by 3 f : face index array #F by 3 list of mesh faces (must be triangles) radius : controls the size of the neighbourhood used, 1 = average edge length (default: 5) use_k_ring : (default: True) Returns pd1 : #v by 3 maximal curvature direction for each vertex pd2 : #v by 3 minimal curvature direction for each vertex pv1 : #v by 1 maximal curvature value for each vertex pv2 : #v by 1 minimal curvature value for each vertex See also average_onto_faces, average_onto_vertices Notes This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo. The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010 Examples Mesh in (v, f) pd1, pd2, pv1, pv2 = principal_curvature(v, f) procrustes(x: array, y: array) -> Tuple[bool, bool, float, object, object] \u00b6 Solve Procrustes problem in d dimensions. Given two point sets X,Y in R^d find best scale s, orthogonal R and translation t s.t. s*X*R + t - Y^2 is minimized. Parameters X #V by DIM first list of points Y #V by DIM second list of points includeScaling if scaling should be allowed includeReflections if R is allowed to be a reflection Returns scale scaling R orthogonal matrix t translation See also Notes None Examples MatrixXd X, Y; (containing 3d points as rows) double scale; MatrixXd R; VectorXd t; igl::procrustes(X,Y,true,false,scale,R,t); R *= scale; MatrixXd Xprime = (X * R).rowwise() + t.transpose(); qslim(v: array, f: array, max_m: int) -> Tuple[bool, object, object, object, object] \u00b6 Decimate (simplify) a triangle mesh in nD according to the paper \u201cSimplifying Surfaces with Color and Texture using Quadric Error Metrics\u201d by [Garland and Heckbert, 1987] (technically a followup to qslim). The mesh can have open boundaries but should be edge-manifold. Parameters V #V by dim list of vertex positions. Assumes that vertices w F #F by 3 list of triangle indices into V max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices See also Notes None Examples quad_planarity(v: array, f: array) -> object \u00b6 Compute planarity of the faces of a quad mesh. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 4 array of face (quad) indices Returns p : #f by 1 array of mesh face (quad) planarities See also None Notes None Examples random_points_on_mesh(n: int, v: array, f: array) -> Tuple[object, object] \u00b6 RANDOM_POINTS_ON_MESH Randomly sample a mesh (V,F) n times. Parameters n number of samples V #V by dim list of mesh vertex positions F #F by 3 list of mesh triangle indices Returns B n by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) FI n list of indices into F See also Notes None Examples read_dmat(filename: str, dtype: numpy.dtype str type = 'float64') -> object \u00b6 Read a matrix from an ascii dmat file, a simple ascii matrix file type, defined as follows. The first line is always: <#columns> <#rows> Then the coefficients of the matrix are given separated by whitespace with columns running fastest. Parameters filename : string, path to .dmat file dtype : data-type of the returned matrix. Default is float64 . (returned faces always have type int32.) Returns w : array containing read-in coefficients See also read_triangle_mesh, read_off Notes None Examples w = read_dmat(\u201cmy_model.dmat\u201d) read_obj(filename: str, dtype: numpy.dtype str type = 'float64') -> Tuple[object, object, object, object, object, object] \u00b6 Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .obj file dtype : data-type of the returned faces, texture coordinates and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 tc : array of texture coordinats #tc by 2 n : array of corner normals #n by 3 f : #f array of face indices into vertex positions ftc : #f array of face indices into vertex texture coordinates fn : #f array of face indices into vertex normals See also read_triangle_mesh, read_off Notes None Examples v, _, n, f, _, _ = read_obj(\u201cmy_model.obj\u201d) read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype str type = 'float64') -> Tuple[object, object, object] \u00b6 Read a mesh from an ascii off file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .off file read_normals : bool, determines whether normals are read. If false, returns [] dtype : data-type of the returned vertices, faces, and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions n : list of vertex normals #v by 3 See also read_triangle_mesh, read_obj Notes None Examples v, f, n, c = read_off(\u201cmy_model.off\u201d) read_triangle_mesh(filename: str, dtype: numpy.dtype str type = 'float64') -> Tuple[object, object] \u00b6 Read mesh from an ascii file with automatic detection of file format. Supported: obj, off, stl, wrl, ply, mesh. Parameters filename : string, path to mesh file dtype : data-type of the returned vertices, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions See also read_obj, read_off, read_stl Notes None Examples v, f = read_triangle_mesh(\u201cmy_model.obj\u201d) remove_duplicate_vertices(v: array, f: array, epsilon: float) -> Tuple[object, object, object, object] \u00b6 REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness tolerance (epsilon) Parameters V #V by dim list of vertex positions epsilon uniqueness tolerance (significant digit), can probably think of this as a tolerance on L1 distance Returns SV #SV by dim new list of vertex positions SVI #V by 1 list of indices so SV = V(SVI,:) SVJ #SV by 1 list of indices so V = SV(SVJ,:) Wrapper that also remaps given faces (F) \u2192 (SF) so that SF index SV See also Notes None Examples % Mesh in (V,F) [SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7); % remap faces SF = SVJ(F); remove_duplicates(v: array, f: array, epsilon: float) -> Tuple[object, object, object] \u00b6 Merge the duplicate vertices from V, fixing the topology accordingly Parameters V,F mesh description epsilon minimal distance to consider two vertices identical Returns NV, NF new mesh without duplicate vertices See also Notes None Examples remove_unreferenced(v: array, f: array) -> Tuple[object, object, object, object] \u00b6 Remove unreferenced vertices from V, updating F accordingly Parameters V #V by dim list of mesh vertex positions F #F by ss list of simplices (Values of -1 are quitely skipped) Returns NV #NV by dim list of mesh vertex positions NF #NF by ss list of simplices IM #V by 1 list of indices such that: NF = IM(F) and NT = IM(T) and V(find(IM<=size(NV,1)),:) = NV J #RV by 1 list, such that RV = V(J,:) See also Notes None Examples resolve_duplicated_faces(f1: array) -> Tuple[object, object] \u00b6 Resolve duplicated faces according to the following rules per unique face: If the number of positively oriented faces equals the number of \u00b6 negatively oriented faces, remove all duplicated faces at this triangle. If the number of positively oriented faces equals the number of \u00b6 negatively oriented faces plus 1, keeps one of the positively oriented face. If the number of positively oriented faces equals the number of \u00b6 negatively oriented faces minus 1, keeps one of the negatively oriented face. If the number of postively oriented faces differ with the number of \u00b6 negativley oriented faces by more than 1, the mesh is not orientable. An exception will be thrown. Parameters F1 #F1 by 3 array of input faces. Returns F2 #F2 by 3 array of output faces without duplicated faces. J #F2 list of indices into F1. See also Notes None Examples shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -> object \u00b6 Compute shape diamater function per given point. In the parlence of the paper \u201cConsistent Mesh Partitioning and Skeletonisation using the Shape Diameter Function\u201d [Shapiro et al. 2008], this implementation uses a 180\u00b0 cone and a uniform average ( not a average weighted by inverse angles). Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of shape diamater function values between bounding box diagonal (perfect sphere) and 0 (perfect needle hook) See also Notes None Examples sort_angles(m: array) -> object \u00b6 Sort angles in ascending order in a numerically robust way. Instead of computing angles using atan2(y, x), sort directly on (y, x). Parameters - M: m by n matrix of scalars. (n >= 2). Assuming the first column of M contains values for y, and the second column is x. Using the rest of the columns as tie-breaker. Returns R: an array of m indices. M.row(R[i]) contains the i-th smallest angle. See also Notes None. Examples tetrahedralize(v: array, f: array, switches: str = 'pYQ') -> Tuple[int, object, object, object] \u00b6 Mesh the interior of a surface mesh (V,F) using tetgen. Parameters v : #v by 3 vertex position array f : #v array of polygon face indices into V (0-indexed) switches : string of tetgen options (See tetgen documentation) e.g. \u201cpq1.414a0.01\u201d tries to mesh the interior of a given surface with quality and area constraints. Will mesh the convex hull constrained to pass through V (ignores F) Returns tv #v by 3 vertex position array tt #t by 4 array of tet face indices tf #f by 3 array of triangle face indices See also None Notes Returns status: 0 success 1 tetgen threw exception 2 tetgen did not crash but could not create any tets (probably there are holes, duplicate faces etc.) -1 other error Examples triangle_triangle_adjacency(f: array) -> Tuple[object, object] \u00b6 Constructs the triangle-triangle adjacency matrix for a given mesh (V,F). Parameters F #F by simplex_size list of mesh faces (must be triangles) Returns TT #F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i TTi #F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i See also Notes NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third [2,3]. this convention is DIFFERENT from cotmatrix_entries.h Examples triangulate(v: array, e: array, h: array, flags: str = 'a0.005qQ') -> Tuple[object, object] \u00b6 Triangulate the interior of a polygon using the triangle library. Parameters v : #v by 2 array of 2D vertex positions e : #e by 2 array of vertex ids forming unoriented edges of the boundary of the polygon h : #h by 2 coordinates of points contained inside holes of the polygon m : optional #v list of markers for input vertices flags : string of options pass to triangle (see triangle documentation) (default \u2018a0.005q\u2019) Returns v2 : #v2 by 2 coordinates of the vertives of the generated triangulation f2 : #f2 by 3 array of indices forming the faces of the generated triangulation m2 : (only if you passed in m) #v2 list of markers for output vertices See also Notes Examples v2, f2 = triangulate(v, e, h) uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -> object \u00b6 Find uniform sampling up to placing samples on mesh vertices Parameters Returns See also Notes None Examples uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -> object \u00b6 UNIFORMLY_SAMPLE_TWO_MANIFOLD Attempt to sample a mesh uniformly by furthest point relaxation as described in \u201cFast Automatic Skinning Transformations\u201d [Jacobson et al. 12] Section 3.3. Parameters W #W by dim positions of mesh in weight space F #F by 3 indices of triangles k number of samplse push factor by which corners should be pushed away Returns WS k by dim locations in weights space See also Notes None Examples unproject(win: array, model: array, proj: array, viewport: array) -> object \u00b6 Reimplementation of gluUnproject Parameters win #P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns scene #P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates See also Notes None Examples unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -> Tuple[object, std::__1::vector<igl::Hit, std::__1::allocator<igl::Hit> >] \u00b6 Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position inside a given mesh. If the ray through the given screen location (x,y) hits the mesh more than twice then the 3D midpoint between the first two hits is return. If it hits once, then that point is return. If it does not hit the mesh then obj is not set. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns obj 3d unprojected mouse point in mesh hits vector of hits Returns number of hits See also Notes None Examples unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -> Tuple[bool, int, object] \u00b6 Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position onto a given mesh, if the ray through the given screen location (x,y) hits the mesh. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns fid id of the first face hit bc barycentric coordinates of hit Returns true if there\u2019s a hit See also Notes None Examples unproject_ray(pos: array, model: array, proj: array, viewport: array) -> Tuple[object, object] \u00b6 Construct a ray (source point + direction vector) given a screen space positions (e.g. mouse) and a model-view projection constellation. Parameters pos 2d screen-space position (x,y) model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns s source of ray (pos unprojected with z=0) dir direction of ray (d - s) where d is pos unprojected with z=1 See also Notes None Examples upsample(v: array, f: array, number_of_subdivs: int = 1) -> Tuple[object, object] \u00b6 Subdivide a mesh without moving vertices: loop subdivision but odd vertices stay put and even vertices are just edge midpoints Parameters V #V by dim mesh vertices F #F by 3 mesh triangles Returns NV new vertex positions, V is guaranteed to be at top NF new list of face indices See also Notes assumes (V,F) is edge-manifold. Examples vector_area_matrix(f: array) -> object \u00b6 Constructs the symmetric area matrix A, s.t. [V.col(0)\u2019 V.col(1)\u2019] * A * [V.col(0); V.col(1)] is the vector area of the mesh (V,F). Parameters f : #f by 3 array of mesh faces (must be triangles) Returns a : #vx2 by #vx2 area matrix See also None Notes None Examples vertex_components(f: array) -> object \u00b6 Compute connected components of the vertices of a mesh given the mesh\u2019 face indices. Parameters f : #f x dim array of face indices Returns An array of component ids (starting with 0) See also vertex_components_from_adjacency_matrix face_components_from_faces Notes Examples vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix scipy.sparse.csc_matrix) -> Tuple[object, object] \u00b6 Compute connected components of a graph represented by a sparse adjacency matrix. Parameters a : n by n sparse adjacency matrix Returns A tuple (c, counts) where c is an array of component ids (starting with 0) and counts is a #components array of counts for each component See also vertex_components face_components Notes Examples vertex_triangle_adjacency(f: array, n: int) -> Tuple[object, object] \u00b6 vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F) Parameters F #F by 3 list of triangle indices into some vertex list V n number of vertices, #V (e.g., F.maxCoeff()+1) Returns VF 3*#F list List of faces indice on each vertex, so that VF(NI(i)+j) = f, means that face f is the jth face (in no particular order) incident on vertex i. NI #V+1 list cumulative sum of vertex-triangle degrees with a preceeding zero. \u201cHow many faces\u201d have been seen before visiting this vertex and its incident faces. See also Notes None Examples winding_number(v: array, f: array, o: array) -> object \u00b6 WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron described by points (vectors) V Parameters V n by 3 list of vertex positions F #F by 3 list of triangle indices, minimum index is 0 O no by 3 list of origin positions Returns S no by 1 list of winding numbers See also Notes None Examples winding_number_for_point(v: array, f: array, p: array) -> float \u00b6 Compute winding number of a single point Parameters V n by dim list of vertex positions F #F by dim list of triangle indices, minimum index is 0 p single origin position Returns w winding number of this point See also Notes None Examples write_obj(filename: str, v: array, f: array) -> bool \u00b6 Write a mesh in an ascii obj file. Parameters filename : path to outputfile v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions Returns ret : bool if output was successful See also read_obj Notes None Examples Mesh in (v, f) success = write_obj(v, f) write_off(str: str, v: array, f: array, c: array) -> bool \u00b6 Export geometry and colors-by-vertex Export a mesh from an ascii OFF file, filling in vertex positions. Only triangle meshes are supported Parameters str path to .off output file V #V by 3 mesh vertex positions F #F by 3 mesh indices into V C double matrix of rgb values per vertex #V by 3 Returns Returns true on success, false on errors See also Notes None Examples write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -> bool \u00b6 write mesh to a file with automatic detection of file format. supported: obj, off, stl, wrl, ply, mesh). Parameters str path to file V eigen double matrix #V by 3 F eigen int matrix #F by 3 force_ascii=True force ascii format even if binary is available Returns Returns true iff success See also Notes Examples VERSION dev FILE /Users/teseo/data/igl/python/igl/pyigl.cpython-36m-darwin.so igl.adjacency_list = adjacency_list(\u2026) method of builtins.PyCapsule instance adjacency_list(f: array) -> handle \u00b6 Constructs the graph adjacency list of a given mesh (v, f) Parameters f : #f by dim array of fixed dimensional (e.g. triangle (#f by 3), tet (#f by 4), quad (#f by 4), etc\u2026) mesh faces Returns list of lists containing at index i the adjacent vertices of vertex i See also adjacency_matrix Notes Examples Mesh in (v, f) a = mesh_adjacency_list(f) igl.adjacency_list = adjacency_list(\u2026) method of builtins.PyCapsule instance adjacency_list(f: array) -> handle \u00b6 Constructs the graph adjacency list of a given mesh (v, f) Parameters f : #f by dim array of fixed dimensional (e.g. triangle (#f by 3), tet (#f by 4), quad (#f by 4), etc\u2026) mesh faces Returns list of lists containing at index i the adjacent vertices of vertex i See also adjacency_matrix Notes Examples Mesh in (v, f) a = mesh_adjacency_list(f) igl.adjacency_matrix = adjacency_matrix(\u2026) method of builtins.PyCapsule instance adjacency_matrix(f: array) -> object \u00b6 Constructs the graph adjacency matrix of a given mesh (v, f). Parameters f : #f by dim list of mesh simplices Returns a : max(f) by max(f) cotangent matrix, each row i corresponding to v(i, :) See also adjacency_list, edges, cotmatrix, diag Notes None Examples Mesh in (v, f) a = adjacency_matrix(f) Sum each row a_sum = np.sum(a, axis=1) Convert row sums into diagonal of sparse matrix a_diag = diag(a_sum) Build uniform laplacian u = a - a_diag igl.adjacency_matrix = adjacency_matrix(\u2026) method of builtins.PyCapsule instance adjacency_matrix(f: array) -> object \u00b6 Constructs the graph adjacency matrix of a given mesh (v, f). Parameters f : #f by dim list of mesh simplices Returns a : max(f) by max(f) cotangent matrix, each row i corresponding to v(i, :) See also adjacency_list, edges, cotmatrix, diag Notes None Examples Mesh in (v, f) a = adjacency_matrix(f) Sum each row a_sum = np.sum(a, axis=1) Convert row sums into diagonal of sparse matrix a_diag = diag(a_sum) Build uniform laplacian u = a - a_diag igl.ambient_occlusion = ambient_occlusion(\u2026) method of builtins.PyCapsule instance ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -> object \u00b6 Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of ambient occusion values between 1 (fully occluded) and 0 (not occluded) See also Notes None Examples igl.ambient_occlusion = ambient_occlusion(\u2026) method of builtins.PyCapsule instance ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -> object \u00b6 Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of ambient occusion values between 1 (fully occluded) and 0 (not occluded) See also Notes None Examples igl.arap_linear_block = arap_linear_block(\u2026) method of builtins.PyCapsule instance arap_linear_block(v: array, f: array, d: int, energy: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block = arap_linear_block(\u2026) method of builtins.PyCapsule instance arap_linear_block(v: array, f: array, d: int, energy: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_elements = arap_linear_block_elements(\u2026) method of builtins.PyCapsule instance arap_linear_block_elements(v: array, f: array, d: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_elements = arap_linear_block_elements(\u2026) method of builtins.PyCapsule instance arap_linear_block_elements(v: array, f: array, d: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_spokes = arap_linear_block_spokes(\u2026) method of builtins.PyCapsule instance arap_linear_block_spokes(v: array, f: array, d: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_spokes = arap_linear_block_spokes(\u2026) method of builtins.PyCapsule instance arap_linear_block_spokes(v: array, f: array, d: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_spokes_and_rims = arap_linear_block_spokes_and_rims(\u2026) method of builtins.PyCapsule instance arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_spokes_and_rims = arap_linear_block_spokes_and_rims(\u2026) method of builtins.PyCapsule instance arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -> object \u00b6 Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_rhs = arap_rhs(\u2026) method of builtins.PyCapsule instance arap_rhs(v: array, f: array, d: int, energy: int) -> object \u00b6 Guild right-hand side constructor of global poisson solve for various ARAP energies Inputs: Outputs: K #V*dim by #(FV)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); Parameters v : #v by Vdim list of initial domain positions f : #f by 3 list of triangle indices into v d : dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2 energy : ARAPEnergyType enum value defining which energy is being used. See igl.ARAPEnergyType for valid options and explanations. Returns *d by #(fv)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); See also arap_linear_block, arap Notes Examples igl.arap_rhs = arap_rhs(\u2026) method of builtins.PyCapsule instance arap_rhs(v: array, f: array, d: int, energy: int) -> object \u00b6 Guild right-hand side constructor of global poisson solve for various ARAP energies Inputs: Outputs: K #V*dim by #(FV)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); Parameters v : #v by Vdim list of initial domain positions f : #f by 3 list of triangle indices into v d : dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2 energy : ARAPEnergyType enum value defining which energy is being used. See igl.ARAPEnergyType for valid options and explanations. Returns *d by #(fv)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); See also arap_linear_block, arap Notes Examples igl.average_onto_vertices = average_onto_vertices(\u2026) method of builtins.PyCapsule instance average_onto_vertices(v: array, f: array, s: array) -> object \u00b6 Move a scalar field defined on faces to vertices by averaging Parameters v : #v by vdim array of mesh vertices f : #f by simplex_count array of simplex indices s : #f by dim scalar field defined on simplices Returns by dim scalar field defined on vertices See also average_onto_faces Notes Examples igl.average_onto_vertices = average_onto_vertices(\u2026) method of builtins.PyCapsule instance average_onto_vertices(v: array, f: array, s: array) -> object \u00b6 Move a scalar field defined on faces to vertices by averaging Parameters v : #v by vdim array of mesh vertices f : #f by simplex_count array of simplex indices s : #f by dim scalar field defined on simplices Returns by dim scalar field defined on vertices See also average_onto_faces Notes Examples igl.avg_edge_length = avg_edge_length(\u2026) method of builtins.PyCapsule instance avg_edge_length(v: array, f: array) -> float \u00b6 Compute the average edge length for the given triangle mesh. Parameters v : array_like #v by 3 vertex array f : f #f by simplex-size list of mesh faces (must be simplex) Returns l : average edge length See also adjacency_matrix Notes None Examples Mesh in (v, f) length = avg_edge_length(v, f) igl.avg_edge_length = avg_edge_length(\u2026) method of builtins.PyCapsule instance avg_edge_length(v: array, f: array) -> float \u00b6 Compute the average edge length for the given triangle mesh. Parameters v : array_like #v by 3 vertex array f : f #f by simplex-size list of mesh faces (must be simplex) Returns l : average edge length See also adjacency_matrix Notes None Examples Mesh in (v, f) length = avg_edge_length(v, f) igl.barycenter = barycenter(\u2026) method of builtins.PyCapsule instance barycenter(v: array, f: array) -> object \u00b6 Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V Returns A #f x dim matrix where each row is the barycenter of each simplex See also Notes None Examples igl.barycenter = barycenter(\u2026) method of builtins.PyCapsule instance barycenter(v: array, f: array) -> object \u00b6 Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V Returns A #f x dim matrix where each row is the barycenter of each simplex See also Notes None Examples igl.barycentric_coordinates_tet = barycentric_coordinates_tet(\u2026) method of builtins.PyCapsule instance barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -> object \u00b6 Compute barycentric coordinates in a tet corresponding to the Euclidean coordinates in p . The input arrays a , b , c and d are the vertices of each tet. I.e. one tet is a[i, :], b[i, :], c[i, :], d[:, i] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tet corners in 3d b : #P by 3 Tet corners in 3d c : #P by 3 Tet corners in 3d d : #P by 3 Tet corners in 3d Returns by 4 list of barycentric coordinates See also Notes Examples igl.barycentric_coordinates_tet = barycentric_coordinates_tet(\u2026) method of builtins.PyCapsule instance barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -> object \u00b6 Compute barycentric coordinates in a tet corresponding to the Euclidean coordinates in p . The input arrays a , b , c and d are the vertices of each tet. I.e. one tet is a[i, :], b[i, :], c[i, :], d[:, i] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tet corners in 3d b : #P by 3 Tet corners in 3d c : #P by 3 Tet corners in 3d d : #P by 3 Tet corners in 3d Returns by 4 list of barycentric coordinates See also Notes Examples igl.barycentric_coordinates_tri = barycentric_coordinates_tri(\u2026) method of builtins.PyCapsule instance barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -> object \u00b6 Compute barycentric coordinates in a triangle corresponding to the Euclidean coordinates in p . The input arrays a , b , and c are the vertices of each triangle. I.e. one triangle is a[i, :], b[i, :], c[i, :] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tri corners in 3d b : #P by 3 Tri corners in 3d c : #P by 3 Tri corners in 3d Returns by 3 list of barycentric coordinates See also Notes Examples igl.barycentric_coordinates_tri = barycentric_coordinates_tri(\u2026) method of builtins.PyCapsule instance barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -> object \u00b6 Compute barycentric coordinates in a triangle corresponding to the Euclidean coordinates in p . The input arrays a , b , and c are the vertices of each triangle. I.e. one triangle is a[i, :], b[i, :], c[i, :] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tri corners in 3d b : #P by 3 Tri corners in 3d c : #P by 3 Tri corners in 3d Returns by 3 list of barycentric coordinates See also Notes Examples igl.bfs = bfs(\u2026) method of builtins.PyCapsule instance bfs(A: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, s: int) -> Tuple[object, object] \u00b6 Construct an array indexing into a directed graph represented by an adjacency list using breadth first search. I.e. the output is an array of vertices in breadth-first order. Parameters A : #V list of adjacency lists or #V by #V adjacency matrix s : starting node (index into A) Returns A tuple, (d, p) where: d is a #V list of indices into rows of A in the order in which graph nodes are discovered p is a #V list of indices of A of predecsors where -1 indicates root/not discovered. I.e. p[i] is the index of the vertex v which preceded d[i] in the breadth first traversal. Note that together, (d, p) form a spanning tree of the input graph See also Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) A = igl.adjacency_matrix(V, F) d, p = igl.bfs(A, V[0]) igl.bfs = bfs(\u2026) method of builtins.PyCapsule instance bfs(A: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, s: int) -> Tuple[object, object] \u00b6 Construct an array indexing into a directed graph represented by an adjacency list using breadth first search. I.e. the output is an array of vertices in breadth-first order. Parameters A : #V list of adjacency lists or #V by #V adjacency matrix s : starting node (index into A) Returns A tuple, (d, p) where: d is a #V list of indices into rows of A in the order in which graph nodes are discovered p is a #V list of indices of A of predecsors where -1 indicates root/not discovered. I.e. p[i] is the index of the vertex v which preceded d[i] in the breadth first traversal. Note that together, (d, p) form a spanning tree of the input graph See also Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) A = igl.adjacency_matrix(V, F) d, p = igl.bfs(A, V[0]) igl.bfs_orient = bfs_orient(\u2026) method of builtins.PyCapsule instance bfs_orient(f: array) -> Tuple[object, object] \u00b6 Consistently orient faces in orientable patches using BFS. Parameters f : #F by 3 list of faces Returns A tuple, (ff, c) where: ff is a #F by 3 list of faces which are consistently oriented with c is a #F array of connected component ids See also Notes Examples v, f, _ = igl.readOFF(\u201ctest.off) ff, c = igl.bfs_orient(f) igl.bfs_orient = bfs_orient(\u2026) method of builtins.PyCapsule instance bfs_orient(f: array) -> Tuple[object, object] \u00b6 Consistently orient faces in orientable patches using BFS. Parameters f : #F by 3 list of faces Returns A tuple, (ff, c) where: ff is a #F by 3 list of faces which are consistently oriented with c is a #F array of connected component ids See also Notes Examples v, f, _ = igl.readOFF(\u201ctest.off) ff, c = igl.bfs_orient(f) igl.bone_parents = bone_parents(\u2026) method of builtins.PyCapsule instance bone_parents(be: array) -> object \u00b6 BONE_PARENTS Recover \u201cparent\u201d bones from directed graph representation. Parameters BE #BE by 2 list of directed bone edges Returns P #BE by 1 list of parent indices into BE, -1 means root. See also Notes None Examples igl.bone_parents = bone_parents(\u2026) method of builtins.PyCapsule instance bone_parents(be: array) -> object \u00b6 BONE_PARENTS Recover \u201cparent\u201d bones from directed graph representation. Parameters BE #BE by 2 list of directed bone edges Returns P #BE by 1 list of parent indices into BE, -1 means root. See also Notes None Examples igl.boundary_conditions = boundary_conditions(\u2026) method of builtins.PyCapsule instance boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -> Tuple[bool, object, object] \u00b6 Compute boundary conditions for automatic weights computation. This function expects that the given mesh (V,Ele) has sufficient samples (vertices) exactly at point handle locations and exactly along bone and cage edges. Parameters V #V by dim list of domain vertices Ele #Ele by simplex-size list of simplex indices C #C by dim list of handle positions P #P by 1 list of point handle indices into C BE #BE by 2 list of bone edge indices into C CE #CE by 2 list of cage edge indices into P Returns b #b list of boundary indices (indices into V of vertices which have known, fixed values) bc #b by #weights list of known/fixed values for boundary vertices (notice the #b != #weights in general because #b will include all the intermediary samples along each bone, etc.. The ordering of the weights corresponds to [P;BE] Returns false if boundary conditions are suspicious: P and BE are empty bc is empty some column of bc doesn\u2019t have a 0 (assuming bc has >1 columns) some column of bc doesn\u2019t have a 1 (assuming bc has >1 columns) See also Notes None Examples igl.boundary_conditions = boundary_conditions(\u2026) method of builtins.PyCapsule instance boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -> Tuple[bool, object, object] \u00b6 Compute boundary conditions for automatic weights computation. This function expects that the given mesh (V,Ele) has sufficient samples (vertices) exactly at point handle locations and exactly along bone and cage edges. Parameters V #V by dim list of domain vertices Ele #Ele by simplex-size list of simplex indices C #C by dim list of handle positions P #P by 1 list of point handle indices into C BE #BE by 2 list of bone edge indices into C CE #CE by 2 list of cage edge indices into P Returns b #b list of boundary indices (indices into V of vertices which have known, fixed values) bc #b by #weights list of known/fixed values for boundary vertices (notice the #b != #weights in general because #b will include all the intermediary samples along each bone, etc.. The ordering of the weights corresponds to [P;BE] Returns false if boundary conditions are suspicious: P and BE are empty bc is empty some column of bc doesn\u2019t have a 0 (assuming bc has >1 columns) some column of bc doesn\u2019t have a 1 (assuming bc has >1 columns) See also Notes None Examples igl.boundary_facets = boundary_facets(\u2026) method of builtins.PyCapsule instance boundary_facets(t: array) -> object \u00b6 Determine boundary faces (edges) of tetrahedra (triangles). Parameters t : tetrahedron or triangle index list, m by 4/3, where m is the number of tetrahedra/triangles Returns f : list of boundary faces, n by 3/2, where n is the number of boundary faces/edges See also None Notes None Examples Mesh in (v, f) b = boundary_facets(f) igl.boundary_facets = boundary_facets(\u2026) method of builtins.PyCapsule instance boundary_facets(t: array) -> object \u00b6 Determine boundary faces (edges) of tetrahedra (triangles). Parameters t : tetrahedron or triangle index list, m by 4/3, where m is the number of tetrahedra/triangles Returns f : list of boundary faces, n by 3/2, where n is the number of boundary faces/edges See also None Notes None Examples Mesh in (v, f) b = boundary_facets(f) igl.boundary_loop = boundary_loop(\u2026) method of builtins.PyCapsule instance boundary_loop(f: array) -> object \u00b6 Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. Parameters f : #v by dim array of mesh faces Returns l : ordered list of boundary vertices of longest boundary loop See also Notes None Examples Mesh in (v, f) l = boundary_loop(f) igl.boundary_loop = boundary_loop(\u2026) method of builtins.PyCapsule instance boundary_loop(f: array) -> object \u00b6 Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. Parameters f : #v by dim array of mesh faces Returns l : ordered list of boundary vertices of longest boundary loop See also Notes None Examples Mesh in (v, f) l = boundary_loop(f) igl.bounding_box = bounding_box(\u2026) method of builtins.PyCapsule instance bounding_box(*args, **kwargs) \u00b6 bounding_box(v: array) -> Tuple[object, object] \u00b6 Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples bounding_box(v: array, pad: float) -> Tuple[object, object] \u00b6 Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples igl.bounding_box = bounding_box(\u2026) method of builtins.PyCapsule instance bounding_box(*args, **kwargs) \u00b6 bounding_box(v: array) -> Tuple[object, object] \u00b6 Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples bounding_box(v: array, pad: float) -> Tuple[object, object] \u00b6 Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples igl.bounding_box_diagonal = bounding_box_diagonal(\u2026) method of builtins.PyCapsule instance bounding_box_diagonal(v: array) -> float \u00b6 Compute the length of the diagonal of a given meshes axis-aligned bounding Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V Returns Returns length of bounding box diagonal See also Notes None Examples igl.bounding_box_diagonal = bounding_box_diagonal(\u2026) method of builtins.PyCapsule instance bounding_box_diagonal(v: array) -> float \u00b6 Compute the length of the diagonal of a given meshes axis-aligned bounding Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V Returns Returns length of bounding box diagonal See also Notes None Examples igl.centroid = centroid(\u2026) method of builtins.PyCapsule instance centroid(v: array, f: array) -> Tuple[object] \u00b6 Computes the centroid of a closed mesh using a surface integral. Parameters v : #v by dim array of rest domain positions f : #f by 3 array of triangle indices into v Returns c : dim array of centroid coordinates vol : total volume of solid See also None Notes None Examples Mesh in (v, f) c, vol = centroid(v, f) igl.centroid = centroid(\u2026) method of builtins.PyCapsule instance centroid(v: array, f: array) -> Tuple[object] \u00b6 Computes the centroid of a closed mesh using a surface integral. Parameters v : #v by dim array of rest domain positions f : #f by 3 array of triangle indices into v Returns c : dim array of centroid coordinates vol : total volume of solid See also None Notes None Examples Mesh in (v, f) c, vol = centroid(v, f) igl.circulation = circulation(\u2026) method of builtins.PyCapsule instance circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -> List[int] \u00b6 Return list of faces around the end point of an edge. Assumes data-structures are built from an edge-manifold closed mesh. Parameters e index into E of edge to circulate ccw whether to continue in ccw direction of edge (circulate around EMAP #F*3 list of indices into E, mapping each directed edge to unique \u00b6 unique edge in E EF #E by 2 list of edge flaps, EF(e,0)=f means e=(i\u2192j) is the edge of e=(j->i) \u00b6 EI #E by 2 list of edge flap corners (see above). Returns Returns list of faces touched by circulation (in cyclically order). See also Notes None Examples igl.circulation = circulation(\u2026) method of builtins.PyCapsule instance circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -> List[int] \u00b6 Return list of faces around the end point of an edge. Assumes data-structures are built from an edge-manifold closed mesh. Parameters e index into E of edge to circulate ccw whether to continue in ccw direction of edge (circulate around EMAP #F*3 list of indices into E, mapping each directed edge to unique \u00b6 unique edge in E EF #E by 2 list of edge flaps, EF(e,0)=f means e=(i\u2192j) is the edge of e=(j->i) \u00b6 EI #E by 2 list of edge flap corners (see above). Returns Returns list of faces touched by circulation (in cyclically order). See also Notes None Examples igl.circumradius = circumradius(\u2026) method of builtins.PyCapsule instance circumradius(v: array, f: array) -> object \u00b6 Compute the circumradius of each triangle in a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of triangle indices into V Returns R #F list of circumradii See also Notes None Examples R = circumradius(V, F) igl.circumradius = circumradius(\u2026) method of builtins.PyCapsule instance circumradius(v: array, f: array) -> object \u00b6 Compute the circumradius of each triangle in a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of triangle indices into V Returns R #F list of circumradii See also Notes None Examples R = circumradius(V, F) igl.collapse_small_triangles = collapse_small_triangles(\u2026) method of builtins.PyCapsule instance collapse_small_triangles(v: array, f: array, eps: float) -> object \u00b6 Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the original faces and vertices of (V,F) except any small triangles have been removed via collapse. We are not following the rules in \u201cMesh Optimization\u201d [Hoppe et al] Section 4.2. But for our purposes we don\u2019t care about this criteria. Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V eps epsilon for smallest allowed area treated as fraction of squared bounding box diagonal Returns FF #FF by 3 list of triangle indices into V See also Notes None Examples igl.collapse_small_triangles = collapse_small_triangles(\u2026) method of builtins.PyCapsule instance collapse_small_triangles(v: array, f: array, eps: float) -> object \u00b6 Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the original faces and vertices of (V,F) except any small triangles have been removed via collapse. We are not following the rules in \u201cMesh Optimization\u201d [Hoppe et al] Section 4.2. But for our purposes we don\u2019t care about this criteria. Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V eps epsilon for smallest allowed area treated as fraction of squared bounding box diagonal Returns FF #FF by 3 list of triangle indices into V See also Notes None Examples igl.connect_boundary_to_infinity = connect_boundary_to_infinity(\u2026) method of builtins.PyCapsule instance connect_boundary_to_infinity(f: array) -> object \u00b6 Connect all boundary edges to a fictitious point at infinity. Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into [V;inf inf inf], original F are guaranteed to come first. If (V,F) was a manifold mesh, now it is closed with a possibly non-manifold vertex at infinity (but it will be edge-manifold). See also Notes None Examples igl.connect_boundary_to_infinity = connect_boundary_to_infinity(\u2026) method of builtins.PyCapsule instance connect_boundary_to_infinity(f: array) -> object \u00b6 Connect all boundary edges to a fictitious point at infinity. Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into [V;inf inf inf], original F are guaranteed to come first. If (V,F) was a manifold mesh, now it is closed with a possibly non-manifold vertex at infinity (but it will be edge-manifold). See also Notes None Examples igl.connect_boundary_to_infinity_face = connect_boundary_to_infinity_face(\u2026) method of builtins.PyCapsule instance connect_boundary_to_infinity_face(v: array, f: array) -> Tuple[object, object] \u00b6 Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into VO See also Notes None Examples igl.connect_boundary_to_infinity_face = connect_boundary_to_infinity_face(\u2026) method of builtins.PyCapsule instance connect_boundary_to_infinity_face(v: array, f: array) -> Tuple[object, object] \u00b6 Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into VO See also Notes None Examples igl.connect_boundary_to_infinity_index = connect_boundary_to_infinity_index(\u2026) method of builtins.PyCapsule instance connect_boundary_to_infinity_index(f: array, inf_index: int) -> object \u00b6 Parameters inf_index index of point at infinity (usually V.rows() or F.maxCoeff()) Returns See also Notes None Examples igl.connect_boundary_to_infinity_index = connect_boundary_to_infinity_index(\u2026) method of builtins.PyCapsule instance connect_boundary_to_infinity_index(f: array, inf_index: int) -> object \u00b6 Parameters inf_index index of point at infinity (usually V.rows() or F.maxCoeff()) Returns See also Notes None Examples igl.cotmatrix = cotmatrix(\u2026) method of builtins.PyCapsule instance cotmatrix(v: array, f: array) -> object \u00b6 Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (v, f). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) Returns l : #v by #v cotangent matrix, each row i corresponding to v(i, :) See also adjacency_matrix Notes This Laplacian uses the convention that diagonal entries are minus the sum of off-diagonal entries. The diagonal entries are therefore in general negative and the matrix is negative semi-definite (immediately, -L is positive semi-definite) Examples Mesh in (v, f) l = cotmatrix(v, f) igl.cotmatrix = cotmatrix(\u2026) method of builtins.PyCapsule instance cotmatrix(v: array, f: array) -> object \u00b6 Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (v, f). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) Returns l : #v by #v cotangent matrix, each row i corresponding to v(i, :) See also adjacency_matrix Notes This Laplacian uses the convention that diagonal entries are minus the sum of off-diagonal entries. The diagonal entries are therefore in general negative and the matrix is negative semi-definite (immediately, -L is positive semi-definite) Examples Mesh in (v, f) l = cotmatrix(v, f) igl.cotmatrix_entries = cotmatrix_entries(\u2026) method of builtins.PyCapsule instance cotmatrix_entries(v: array, f: array) -> object \u00b6 COTMATRIX_ENTRIES compute the cotangents of each angle in mesh (V,F) Parameters V #V by dim list of rest domain positions F #F by {34} list of {triangletetrahedra} indices into V Returns C #F by 3 list of \u00bd*cotangents corresponding angles for triangles, columns correspond to edges [1,2],[2,0],[0,1] OR C #F by 6 list of \u2159*cotangents of dihedral angles*edge lengths for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2] See also Notes None Examples igl.cotmatrix_entries = cotmatrix_entries(\u2026) method of builtins.PyCapsule instance cotmatrix_entries(v: array, f: array) -> object \u00b6 COTMATRIX_ENTRIES compute the cotangents of each angle in mesh (V,F) Parameters V #V by dim list of rest domain positions F #F by {34} list of {triangletetrahedra} indices into V Returns C #F by 3 list of \u00bd*cotangents corresponding angles for triangles, columns correspond to edges [1,2],[2,0],[0,1] OR C #F by 6 list of \u2159*cotangents of dihedral angles*edge lengths for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2] See also Notes None Examples igl.crouzeix_raviart_cotmatrix = crouzeix_raviart_cotmatrix(\u2026) method of builtins.PyCapsule instance crouzeix_raviart_cotmatrix(v: array, f: array) -> Tuple[object, object, object] \u00b6 CROUZEIX_RAVIART_COTMATRIX Compute the Crouzeix-Raviart cotangent stiffness matrix. Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns L #E by #E edge/face-based diagonal cotangent matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also See also: crouzeix_raviart_massmatrix Notes None Examples See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] igl.crouzeix_raviart_cotmatrix = crouzeix_raviart_cotmatrix(\u2026) method of builtins.PyCapsule instance crouzeix_raviart_cotmatrix(v: array, f: array) -> Tuple[object, object, object] \u00b6 CROUZEIX_RAVIART_COTMATRIX Compute the Crouzeix-Raviart cotangent stiffness matrix. Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns L #E by #E edge/face-based diagonal cotangent matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also See also: crouzeix_raviart_massmatrix Notes None Examples See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] igl.crouzeix_raviart_cotmatrix_known_e = crouzeix_raviart_cotmatrix_known_e(\u2026) method of builtins.PyCapsule instance crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -> object \u00b6 wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples igl.crouzeix_raviart_cotmatrix_known_e = crouzeix_raviart_cotmatrix_known_e(\u2026) method of builtins.PyCapsule instance crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -> object \u00b6 wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples igl.crouzeix_raviart_massmatrix = crouzeix_raviart_massmatrix(\u2026) method of builtins.PyCapsule instance crouzeix_raviart_massmatrix(v: array, f: array) -> Tuple[object, object, object] \u00b6 CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where edge e. \u00b6 Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns M #E by #E edge/face-based diagonal mass matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also crouzeix_raviart_cotmatrix Notes See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] Examples igl.crouzeix_raviart_massmatrix = crouzeix_raviart_massmatrix(\u2026) method of builtins.PyCapsule instance crouzeix_raviart_massmatrix(v: array, f: array) -> Tuple[object, object, object] \u00b6 CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where edge e. \u00b6 Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns M #E by #E edge/face-based diagonal mass matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also crouzeix_raviart_cotmatrix Notes See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] Examples igl.crouzeix_raviart_massmatrix_known_e = crouzeix_raviart_massmatrix_known_e(\u2026) method of builtins.PyCapsule instance crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -> object \u00b6 wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples igl.crouzeix_raviart_massmatrix_known_e = crouzeix_raviart_massmatrix_known_e(\u2026) method of builtins.PyCapsule instance crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -> object \u00b6 wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples igl.cut_mesh = cut_mesh(\u2026) method of builtins.PyCapsule instance cut_mesh(v: array, f: array, cuts: array) -> Tuple[object, object] \u00b6 Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V cuts : #F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) Returns A pair (vcut, fcut) where: vcut is a #v by 3 list of the vertex positions of the cut mesh. This matrix will be similar to the original vertices except some rows will be duplicated. fcut is a #f by 3 list of the faces of the cut mesh (must be triangles). This matrix will be similar to the original face matrix except some indices will be redirected to point to the newly duplicated vertices. See also Notes Examples igl.cut_mesh = cut_mesh(\u2026) method of builtins.PyCapsule instance cut_mesh(v: array, f: array, cuts: array) -> Tuple[object, object] \u00b6 Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V cuts : #F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) Returns A pair (vcut, fcut) where: vcut is a #v by 3 list of the vertex positions of the cut mesh. This matrix will be similar to the original vertices except some rows will be duplicated. fcut is a #f by 3 list of the faces of the cut mesh (must be triangles). This matrix will be similar to the original face matrix except some indices will be redirected to point to the newly duplicated vertices. See also Notes Examples igl.cut_mesh_from_singularities = cut_mesh_from_singularities(\u2026) method of builtins.PyCapsule instance cut_mesh_from_singularities(v: array, f: array, mismatch: array) -> object \u00b6 Given a mesh (v,f) and the integer mismatch of a cross field per edge (mismatch), finds and returns the cut_graph connecting the singularities (seams) Parameters v : #v by 3 array of triangle vertices (each row is a vertex) f : #f by 3 array of triangle indices into v mismatch : #f by 3 array of per-corner integer mismatches Returns seams : #f by 3 array of per corner booleans that de**notes if an edge is a** seam or not See also cut_mesh Notes Examples igl.cut_mesh_from_singularities = cut_mesh_from_singularities(\u2026) method of builtins.PyCapsule instance cut_mesh_from_singularities(v: array, f: array, mismatch: array) -> object \u00b6 Given a mesh (v,f) and the integer mismatch of a cross field per edge (mismatch), finds and returns the cut_graph connecting the singularities (seams) Parameters v : #v by 3 array of triangle vertices (each row is a vertex) f : #f by 3 array of triangle indices into v mismatch : #f by 3 array of per-corner integer mismatches Returns seams : #f by 3 array of per corner booleans that de**notes if an edge is a** seam or not See also cut_mesh Notes Examples igl.cylinder = cylinder(\u2026) method of builtins.PyCapsule instance cylinder(axis_devisions: int, height_devisions: int) -> Tuple[object, object] \u00b6 Construct a triangle mesh of a cylinder (without caps) Parameters axis_devisions number of vertices around the cylinder height_devisions number of vertices up the cylinder Returns V #V by 3 list of mesh vertex positions F #F by 3 list of triangle indices into V See also Notes None Examples igl.cylinder = cylinder(\u2026) method of builtins.PyCapsule instance cylinder(axis_devisions: int, height_devisions: int) -> Tuple[object, object] \u00b6 Construct a triangle mesh of a cylinder (without caps) Parameters axis_devisions number of vertices around the cylinder height_devisions number of vertices up the cylinder Returns V #V by 3 list of mesh vertex positions F #F by 3 list of triangle indices into V See also Notes None Examples igl.decimate = decimate(\u2026) method of builtins.PyCapsule instance decimate(v: array, f: array, max_m: int) -> Tuple[bool, object, object, object, object] \u00b6 Assumes (V,F) is a manifold mesh (possibly with boundary) Collapses edges until desired number of faces is achieved. This uses default edge cost and merged vertex placement functions {edge length, edge midpoint}. Parameters V #V by dim list of vertex positions F #F by 3 list of face indices into V. max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices Returns true if m was reached (otherwise #G > m) See also Notes None Examples igl.decimate = decimate(\u2026) method of builtins.PyCapsule instance decimate(v: array, f: array, max_m: int) -> Tuple[bool, object, object, object, object] \u00b6 Assumes (V,F) is a manifold mesh (possibly with boundary) Collapses edges until desired number of faces is achieved. This uses default edge cost and merged vertex placement functions {edge length, edge midpoint}. Parameters V #V by dim list of vertex positions F #F by 3 list of face indices into V. max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices Returns true if m was reached (otherwise #G > m) See also Notes None Examples igl.dihedral_angles = dihedral_angles(\u2026) method of builtins.PyCapsule instance dihedral_angles(v: array, t: array) -> Tuple[object, object] \u00b6 Compute dihedral angles for all tets of a given tet mesh (v, t). Parameters v : #v by dim list of vertex positions t : #v by 4 list of tet indices Returns theta : #t by 6 list of dihedral angles (in radians) cos_theta : #t by 6 list of cosine of dihedral angles (in radians) See also Notes None Examples TetMesh in (v, t) theta, cos_theta = dihedral_angles(v, t) igl.dihedral_angles = dihedral_angles(\u2026) method of builtins.PyCapsule instance dihedral_angles(v: array, t: array) -> Tuple[object, object] \u00b6 Compute dihedral angles for all tets of a given tet mesh (v, t). Parameters v : #v by dim list of vertex positions t : #v by 4 list of tet indices Returns theta : #t by 6 list of dihedral angles (in radians) cos_theta : #t by 6 list of cosine of dihedral angles (in radians) See also Notes None Examples TetMesh in (v, t) theta, cos_theta = dihedral_angles(v, t) igl.dihedral_angles_intrinsic = dihedral_angles_intrinsic(\u2026) method of builtins.PyCapsule instance dihedral_angles_intrinsic(l: array, a: array) -> Tuple[object, object] \u00b6 See dihedral_angles for the documentation. igl.dihedral_angles_intrinsic = dihedral_angles_intrinsic(\u2026) method of builtins.PyCapsule instance dihedral_angles_intrinsic(l: array, a: array) -> Tuple[object, object] \u00b6 See dihedral_angles for the documentation. igl.directed_edge_parents = directed_edge_parents(\u2026) method of builtins.PyCapsule instance directed_edge_parents(e: array) -> object \u00b6 Recover \u201cparents\u201d (preceding edges) in a tree given just directed edges. Parameters e : #e by 2 list of directed edges Returns p : #e list of parent indices into e. (-1) means root See also Notes None Examples p = edges(e) igl.directed_edge_parents = directed_edge_parents(\u2026) method of builtins.PyCapsule instance directed_edge_parents(e: array) -> object \u00b6 Recover \u201cparents\u201d (preceding edges) in a tree given just directed edges. Parameters e : #e by 2 list of directed edges Returns p : #e list of parent indices into e. (-1) means root See also Notes None Examples p = edges(e) igl.doublearea = doublearea(\u2026) method of builtins.PyCapsule instance doublearea(v: array, f: array) -> object \u00b6 Computes twice the area for each input triangle[quad] Parameters v : #v by dim array of mesh vertex positions f : #f by simplex_size array of mesh faces (must be triangles or quads) Returns d_area : #f list of triangle[quad] double areas (SIGNED only for 2D input) See also None Notes Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal if you have 1million unreferenced vertices and 1 face Examples Mesh in (v, f) dbl_area = doublearea(v, f) igl.doublearea = doublearea(\u2026) method of builtins.PyCapsule instance doublearea(v: array, f: array) -> object \u00b6 Computes twice the area for each input triangle[quad] Parameters v : #v by dim array of mesh vertex positions f : #f by simplex_size array of mesh faces (must be triangles or quads) Returns d_area : #f list of triangle[quad] double areas (SIGNED only for 2D input) See also None Notes Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal if you have 1million unreferenced vertices and 1 face Examples Mesh in (v, f) dbl_area = doublearea(v, f) igl.ears = ears(\u2026) method of builtins.PyCapsule instance ears(f: array) -> Tuple[object, object] \u00b6 FIND_EARS Find all ears (faces with two boundary edges) in a given mesh Parameters F #F by 3 list of triangle mesh indices Returns ears #ears list of indices into F of ears ear_opp #ears list of indices indicating which edge is non-boundary (connecting to flops) See also Notes None Examples ears,ear_opp = find_ears(F) igl.ears = ears(\u2026) method of builtins.PyCapsule instance ears(f: array) -> Tuple[object, object] \u00b6 FIND_EARS Find all ears (faces with two boundary edges) in a given mesh Parameters F #F by 3 list of triangle mesh indices Returns ears #ears list of indices into F of ears ear_opp #ears list of indices indicating which edge is non-boundary (connecting to flops) See also Notes None Examples ears,ear_opp = find_ears(F) igl.edge_topology = edge_topology(\u2026) method of builtins.PyCapsule instance edge_topology(v: array, f: array) -> Tuple[object, object, object] \u00b6 Initialize Edges and their topological relations (assumes an edge-manifold mesh) Parameters v : #v by dim, list of mesh vertex positions (unused) f : #f by 3, list of triangle indices into V Returns ev : #e by 2, list of edges described as pair of vertices. fe : #f by 3, list storing triangle-edge relation. ef : #e by w, list storing edge-triangle relation, uses -1 to indicate boundaries. See also Notes None Examples Mesh in (v, f) ev, fe, ef = edge_topology(v, f) igl.edge_topology = edge_topology(\u2026) method of builtins.PyCapsule instance edge_topology(v: array, f: array) -> Tuple[object, object, object] \u00b6 Initialize Edges and their topological relations (assumes an edge-manifold mesh) Parameters v : #v by dim, list of mesh vertex positions (unused) f : #f by 3, list of triangle indices into V Returns ev : #e by 2, list of edges described as pair of vertices. fe : #f by 3, list storing triangle-edge relation. ef : #e by w, list storing edge-triangle relation, uses -1 to indicate boundaries. See also Notes None Examples Mesh in (v, f) ev, fe, ef = edge_topology(v, f) igl.edges = edges(\u2026) method of builtins.PyCapsule instance edges(f: array) -> object \u00b6 Constructs a list of unique edges represented in a given mesh (v, f) Parameters f : #F by dim list of mesh faces (must be triangles or tets) Returns by 2 list of edges in no particular order See also adjacency_matrix Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) E = igl.edges(F) igl.edges = edges(\u2026) method of builtins.PyCapsule instance edges(f: array) -> object \u00b6 Constructs a list of unique edges represented in a given mesh (v, f) Parameters f : #F by dim list of mesh faces (must be triangles or tets) Returns by 2 list of edges in no particular order See also adjacency_matrix Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) E = igl.edges(F) igl.euler_characteristic = euler_characteristic(\u2026) method of builtins.PyCapsule instance euler_characteristic(f: array) -> int \u00b6 Computes the Euler characteristic of a given mesh (V,F) Parameters F #F by dim list of mesh faces (must be triangles) Returns Returns An int containing the Euler characteristic See also Notes None Examples igl.euler_characteristic = euler_characteristic(\u2026) method of builtins.PyCapsule instance euler_characteristic(f: array) -> int \u00b6 Computes the Euler characteristic of a given mesh (V,F) Parameters F #F by dim list of mesh faces (must be triangles) Returns Returns An int containing the Euler characteristic See also Notes None Examples igl.euler_characteristic_complete = euler_characteristic_complete(\u2026) method of builtins.PyCapsule instance euler_characteristic_complete(v: array, f: array) -> int \u00b6 Parameters V #V by dim list of mesh vertex positions Returns See also Notes None Examples igl.euler_characteristic_complete = euler_characteristic_complete(\u2026) method of builtins.PyCapsule instance euler_characteristic_complete(v: array, f: array) -> int \u00b6 Parameters V #V by dim list of mesh vertex positions Returns See also Notes None Examples igl.exact_geodesic = exact_geodesic(\u2026) method of builtins.PyCapsule instance exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array None = None, ft: numpy.array None = None) -> object \u00b6 Exact geodesic algorithm for the calculation of geodesics on a triangular mesh. Parameters v : #v by 3 array of 3D vertex positions f : #f by 3 array of mesh faces vs : #vs by 1 array specifying indices of source vertices fs : #fs by 1 array specifying indices of source faces vt : #vt by 1 array specifying indices of target vertices ft : #ft by 1 array specifying indices of target faces Returns d : #vt+#ft by 1 array of geodesic distances of each target w.r.t. the nearest one in the source set See also Notes Specifying a face as target/source means its center. Implementation from https:code.google.com/archive/p/geodesic/ with the algorithm first described by Mitchell, Mount and Papadimitriou in 1987. Examples igl.exact_geodesic = exact_geodesic(\u2026) method of builtins.PyCapsule instance exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array None = None, ft: numpy.array None = None) -> object \u00b6 Exact geodesic algorithm for the calculation of geodesics on a triangular mesh. Parameters v : #v by 3 array of 3D vertex positions f : #f by 3 array of mesh faces vs : #vs by 1 array specifying indices of source vertices fs : #fs by 1 array specifying indices of source faces vt : #vt by 1 array specifying indices of target vertices ft : #ft by 1 array specifying indices of target faces Returns d : #vt+#ft by 1 array of geodesic distances of each target w.r.t. the nearest one in the source set See also Notes Specifying a face as target/source means its center. Implementation from https:code.google.com/archive/p/geodesic/ with the algorithm first described by Mitchell, Mount and Papadimitriou in 1987. Examples igl.face_components = face_components(\u2026) method of builtins.PyCapsule instance face_components(f: array) -> object \u00b6 Compute connected components of facets based on edge-edge adjacency, Parameters f : #f x 3 array of triangle indices Returns An array, c, with shape (#f,), of component ids See also vertex_components vertex_components_from_adjacency_matrix Notes Examples igl.face_components = face_components(\u2026) method of builtins.PyCapsule instance face_components(f: array) -> object \u00b6 Compute connected components of facets based on edge-edge adjacency, Parameters f : #f x 3 array of triangle indices Returns An array, c, with shape (#f,), of component ids See also vertex_components vertex_components_from_adjacency_matrix Notes Examples igl.fit_plane = fit_plane(\u2026) method of builtins.PyCapsule instance fit_plane(v: array) -> Tuple[object, object] \u00b6 This function fits a plane to a point cloud. Parameters V #Vx3 matrix. The 3D point cloud, one row for each vertex. Returns N 1x3 Vector. The normal of the fitted plane. C 1x3 Vector. A point that lies in the fitted plane. See also Notes From http:missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html Examples igl.fit_plane = fit_plane(\u2026) method of builtins.PyCapsule instance fit_plane(v: array) -> Tuple[object, object] \u00b6 This function fits a plane to a point cloud. Parameters V #Vx3 matrix. The 3D point cloud, one row for each vertex. Returns N 1x3 Vector. The normal of the fitted plane. C 1x3 Vector. A point that lies in the fitted plane. See also Notes From http:missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html Examples igl.flip_avoiding_line_search = flip_avoiding_line_search(\u2026) method of builtins.PyCapsule instance flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function<double (Eigen::Matrix<double, -1, -1, 0, -1, -1>)>, cur_energy: float) -> Tuple[float, object] \u00b6 A bisection line search for a mesh based energy that avoids triangle flips as suggested in \u201cBijective Parameterization with Free Boundaries\u201d (Smith J. and Schaefer S., 2015). The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles). This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see igl::line_search). Supports both triangle and tet meshes. Parameters F #F by \u00be list of mesh faces or tets cur_v #V by dim list of variables dst_v #V by dim list of target vertices. This mesh may have flipped triangles energy A function to compute the mesh-based energy (return an energy that is bigger than 0) cur_energy(OPTIONAL) The energy at the given point. Helps save redundant c omputations. This is optional. If not specified, the function will compute it. \u00b6 Returns cur_v #V by dim list of variables at the new location Returns the energy at the new point See also Notes None Examples igl.flip_avoiding_line_search = flip_avoiding_line_search(\u2026) method of builtins.PyCapsule instance flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function<double (Eigen::Matrix<double, -1, -1, 0, -1, -1>)>, cur_energy: float) -> Tuple[float, object] \u00b6 A bisection line search for a mesh based energy that avoids triangle flips as suggested in \u201cBijective Parameterization with Free Boundaries\u201d (Smith J. and Schaefer S., 2015). The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles). This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see igl::line_search). Supports both triangle and tet meshes. Parameters F #F by \u00be list of mesh faces or tets cur_v #V by dim list of variables dst_v #V by dim list of target vertices. This mesh may have flipped triangles energy A function to compute the mesh-based energy (return an energy that is bigger than 0) cur_energy(OPTIONAL) The energy at the given point. Helps save redundant c omputations. This is optional. If not specified, the function will compute it. \u00b6 Returns cur_v #V by dim list of variables at the new location Returns the energy at the new point See also Notes None Examples igl.gaussian_curvature = gaussian_curvature(\u2026) method of builtins.PyCapsule instance gaussian_curvature(v: array, f: array) -> object \u00b6 Compute discrete local integral gaussian curvature (angle deficit, without averaging by local area). Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices Returns k : #v by 1 array of discrete gaussian curvature values See also principal_curvature Notes None Examples Mesh in (v, f) k = gaussian_curvature(v, f) igl.gaussian_curvature = gaussian_curvature(\u2026) method of builtins.PyCapsule instance gaussian_curvature(v: array, f: array) -> object \u00b6 Compute discrete local integral gaussian curvature (angle deficit, without averaging by local area). Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices Returns k : #v by 1 array of discrete gaussian curvature values See also principal_curvature Notes None Examples Mesh in (v, f) k = gaussian_curvature(v, f) igl.grad = grad(\u2026) method of builtins.PyCapsule instance grad(v: array, f: array, uniform: bool = False) -> object \u00b6 Compute the numerical gradient operator. Parameters v : #v by 3 list of mesh vertex positions f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices] uniform : boolean (default false). Use a uniform mesh instead of the vertices v Returns g : #faces * dim by #v gradient operator See also cotmatrix, massmatrix Notes Gradient of a scalar function defined on piecewise linear elements (mesh) is constant on each triangle [tetrahedron] i,j,k: grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A \u00b6 where Xi is the scalar value at vertex i, Vi is the 3D position of vertex i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of 90 degrees. Examples Mesh in (v, f) g = grad(v, f) igl.grad = grad(\u2026) method of builtins.PyCapsule instance grad(v: array, f: array, uniform: bool = False) -> object \u00b6 Compute the numerical gradient operator. Parameters v : #v by 3 list of mesh vertex positions f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices] uniform : boolean (default false). Use a uniform mesh instead of the vertices v Returns g : #faces * dim by #v gradient operator See also cotmatrix, massmatrix Notes Gradient of a scalar function defined on piecewise linear elements (mesh) is constant on each triangle [tetrahedron] i,j,k: grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A \u00b6 where Xi is the scalar value at vertex i, Vi is the 3D position of vertex i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of 90 degrees. Examples Mesh in (v, f) g = grad(v, f) igl.grad = grad(\u2026) method of builtins.PyCapsule instance grad(v: array, f: array, uniform: bool = False) -> object \u00b6 Compute the numerical gradient operator. Parameters v : #v by 3 list of mesh vertex positions f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices] uniform : boolean (default false). Use a uniform mesh instead of the vertices v Returns g : #faces * dim by #v gradient operator See also cotmatrix, massmatrix Notes Gradient of a scalar function defined on piecewise linear elements (mesh) is constant on each triangle [tetrahedron] i,j,k: grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A \u00b6 where Xi is the scalar value at vertex i, Vi is the 3D position of vertex i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of 90 degrees. Examples Mesh in (v, f) g = grad(v, f) igl.harmonic_integrated_with_laplacian = harmonic_integrated_with_laplacian(\u2026) method of builtins.PyCapsule instance harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, k: int) -> object \u00b6 Build the discrete k-harmonic operator (computing integrated quantities). That is, if the k-harmonic PDE is Q x = 0, then this minimizes x\u2019 Q x Parameters L #V by #V discrete (integrated) Laplacian M #V by #V mass matrix k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns Q #V by #V discrete (integrated) k-Laplacian See also Notes Examples igl.harmonic_integrated_with_laplacian = harmonic_integrated_with_laplacian(\u2026) method of builtins.PyCapsule instance harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix scipy.sparse.csc_matrix, k: int) -> object \u00b6 Build the discrete k-harmonic operator (computing integrated quantities). That is, if the k-harmonic PDE is Q x = 0, then this minimizes x\u2019 Q x Parameters L #V by #V discrete (integrated) Laplacian M #V by #V mass matrix k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns Q #V by #V discrete (integrated) k-Laplacian See also Notes Examples igl.harmonic_uniform_laplacian = harmonic_uniform_laplacian(\u2026) method of builtins.PyCapsule instance harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -> object \u00b6 Compute harmonic map using uniform laplacian operator Parameters F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples igl.harmonic_uniform_laplacian = harmonic_uniform_laplacian(\u2026) method of builtins.PyCapsule instance harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -> object \u00b6 Compute harmonic map using uniform laplacian operator Parameters F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples igl.harmonic_weights = harmonic_weights(\u2026) method of builtins.PyCapsule instance harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -> object \u00b6 Compute k-harmonic weight functions \u201ccoordinates\u201d. Parameters V #V by dim vertex positions F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples igl.harmonic_weights = harmonic_weights(\u2026) method of builtins.PyCapsule instance harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -> object \u00b6 Compute k-harmonic weight functions \u201ccoordinates\u201d. Parameters V #V by dim vertex positions F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples igl.hausdorff = hausdorff(\u2026) method of builtins.PyCapsule instance hausdorff(va: array, fa: array, vb: array, fb: array) -> float \u00b6 HAUSDORFF compute the Hausdorff distance between mesh (VA,FA) and mesh (VB,FB). This is the a\u2208A b\u2208B b\u2208B a\u2208A \u00b6 Parameters VA #VA by 3 list of vertex positions FA #FA by 3 list of face indices into VA VB #VB by 3 list of vertex positions FB #FB by 3 list of face indices into VB Returns d hausdorff distance pair 2 by 3 list of \u201cdeterminer points\u201d so that pair(1,:) is from A and pair(2,:) is from B See also Notes Known issue: This is only computing max(min(va,B),min(vb,A)). This is better than max(min(va,Vb),min(vb,Va)). This (at least) is missing \u201cedge-edge\u201d cases like the distance between the two different triangulations of a non-planar quad in 3D. Even simpler, consider the Hausdorff distance between the non-convex, block letter V polygon (with 7 vertices) in 2D and its convex hull. The Hausdorff distance is defined by the midpoint in the middle of the segment across the concavity and some non-vertex point on the edge of the V. Examples igl.hausdorff = hausdorff(\u2026) method of builtins.PyCapsule instance hausdorff(va: array, fa: array, vb: array, fb: array) -> float \u00b6 HAUSDORFF compute the Hausdorff distance between mesh (VA,FA) and mesh (VB,FB). This is the a\u2208A b\u2208B b\u2208B a\u2208A \u00b6 Parameters VA #VA by 3 list of vertex positions FA #FA by 3 list of face indices into VA VB #VB by 3 list of vertex positions FB #FB by 3 list of face indices into VB Returns d hausdorff distance pair 2 by 3 list of \u201cdeterminer points\u201d so that pair(1,:) is from A and pair(2,:) is from B See also Notes Known issue: This is only computing max(min(va,B),min(vb,A)). This is better than max(min(va,Vb),min(vb,Va)). This (at least) is missing \u201cedge-edge\u201d cases like the distance between the two different triangulations of a non-planar quad in 3D. Even simpler, consider the Hausdorff distance between the non-convex, block letter V polygon (with 7 vertices) in 2D and its convex hull. The Hausdorff distance is defined by the midpoint in the middle of the segment across the concavity and some non-vertex point on the edge of the V. Examples igl.internal_angles = internal_angles(\u2026) method of builtins.PyCapsule instance internal_angles(v: array, f: array) -> object \u00b6 Computes internal angles for a triangle mesh. Parameters v : #v by dim array of mesh vertex nD positions f : #f by poly-size array of face (triangle) indices Returns k : #f by poly-size array of internal angles. For triangles, columns correspond to edges [1,2],[2,0],[0,1]. See also None Notes If poly-size \u2260 3 then dim must equal 3. Examples igl.internal_angles = internal_angles(\u2026) method of builtins.PyCapsule instance internal_angles(v: array, f: array) -> object \u00b6 Computes internal angles for a triangle mesh. Parameters v : #v by dim array of mesh vertex nD positions f : #f by poly-size array of face (triangle) indices Returns k : #f by poly-size array of internal angles. For triangles, columns correspond to edges [1,2],[2,0],[0,1]. See also None Notes If poly-size \u2260 3 then dim must equal 3. Examples igl.is_edge_manifold = is_edge_manifold(\u2026) method of builtins.PyCapsule instance is_edge_manifold(f: array) -> bool \u00b6 See is_edge_manifold for the documentation. igl.is_edge_manifold = is_edge_manifold(\u2026) method of builtins.PyCapsule instance is_edge_manifold(f: array) -> bool \u00b6 See is_edge_manifold for the documentation. igl.is_irregular_vertex = is_irregular_vertex(\u2026) method of builtins.PyCapsule instance is_irregular_vertex(v: array, f: array) -> std::__1::vector<bool, std::__1::allocator<bool> > \u00b6 Determine if a vertex is irregular, i.e. it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored. Parameters v : #v by dim array of vertex positions f : #f by 3[4] array of triangle[quads] indices Returns s : #v list of bools revealing whether vertices are singular See also None Notes None Examples igl.is_irregular_vertex = is_irregular_vertex(\u2026) method of builtins.PyCapsule instance is_irregular_vertex(v: array, f: array) -> std::__1::vector<bool, std::__1::allocator<bool> > \u00b6 Determine if a vertex is irregular, i.e. it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored. Parameters v : #v by dim array of vertex positions f : #f by 3[4] array of triangle[quads] indices Returns s : #v list of bools revealing whether vertices are singular See also None Notes None Examples igl.isolines = isolines(\u2026) method of builtins.PyCapsule instance isolines(v: array, f: array, z: array, n: int) -> Tuple[object, object] \u00b6 Constructs isolines for a function z given on a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of mesh faces (must be triangles) z #V by 1 list of function values evaluated at vertices n the number of desired isolines Returns isoV #isoV by dim list of isoline vertex positions isoE #isoE by 2 list of isoline edge positions See also Notes None Examples igl.isolines = isolines(\u2026) method of builtins.PyCapsule instance isolines(v: array, f: array, z: array, n: int) -> Tuple[object, object] \u00b6 Constructs isolines for a function z given on a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of mesh faces (must be triangles) z #V by 1 list of function values evaluated at vertices n the number of desired isolines Returns isoV #isoV by dim list of isoline vertex positions isoE #isoE by 2 list of isoline edge positions See also Notes None Examples igl.lscm = lscm(\u2026) method of builtins.PyCapsule instance lscm(v: array, f: array, b: array, bc: array) -> Tuple[bool, object] \u00b6 Compute a Least-squares conformal map parametrization. Parameters v : #v by 3 array of mesh vertex positions f : #f by 3 array of mesh faces (must be triangles) b : #b boundary indices into v bc : #b by 3 list of boundary values Returns uv #v by 2 list of 2D mesh vertex positions in UV space See also None Notes Derived in \u201cIntrinsic Parameterizations of Surface Meshes\u201d [Desbrun et al. 2002] and \u201cLeast Squares Conformal Maps for Automatic Texture Atlas Generation\u201d [L\u00e9vy et al. 2002]), though this implementation follows the derivation in: \u201cSpectral Conformal Parameterization\u201d [Mullen et al. 2008] (note, this does not implement the Eigen-decomposition based method in [Mullen et al. 2008], which is not equivalent. Input should be a manifold mesh (also no unreferenced vertices) and \u201cboundary\u201d (fixed vertices) b should contain at least two vertices per connected component. Returns true only on solver success. Examples igl.lscm = lscm(\u2026) method of builtins.PyCapsule instance lscm(v: array, f: array, b: array, bc: array) -> Tuple[bool, object] \u00b6 Compute a Least-squares conformal map parametrization. Parameters v : #v by 3 array of mesh vertex positions f : #f by 3 array of mesh faces (must be triangles) b : #b boundary indices into v bc : #b by 3 list of boundary values Returns uv #v by 2 list of 2D mesh vertex positions in UV space See also None Notes Derived in \u201cIntrinsic Parameterizations of Surface Meshes\u201d [Desbrun et al. 2002] and \u201cLeast Squares Conformal Maps for Automatic Texture Atlas Generation\u201d [L\u00e9vy et al. 2002]), though this implementation follows the derivation in: \u201cSpectral Conformal Parameterization\u201d [Mullen et al. 2008] (note, this does not implement the Eigen-decomposition based method in [Mullen et al. 2008], which is not equivalent. Input should be a manifold mesh (also no unreferenced vertices) and \u201cboundary\u201d (fixed vertices) b should contain at least two vertices per connected component. Returns true only on solver success. Examples igl.massmatrix = massmatrix(\u2026) method of builtins.PyCapsule instance massmatrix(v: array, f: array, type: int = 1) -> object \u00b6 Constructs the mass (area) matrix for a given mesh (V,F). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) type : one of the following types: -igl.MASSMATRIX_TYPE_BARYCENTRIC barycentric -igl.MASSMATRIX_TYPE_VORONOI voronoi-hybrid (default) -igl.MASSMATRIX_TYPE_FULL full (not implemented) Returns m : #v by #v mass matrix See also adjacency_matrix, cotmatrix, grad Notes Examples igl.massmatrix = massmatrix(\u2026) method of builtins.PyCapsule instance massmatrix(v: array, f: array, type: int = 1) -> object \u00b6 Constructs the mass (area) matrix for a given mesh (V,F). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) type : one of the following types: -igl.MASSMATRIX_TYPE_BARYCENTRIC barycentric -igl.MASSMATRIX_TYPE_VORONOI voronoi-hybrid (default) -igl.MASSMATRIX_TYPE_FULL full (not implemented) Returns m : #v by #v mass matrix See also adjacency_matrix, cotmatrix, grad Notes Examples igl.min_quad_dense_precompute = min_quad_dense_precompute(\u2026) method of builtins.PyCapsule instance min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -> object \u00b6 MIN_QUAD_WITH_FIXED Minimize quadratic energy Z\u2019*A*Z + Z\u2019*B + C subject to linear constraints Aeq*Z = Beq Parameters A n by n matrix of quadratic coefficients B n by 1 column of linear coefficients Aeq m by n list of linear equality constraint coefficients Beq m by 1 list of linear equality constraint constant values use_lu_decomposition use lu rather than SVD Returns S n by (n + m) \u201csolve\u201d matrix, such that S*[B\u2019, Beq\u2019] is a solution See also Notes None Examples igl.min_quad_dense_precompute = min_quad_dense_precompute(\u2026) method of builtins.PyCapsule instance min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -> object \u00b6 MIN_QUAD_WITH_FIXED Minimize quadratic energy Z\u2019*A*Z + Z\u2019*B + C subject to linear constraints Aeq*Z = Beq Parameters A n by n matrix of quadratic coefficients B n by 1 column of linear coefficients Aeq m by n list of linear equality constraint coefficients Beq m by 1 list of linear equality constraint constant values use_lu_decomposition use lu rather than SVD Returns S n by (n + m) \u201csolve\u201d matrix, such that S*[B\u2019, Beq\u2019] is a solution See also Notes None Examples igl.orientable_patches = orientable_patches(\u2026) method of builtins.PyCapsule instance orientable_patches(f: array) -> Tuple[object, object] \u00b6 Compute connected components of facets connected by manifold edges. Parameters f : n by dim array of face ids Returns A tuple (c, A) where c is an array of component ids (starting with 0) and A is a #f x #f adjacency matri See also components Notes Known bugs: This will detect a moebius strip as a single patch (manifold, non-orientable) and also non-manfiold, yet orientable patches. Examples igl.orientable_patches = orientable_patches(\u2026) method of builtins.PyCapsule instance orientable_patches(f: array) -> Tuple[object, object] \u00b6 Compute connected components of facets connected by manifold edges. Parameters f : n by dim array of face ids Returns A tuple (c, A) where c is an array of component ids (starting with 0) and A is a #f x #f adjacency matri See also components Notes Known bugs: This will detect a moebius strip as a single patch (manifold, non-orientable) and also non-manfiold, yet orientable patches. Examples igl.oriented_facets = oriented_facets(\u2026) method of builtins.PyCapsule instance oriented_facets(f: array) -> object \u00b6 Determines all \u2018directed facets \u2018 of a given set of simplicial elements. For a manifold triangle mesh, this computes all half-edges. For a manifold tetrahedral mesh, this computes all half-faces. Parameters f : #F by simplex_size list of simplices Returns : by simplex_size-1 list of half-edges/facets See also edges Notes This is not the same as igl::edges because this includes every directed edge including repeats (meaning interior edges on a surface will show up once for each direction and non-manifold edges may appear more than once for each direction). Examples igl.oriented_facets = oriented_facets(\u2026) method of builtins.PyCapsule instance oriented_facets(f: array) -> object \u00b6 Determines all \u2018directed facets \u2018 of a given set of simplicial elements. For a manifold triangle mesh, this computes all half-edges. For a manifold tetrahedral mesh, this computes all half-faces. Parameters f : #F by simplex_size list of simplices Returns : by simplex_size-1 list of half-edges/facets See also edges Notes This is not the same as igl::edges because this includes every directed edge including repeats (meaning interior edges on a surface will show up once for each direction and non-manifold edges may appear more than once for each direction). Examples igl.per_edge_normals = per_edge_normals(\u2026) method of builtins.PyCapsule instance per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -> Tuple[object, object, object] \u00b6 Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices weight weighting type FN #F by 3 matrix of 3D face normals per face Returns N #2 by 3 matrix of mesh edge 3D normals per row E #E by 2 matrix of edge indices per row EMAP #E by 1 matrix of indices from all edges to E See also Notes None Examples igl.per_edge_normals = per_edge_normals(\u2026) method of builtins.PyCapsule instance per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -> Tuple[object, object, object] \u00b6 Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices weight weighting type FN #F by 3 matrix of 3D face normals per face Returns N #2 by 3 matrix of mesh edge 3D normals per row E #E by 2 matrix of edge indices per row EMAP #E by 1 matrix of indices from all edges to E See also Notes None Examples igl.per_face_normals = per_face_normals(\u2026) method of builtins.PyCapsule instance per_face_normals(v: array, f: array, z: array) -> object \u00b6 Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices Z 3 vector normal given to faces with degenerate normal. Returns N #F by 3 eigen Matrix of mesh face (triangle) 3D normals See also Notes None Examples Give degenerate faces (\u2153,\u2153,\u2153)^0.5 per_face_normals(V,F,Vector3d(1,1,1).normalized(),N); \u00b6 igl.per_face_normals = per_face_normals(\u2026) method of builtins.PyCapsule instance per_face_normals(v: array, f: array, z: array) -> object \u00b6 Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices Z 3 vector normal given to faces with degenerate normal. Returns N #F by 3 eigen Matrix of mesh face (triangle) 3D normals See also Notes None Examples Give degenerate faces (\u2153,\u2153,\u2153)^0.5 per_face_normals(V,F,Vector3d(1,1,1).normalized(),N); \u00b6 igl.per_face_normals = per_face_normals(\u2026) method of builtins.PyCapsule instance per_face_normals(v: array, f: array, z: array) -> object \u00b6 Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices Z 3 vector normal given to faces with degenerate normal. Returns N #F by 3 eigen Matrix of mesh face (triangle) 3D normals See also Notes None Examples Give degenerate faces (\u2153,\u2153,\u2153)^0.5 per_face_normals(V,F,Vector3d(1,1,1).normalized(),N); \u00b6 igl.per_vertex_attribute_smoothing = per_vertex_attribute_smoothing(\u2026) method of builtins.PyCapsule instance per_vertex_attribute_smoothing(ain: array, f: array) -> object \u00b6 Smooth vertex attributes using uniform Laplacian Parameters Ain #V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes) F #F by 3 eigne Matrix of face (triangle) indices Returns Aout #V by #A eigen Matrix of mesh vertex attributes See also Notes None Examples igl.per_vertex_attribute_smoothing = per_vertex_attribute_smoothing(\u2026) method of builtins.PyCapsule instance per_vertex_attribute_smoothing(ain: array, f: array) -> object \u00b6 Smooth vertex attributes using uniform Laplacian Parameters Ain #V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes) F #F by 3 eigne Matrix of face (triangle) indices Returns Aout #V by #A eigen Matrix of mesh vertex attributes See also Notes None Examples igl.per_vertex_normals = per_vertex_normals(\u2026) method of builtins.PyCapsule instance per_vertex_normals(v: array, f: array, weighting: int = 0) -> object \u00b6 Compute vertex normals via vertex position list, face list. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices weighting : Weighting type, one of the following -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM uniform influence -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA area weighted -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE angle weighted Returns n #v by 3 array of mesh vertex 3D normals See also per_face_normals, per_edge_normals Notes None Examples Mesh in (v, f) n = per_vertex_normals(v, f) igl.per_vertex_normals = per_vertex_normals(\u2026) method of builtins.PyCapsule instance per_vertex_normals(v: array, f: array, weighting: int = 0) -> object \u00b6 Compute vertex normals via vertex position list, face list. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices weighting : Weighting type, one of the following -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM uniform influence -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA area weighted -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE angle weighted Returns n #v by 3 array of mesh vertex 3D normals See also per_face_normals, per_edge_normals Notes None Examples Mesh in (v, f) n = per_vertex_normals(v, f) igl.piecewise_constant_winding_number = piecewise_constant_winding_number(\u2026) method of builtins.PyCapsule instance piecewise_constant_winding_number(f: array) -> bool \u00b6 PIECEWISE_CONSTANT_WINDING_NUMBER Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input to solid set operations. Assumes that (V,F) contains no -intersections (including degeneracies and co-incidences). If there are co-planar and co-incident vertex placements, a mesh could fail this combinatorial test but still induce a piecewise-constant winding number geometrically . For example, consider a hemisphere with boundary and then pinch the boundary \u201cshut\u201d along a line segment. The bullet-proof check is to first resolve all -intersections in (V,F) -> (SV,SF) (i.e. what the igl::copyleft::cgal::piecewise_constant_winding_number overload does). Parameters F #F by 3 list of triangle indices into some (abstract) list of vertices V Returns Returns true if the mesh combinatorially induces a piecewise constant winding number field. See also Notes None Examples igl.piecewise_constant_winding_number = piecewise_constant_winding_number(\u2026) method of builtins.PyCapsule instance piecewise_constant_winding_number(f: array) -> bool \u00b6 PIECEWISE_CONSTANT_WINDING_NUMBER Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input to solid set operations. Assumes that (V,F) contains no -intersections (including degeneracies and co-incidences). If there are co-planar and co-incident vertex placements, a mesh could fail this combinatorial test but still induce a piecewise-constant winding number geometrically . For example, consider a hemisphere with boundary and then pinch the boundary \u201cshut\u201d along a line segment. The bullet-proof check is to first resolve all -intersections in (V,F) -> (SV,SF) (i.e. what the igl::copyleft::cgal::piecewise_constant_winding_number overload does). Parameters F #F by 3 list of triangle indices into some (abstract) list of vertices V Returns Returns true if the mesh combinatorially induces a piecewise constant winding number field. See also Notes None Examples igl.principal_curvature = principal_curvature(\u2026) method of builtins.PyCapsule instance principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -> Tuple[object, object, object, object] \u00b6 Compute the principal curvature directions and magnitude of the given triangle mesh. Parameters v : vertex array of size #V by 3 f : face index array #F by 3 list of mesh faces (must be triangles) radius : controls the size of the neighbourhood used, 1 = average edge length (default: 5) use_k_ring : (default: True) Returns pd1 : #v by 3 maximal curvature direction for each vertex pd2 : #v by 3 minimal curvature direction for each vertex pv1 : #v by 1 maximal curvature value for each vertex pv2 : #v by 1 minimal curvature value for each vertex See also average_onto_faces, average_onto_vertices Notes This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo. The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010 Examples Mesh in (v, f) pd1, pd2, pv1, pv2 = principal_curvature(v, f) igl.principal_curvature = principal_curvature(\u2026) method of builtins.PyCapsule instance principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -> Tuple[object, object, object, object] \u00b6 Compute the principal curvature directions and magnitude of the given triangle mesh. Parameters v : vertex array of size #V by 3 f : face index array #F by 3 list of mesh faces (must be triangles) radius : controls the size of the neighbourhood used, 1 = average edge length (default: 5) use_k_ring : (default: True) Returns pd1 : #v by 3 maximal curvature direction for each vertex pd2 : #v by 3 minimal curvature direction for each vertex pv1 : #v by 1 maximal curvature value for each vertex pv2 : #v by 1 minimal curvature value for each vertex See also average_onto_faces, average_onto_vertices Notes This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo. The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010 Examples Mesh in (v, f) pd1, pd2, pv1, pv2 = principal_curvature(v, f) igl.procrustes = procrustes(\u2026) method of builtins.PyCapsule instance procrustes(x: array, y: array) -> Tuple[bool, bool, float, object, object] \u00b6 Solve Procrustes problem in d dimensions. Given two point sets X,Y in R^d find best scale s, orthogonal R and translation t s.t. s*X*R + t - Y^2 is minimized. Parameters X #V by DIM first list of points Y #V by DIM second list of points includeScaling if scaling should be allowed includeReflections if R is allowed to be a reflection Returns scale scaling R orthogonal matrix t translation See also Notes None Examples MatrixXd X, Y; (containing 3d points as rows) double scale; MatrixXd R; VectorXd t; igl::procrustes(X,Y,true,false,scale,R,t); R *= scale; MatrixXd Xprime = (X * R).rowwise() + t.transpose(); igl.procrustes = procrustes(\u2026) method of builtins.PyCapsule instance procrustes(x: array, y: array) -> Tuple[bool, bool, float, object, object] \u00b6 Solve Procrustes problem in d dimensions. Given two point sets X,Y in R^d find best scale s, orthogonal R and translation t s.t. s*X*R + t - Y^2 is minimized. Parameters X #V by DIM first list of points Y #V by DIM second list of points includeScaling if scaling should be allowed includeReflections if R is allowed to be a reflection Returns scale scaling R orthogonal matrix t translation See also Notes None Examples MatrixXd X, Y; (containing 3d points as rows) double scale; MatrixXd R; VectorXd t; igl::procrustes(X,Y,true,false,scale,R,t); R *= scale; MatrixXd Xprime = (X * R).rowwise() + t.transpose(); igl.qslim = qslim(\u2026) method of builtins.PyCapsule instance qslim(v: array, f: array, max_m: int) -> Tuple[bool, object, object, object, object] \u00b6 Decimate (simplify) a triangle mesh in nD according to the paper \u201cSimplifying Surfaces with Color and Texture using Quadric Error Metrics\u201d by [Garland and Heckbert, 1987] (technically a followup to qslim). The mesh can have open boundaries but should be edge-manifold. Parameters V #V by dim list of vertex positions. Assumes that vertices w F #F by 3 list of triangle indices into V max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices See also Notes None Examples igl.qslim = qslim(\u2026) method of builtins.PyCapsule instance qslim(v: array, f: array, max_m: int) -> Tuple[bool, object, object, object, object] \u00b6 Decimate (simplify) a triangle mesh in nD according to the paper \u201cSimplifying Surfaces with Color and Texture using Quadric Error Metrics\u201d by [Garland and Heckbert, 1987] (technically a followup to qslim). The mesh can have open boundaries but should be edge-manifold. Parameters V #V by dim list of vertex positions. Assumes that vertices w F #F by 3 list of triangle indices into V max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices See also Notes None Examples igl.quad_planarity = quad_planarity(\u2026) method of builtins.PyCapsule instance quad_planarity(v: array, f: array) -> object \u00b6 Compute planarity of the faces of a quad mesh. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 4 array of face (quad) indices Returns p : #f by 1 array of mesh face (quad) planarities See also None Notes None Examples igl.quad_planarity = quad_planarity(\u2026) method of builtins.PyCapsule instance quad_planarity(v: array, f: array) -> object \u00b6 Compute planarity of the faces of a quad mesh. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 4 array of face (quad) indices Returns p : #f by 1 array of mesh face (quad) planarities See also None Notes None Examples igl.random_points_on_mesh = random_points_on_mesh(\u2026) method of builtins.PyCapsule instance random_points_on_mesh(n: int, v: array, f: array) -> Tuple[object, object] \u00b6 RANDOM_POINTS_ON_MESH Randomly sample a mesh (V,F) n times. Parameters n number of samples V #V by dim list of mesh vertex positions F #F by 3 list of mesh triangle indices Returns B n by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) FI n list of indices into F See also Notes None Examples igl.random_points_on_mesh = random_points_on_mesh(\u2026) method of builtins.PyCapsule instance random_points_on_mesh(n: int, v: array, f: array) -> Tuple[object, object] \u00b6 RANDOM_POINTS_ON_MESH Randomly sample a mesh (V,F) n times. Parameters n number of samples V #V by dim list of mesh vertex positions F #F by 3 list of mesh triangle indices Returns B n by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) FI n list of indices into F See also Notes None Examples igl.read_dmat = read_dmat(\u2026) method of builtins.PyCapsule instance read_dmat(filename: str, dtype: numpy.dtype str type = 'float64') -> object \u00b6 Read a matrix from an ascii dmat file, a simple ascii matrix file type, defined as follows. The first line is always: <#columns> <#rows> Then the coefficients of the matrix are given separated by whitespace with columns running fastest. Parameters filename : string, path to .dmat file dtype : data-type of the returned matrix. Default is float64 . (returned faces always have type int32.) Returns w : array containing read-in coefficients See also read_triangle_mesh, read_off Notes None Examples w = read_dmat(\u201cmy_model.dmat\u201d) igl.read_dmat = read_dmat(\u2026) method of builtins.PyCapsule instance read_dmat(filename: str, dtype: numpy.dtype str type = 'float64') -> object \u00b6 Read a matrix from an ascii dmat file, a simple ascii matrix file type, defined as follows. The first line is always: <#columns> <#rows> Then the coefficients of the matrix are given separated by whitespace with columns running fastest. Parameters filename : string, path to .dmat file dtype : data-type of the returned matrix. Default is float64 . (returned faces always have type int32.) Returns w : array containing read-in coefficients See also read_triangle_mesh, read_off Notes None Examples w = read_dmat(\u201cmy_model.dmat\u201d) igl.read_obj = read_obj(\u2026) method of builtins.PyCapsule instance read_obj(filename: str, dtype: numpy.dtype str type = 'float64') -> Tuple[object, object, object, object, object, object] \u00b6 Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .obj file dtype : data-type of the returned faces, texture coordinates and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 tc : array of texture coordinats #tc by 2 n : array of corner normals #n by 3 f : #f array of face indices into vertex positions ftc : #f array of face indices into vertex texture coordinates fn : #f array of face indices into vertex normals See also read_triangle_mesh, read_off Notes None Examples v, _, n, f, _, _ = read_obj(\u201cmy_model.obj\u201d) igl.read_obj = read_obj(\u2026) method of builtins.PyCapsule instance read_obj(filename: str, dtype: numpy.dtype str type = 'float64') -> Tuple[object, object, object, object, object, object] \u00b6 Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .obj file dtype : data-type of the returned faces, texture coordinates and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 tc : array of texture coordinats #tc by 2 n : array of corner normals #n by 3 f : #f array of face indices into vertex positions ftc : #f array of face indices into vertex texture coordinates fn : #f array of face indices into vertex normals See also read_triangle_mesh, read_off Notes None Examples v, _, n, f, _, _ = read_obj(\u201cmy_model.obj\u201d) igl.read_off = read_off(\u2026) method of builtins.PyCapsule instance read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype str type = 'float64') -> Tuple[object, object, object] \u00b6 Read a mesh from an ascii off file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .off file read_normals : bool, determines whether normals are read. If false, returns [] dtype : data-type of the returned vertices, faces, and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions n : list of vertex normals #v by 3 See also read_triangle_mesh, read_obj Notes None Examples v, f, n, c = read_off(\u201cmy_model.off\u201d) igl.read_off = read_off(\u2026) method of builtins.PyCapsule instance read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype str type = 'float64') -> Tuple[object, object, object] \u00b6 Read a mesh from an ascii off file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .off file read_normals : bool, determines whether normals are read. If false, returns [] dtype : data-type of the returned vertices, faces, and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions n : list of vertex normals #v by 3 See also read_triangle_mesh, read_obj Notes None Examples v, f, n, c = read_off(\u201cmy_model.off\u201d) igl.read_triangle_mesh = read_triangle_mesh(\u2026) method of builtins.PyCapsule instance read_triangle_mesh(filename: str, dtype: numpy.dtype str type = 'float64') -> Tuple[object, object] \u00b6 Read mesh from an ascii file with automatic detection of file format. Supported: obj, off, stl, wrl, ply, mesh. Parameters filename : string, path to mesh file dtype : data-type of the returned vertices, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions See also read_obj, read_off, read_stl Notes None Examples v, f = read_triangle_mesh(\u201cmy_model.obj\u201d) igl.read_triangle_mesh = read_triangle_mesh(\u2026) method of builtins.PyCapsule instance read_triangle_mesh(filename: str, dtype: numpy.dtype str type = 'float64') -> Tuple[object, object] \u00b6 Read mesh from an ascii file with automatic detection of file format. Supported: obj, off, stl, wrl, ply, mesh. Parameters filename : string, path to mesh file dtype : data-type of the returned vertices, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions See also read_obj, read_off, read_stl Notes None Examples v, f = read_triangle_mesh(\u201cmy_model.obj\u201d) igl.remove_duplicate_vertices = remove_duplicate_vertices(\u2026) method of builtins.PyCapsule instance remove_duplicate_vertices(v: array, f: array, epsilon: float) -> Tuple[object, object, object, object] \u00b6 REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness tolerance (epsilon) Parameters V #V by dim list of vertex positions epsilon uniqueness tolerance (significant digit), can probably think of this as a tolerance on L1 distance Returns SV #SV by dim new list of vertex positions SVI #V by 1 list of indices so SV = V(SVI,:) SVJ #SV by 1 list of indices so V = SV(SVJ,:) Wrapper that also remaps given faces (F) \u2192 (SF) so that SF index SV See also Notes None Examples % Mesh in (V,F) [SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7); % remap faces SF = SVJ(F); igl.remove_duplicate_vertices = remove_duplicate_vertices(\u2026) method of builtins.PyCapsule instance remove_duplicate_vertices(v: array, f: array, epsilon: float) -> Tuple[object, object, object, object] \u00b6 REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness tolerance (epsilon) Parameters V #V by dim list of vertex positions epsilon uniqueness tolerance (significant digit), can probably think of this as a tolerance on L1 distance Returns SV #SV by dim new list of vertex positions SVI #V by 1 list of indices so SV = V(SVI,:) SVJ #SV by 1 list of indices so V = SV(SVJ,:) Wrapper that also remaps given faces (F) \u2192 (SF) so that SF index SV See also Notes None Examples % Mesh in (V,F) [SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7); % remap faces SF = SVJ(F); igl.remove_duplicates = remove_duplicates(\u2026) method of builtins.PyCapsule instance remove_duplicates(v: array, f: array, epsilon: float) -> Tuple[object, object, object] \u00b6 Merge the duplicate vertices from V, fixing the topology accordingly Parameters V,F mesh description epsilon minimal distance to consider two vertices identical Returns NV, NF new mesh without duplicate vertices See also Notes None Examples igl.remove_duplicates = remove_duplicates(\u2026) method of builtins.PyCapsule instance remove_duplicates(v: array, f: array, epsilon: float) -> Tuple[object, object, object] \u00b6 Merge the duplicate vertices from V, fixing the topology accordingly Parameters V,F mesh description epsilon minimal distance to consider two vertices identical Returns NV, NF new mesh without duplicate vertices See also Notes None Examples igl.remove_unreferenced = remove_unreferenced(\u2026) method of builtins.PyCapsule instance remove_unreferenced(v: array, f: array) -> Tuple[object, object, object, object] \u00b6 Remove unreferenced vertices from V, updating F accordingly Parameters V #V by dim list of mesh vertex positions F #F by ss list of simplices (Values of -1 are quitely skipped) Returns NV #NV by dim list of mesh vertex positions NF #NF by ss list of simplices IM #V by 1 list of indices such that: NF = IM(F) and NT = IM(T) and V(find(IM<=size(NV,1)),:) = NV J #RV by 1 list, such that RV = V(J,:) See also Notes None Examples igl.remove_unreferenced = remove_unreferenced(\u2026) method of builtins.PyCapsule instance remove_unreferenced(v: array, f: array) -> Tuple[object, object, object, object] \u00b6 Remove unreferenced vertices from V, updating F accordingly Parameters V #V by dim list of mesh vertex positions F #F by ss list of simplices (Values of -1 are quitely skipped) Returns NV #NV by dim list of mesh vertex positions NF #NF by ss list of simplices IM #V by 1 list of indices such that: NF = IM(F) and NT = IM(T) and V(find(IM<=size(NV,1)),:) = NV J #RV by 1 list, such that RV = V(J,:) See also Notes None Examples igl.resolve_duplicated_faces = resolve_duplicated_faces(\u2026) method of builtins.PyCapsule instance resolve_duplicated_faces(f1: array) -> Tuple[object, object] \u00b6 Resolve duplicated faces according to the following rules per unique face: If the number of positively oriented faces equals the number of \u00b6 negatively oriented faces, remove all duplicated faces at this triangle. If the number of positively oriented faces equals the number of \u00b6 negatively oriented faces plus 1, keeps one of the positively oriented face. If the number of positively oriented faces equals the number of \u00b6 negatively oriented faces minus 1, keeps one of the negatively oriented face. If the number of postively oriented faces differ with the number of \u00b6 negativley oriented faces by more than 1, the mesh is not orientable. An exception will be thrown. Parameters F1 #F1 by 3 array of input faces. Returns F2 #F2 by 3 array of output faces without duplicated faces. J #F2 list of indices into F1. See also Notes None Examples igl.resolve_duplicated_faces = resolve_duplicated_faces(\u2026) method of builtins.PyCapsule instance resolve_duplicated_faces(f1: array) -> Tuple[object, object] \u00b6 Resolve duplicated faces according to the following rules per unique face: If the number of positively oriented faces equals the number of \u00b6 negatively oriented faces, remove all duplicated faces at this triangle. If the number of positively oriented faces equals the number of \u00b6 negatively oriented faces plus 1, keeps one of the positively oriented face. If the number of positively oriented faces equals the number of \u00b6 negatively oriented faces minus 1, keeps one of the negatively oriented face. If the number of postively oriented faces differ with the number of \u00b6 negativley oriented faces by more than 1, the mesh is not orientable. An exception will be thrown. Parameters F1 #F1 by 3 array of input faces. Returns F2 #F2 by 3 array of output faces without duplicated faces. J #F2 list of indices into F1. See also Notes None Examples igl.shape_diameter_function = shape_diameter_function(\u2026) method of builtins.PyCapsule instance shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -> object \u00b6 Compute shape diamater function per given point. In the parlence of the paper \u201cConsistent Mesh Partitioning and Skeletonisation using the Shape Diameter Function\u201d [Shapiro et al. 2008], this implementation uses a 180\u00b0 cone and a uniform average ( not a average weighted by inverse angles). Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of shape diamater function values between bounding box diagonal (perfect sphere) and 0 (perfect needle hook) See also Notes None Examples igl.shape_diameter_function = shape_diameter_function(\u2026) method of builtins.PyCapsule instance shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -> object \u00b6 Compute shape diamater function per given point. In the parlence of the paper \u201cConsistent Mesh Partitioning and Skeletonisation using the Shape Diameter Function\u201d [Shapiro et al. 2008], this implementation uses a 180\u00b0 cone and a uniform average ( not a average weighted by inverse angles). Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of shape diamater function values between bounding box diagonal (perfect sphere) and 0 (perfect needle hook) See also Notes None Examples igl.sort_angles = sort_angles(\u2026) method of builtins.PyCapsule instance sort_angles(m: array) -> object \u00b6 Sort angles in ascending order in a numerically robust way. Instead of computing angles using atan2(y, x), sort directly on (y, x). Parameters - M: m by n matrix of scalars. (n >= 2). Assuming the first column of M contains values for y, and the second column is x. Using the rest of the columns as tie-breaker. Returns R: an array of m indices. M.row(R[i]) contains the i-th smallest angle. See also Notes None. Examples igl.sort_angles = sort_angles(\u2026) method of builtins.PyCapsule instance sort_angles(m: array) -> object \u00b6 Sort angles in ascending order in a numerically robust way. Instead of computing angles using atan2(y, x), sort directly on (y, x). Parameters - M: m by n matrix of scalars. (n >= 2). Assuming the first column of M contains values for y, and the second column is x. Using the rest of the columns as tie-breaker. Returns R: an array of m indices. M.row(R[i]) contains the i-th smallest angle. See also Notes None. Examples igl.tetrahedralize = tetrahedralize(\u2026) method of builtins.PyCapsule instance tetrahedralize(v: array, f: array, switches: str = 'pYQ') -> Tuple[int, object, object, object] \u00b6 Mesh the interior of a surface mesh (V,F) using tetgen. Parameters v : #v by 3 vertex position array f : #v array of polygon face indices into V (0-indexed) switches : string of tetgen options (See tetgen documentation) e.g. \u201cpq1.414a0.01\u201d tries to mesh the interior of a given surface with quality and area constraints. Will mesh the convex hull constrained to pass through V (ignores F) Returns tv #v by 3 vertex position array tt #t by 4 array of tet face indices tf #f by 3 array of triangle face indices See also None Notes Returns status: 0 success 1 tetgen threw exception 2 tetgen did not crash but could not create any tets (probably there are holes, duplicate faces etc.) -1 other error Examples igl.tetrahedralize = tetrahedralize(\u2026) method of builtins.PyCapsule instance tetrahedralize(v: array, f: array, switches: str = 'pYQ') -> Tuple[int, object, object, object] \u00b6 Mesh the interior of a surface mesh (V,F) using tetgen. Parameters v : #v by 3 vertex position array f : #v array of polygon face indices into V (0-indexed) switches : string of tetgen options (See tetgen documentation) e.g. \u201cpq1.414a0.01\u201d tries to mesh the interior of a given surface with quality and area constraints. Will mesh the convex hull constrained to pass through V (ignores F) Returns tv #v by 3 vertex position array tt #t by 4 array of tet face indices tf #f by 3 array of triangle face indices See also None Notes Returns status: 0 success 1 tetgen threw exception 2 tetgen did not crash but could not create any tets (probably there are holes, duplicate faces etc.) -1 other error Examples igl.triangle_triangle_adjacency = triangle_triangle_adjacency(\u2026) method of builtins.PyCapsule instance triangle_triangle_adjacency(f: array) -> Tuple[object, object] \u00b6 Constructs the triangle-triangle adjacency matrix for a given mesh (V,F). Parameters F #F by simplex_size list of mesh faces (must be triangles) Returns TT #F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i TTi #F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i See also Notes NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third [2,3]. this convention is DIFFERENT from cotmatrix_entries.h Examples igl.triangle_triangle_adjacency = triangle_triangle_adjacency(\u2026) method of builtins.PyCapsule instance triangle_triangle_adjacency(f: array) -> Tuple[object, object] \u00b6 Constructs the triangle-triangle adjacency matrix for a given mesh (V,F). Parameters F #F by simplex_size list of mesh faces (must be triangles) Returns TT #F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i TTi #F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i See also Notes NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third [2,3]. this convention is DIFFERENT from cotmatrix_entries.h Examples igl.triangulate = triangulate(\u2026) method of builtins.PyCapsule instance triangulate(v: array, e: array, h: array, flags: str = 'a0.005qQ') -> Tuple[object, object] \u00b6 Triangulate the interior of a polygon using the triangle library. Parameters v : #v by 2 array of 2D vertex positions e : #e by 2 array of vertex ids forming unoriented edges of the boundary of the polygon h : #h by 2 coordinates of points contained inside holes of the polygon m : optional #v list of markers for input vertices flags : string of options pass to triangle (see triangle documentation) (default \u2018a0.005q\u2019) Returns v2 : #v2 by 2 coordinates of the vertives of the generated triangulation f2 : #f2 by 3 array of indices forming the faces of the generated triangulation m2 : (only if you passed in m) #v2 list of markers for output vertices See also Notes Examples v2, f2 = triangulate(v, e, h) igl.triangulate = triangulate(\u2026) method of builtins.PyCapsule instance triangulate(v: array, e: array, h: array, flags: str = 'a0.005qQ') -> Tuple[object, object] \u00b6 Triangulate the interior of a polygon using the triangle library. Parameters v : #v by 2 array of 2D vertex positions e : #e by 2 array of vertex ids forming unoriented edges of the boundary of the polygon h : #h by 2 coordinates of points contained inside holes of the polygon m : optional #v list of markers for input vertices flags : string of options pass to triangle (see triangle documentation) (default \u2018a0.005q\u2019) Returns v2 : #v2 by 2 coordinates of the vertives of the generated triangulation f2 : #f2 by 3 array of indices forming the faces of the generated triangulation m2 : (only if you passed in m) #v2 list of markers for output vertices See also Notes Examples v2, f2 = triangulate(v, e, h) igl.uniformly_sample_two_manifold_at_vertices = uniformly_sample_two_manifold_at_vertices(\u2026) method of builtins.PyCapsule instance uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -> object \u00b6 Find uniform sampling up to placing samples on mesh vertices Parameters Returns See also Notes None Examples igl.uniformly_sample_two_manifold_at_vertices = uniformly_sample_two_manifold_at_vertices(\u2026) method of builtins.PyCapsule instance uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -> object \u00b6 Find uniform sampling up to placing samples on mesh vertices Parameters Returns See also Notes None Examples igl.uniformly_sample_two_manifold_internal = uniformly_sample_two_manifold_internal(\u2026) method of builtins.PyCapsule instance uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -> object \u00b6 UNIFORMLY_SAMPLE_TWO_MANIFOLD Attempt to sample a mesh uniformly by furthest point relaxation as described in \u201cFast Automatic Skinning Transformations\u201d [Jacobson et al. 12] Section 3.3. Parameters W #W by dim positions of mesh in weight space F #F by 3 indices of triangles k number of samplse push factor by which corners should be pushed away Returns WS k by dim locations in weights space See also Notes None Examples igl.uniformly_sample_two_manifold_internal = uniformly_sample_two_manifold_internal(\u2026) method of builtins.PyCapsule instance uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -> object \u00b6 UNIFORMLY_SAMPLE_TWO_MANIFOLD Attempt to sample a mesh uniformly by furthest point relaxation as described in \u201cFast Automatic Skinning Transformations\u201d [Jacobson et al. 12] Section 3.3. Parameters W #W by dim positions of mesh in weight space F #F by 3 indices of triangles k number of samplse push factor by which corners should be pushed away Returns WS k by dim locations in weights space See also Notes None Examples igl.unproject = unproject(\u2026) method of builtins.PyCapsule instance unproject(win: array, model: array, proj: array, viewport: array) -> object \u00b6 Reimplementation of gluUnproject Parameters win #P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns scene #P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates See also Notes None Examples igl.unproject = unproject(\u2026) method of builtins.PyCapsule instance unproject(win: array, model: array, proj: array, viewport: array) -> object \u00b6 Reimplementation of gluUnproject Parameters win #P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns scene #P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates See also Notes None Examples igl.unproject_in_mesh = unproject_in_mesh(\u2026) method of builtins.PyCapsule instance unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -> Tuple[object, std::__1::vector<igl::Hit, std::__1::allocator<igl::Hit> >] \u00b6 Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position inside a given mesh. If the ray through the given screen location (x,y) hits the mesh more than twice then the 3D midpoint between the first two hits is return. If it hits once, then that point is return. If it does not hit the mesh then obj is not set. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns obj 3d unprojected mouse point in mesh hits vector of hits Returns number of hits See also Notes None Examples igl.unproject_in_mesh = unproject_in_mesh(\u2026) method of builtins.PyCapsule instance unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -> Tuple[object, std::__1::vector<igl::Hit, std::__1::allocator<igl::Hit> >] \u00b6 Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position inside a given mesh. If the ray through the given screen location (x,y) hits the mesh more than twice then the 3D midpoint between the first two hits is return. If it hits once, then that point is return. If it does not hit the mesh then obj is not set. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns obj 3d unprojected mouse point in mesh hits vector of hits Returns number of hits See also Notes None Examples igl.unproject_onto_mesh = unproject_onto_mesh(\u2026) method of builtins.PyCapsule instance unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -> Tuple[bool, int, object] \u00b6 Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position onto a given mesh, if the ray through the given screen location (x,y) hits the mesh. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns fid id of the first face hit bc barycentric coordinates of hit Returns true if there\u2019s a hit See also Notes None Examples igl.unproject_onto_mesh = unproject_onto_mesh(\u2026) method of builtins.PyCapsule instance unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -> Tuple[bool, int, object] \u00b6 Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position onto a given mesh, if the ray through the given screen location (x,y) hits the mesh. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns fid id of the first face hit bc barycentric coordinates of hit Returns true if there\u2019s a hit See also Notes None Examples igl.unproject_ray = unproject_ray(\u2026) method of builtins.PyCapsule instance unproject_ray(pos: array, model: array, proj: array, viewport: array) -> Tuple[object, object] \u00b6 Construct a ray (source point + direction vector) given a screen space positions (e.g. mouse) and a model-view projection constellation. Parameters pos 2d screen-space position (x,y) model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns s source of ray (pos unprojected with z=0) dir direction of ray (d - s) where d is pos unprojected with z=1 See also Notes None Examples igl.unproject_ray = unproject_ray(\u2026) method of builtins.PyCapsule instance unproject_ray(pos: array, model: array, proj: array, viewport: array) -> Tuple[object, object] \u00b6 Construct a ray (source point + direction vector) given a screen space positions (e.g. mouse) and a model-view projection constellation. Parameters pos 2d screen-space position (x,y) model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns s source of ray (pos unprojected with z=0) dir direction of ray (d - s) where d is pos unprojected with z=1 See also Notes None Examples igl.upsample = upsample(\u2026) method of builtins.PyCapsule instance upsample(v: array, f: array, number_of_subdivs: int = 1) -> Tuple[object, object] \u00b6 Subdivide a mesh without moving vertices: loop subdivision but odd vertices stay put and even vertices are just edge midpoints Parameters V #V by dim mesh vertices F #F by 3 mesh triangles Returns NV new vertex positions, V is guaranteed to be at top NF new list of face indices See also Notes assumes (V,F) is edge-manifold. Examples igl.upsample = upsample(\u2026) method of builtins.PyCapsule instance upsample(v: array, f: array, number_of_subdivs: int = 1) -> Tuple[object, object] \u00b6 Subdivide a mesh without moving vertices: loop subdivision but odd vertices stay put and even vertices are just edge midpoints Parameters V #V by dim mesh vertices F #F by 3 mesh triangles Returns NV new vertex positions, V is guaranteed to be at top NF new list of face indices See also Notes assumes (V,F) is edge-manifold. Examples igl.vector_area_matrix = vector_area_matrix(\u2026) method of builtins.PyCapsule instance vector_area_matrix(f: array) -> object \u00b6 Constructs the symmetric area matrix A, s.t. [V.col(0)\u2019 V.col(1)\u2019] * A * [V.col(0); V.col(1)] is the vector area of the mesh (V,F). Parameters f : #f by 3 array of mesh faces (must be triangles) Returns a : #vx2 by #vx2 area matrix See also None Notes None Examples igl.vector_area_matrix = vector_area_matrix(\u2026) method of builtins.PyCapsule instance vector_area_matrix(f: array) -> object \u00b6 Constructs the symmetric area matrix A, s.t. [V.col(0)\u2019 V.col(1)\u2019] * A * [V.col(0); V.col(1)] is the vector area of the mesh (V,F). Parameters f : #f by 3 array of mesh faces (must be triangles) Returns a : #vx2 by #vx2 area matrix See also None Notes None Examples igl.vertex_components = vertex_components(\u2026) method of builtins.PyCapsule instance vertex_components(f: array) -> object \u00b6 Compute connected components of the vertices of a mesh given the mesh\u2019 face indices. Parameters f : #f x dim array of face indices Returns An array of component ids (starting with 0) See also vertex_components_from_adjacency_matrix face_components_from_faces Notes Examples igl.vertex_components = vertex_components(\u2026) method of builtins.PyCapsule instance vertex_components(f: array) -> object \u00b6 Compute connected components of the vertices of a mesh given the mesh\u2019 face indices. Parameters f : #f x dim array of face indices Returns An array of component ids (starting with 0) See also vertex_components_from_adjacency_matrix face_components_from_faces Notes Examples igl.vertex_components_from_adjacency_matrix = vertex_components_from_adjacency_matrix(\u2026) method of builtins.PyCapsule instance vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix scipy.sparse.csc_matrix) -> Tuple[object, object] \u00b6 Compute connected components of a graph represented by a sparse adjacency matrix. Parameters a : n by n sparse adjacency matrix Returns A tuple (c, counts) where c is an array of component ids (starting with 0) and counts is a #components array of counts for each component See also vertex_components face_components Notes Examples igl.vertex_components_from_adjacency_matrix = vertex_components_from_adjacency_matrix(\u2026) method of builtins.PyCapsule instance vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix scipy.sparse.csc_matrix) -> Tuple[object, object] \u00b6 Compute connected components of a graph represented by a sparse adjacency matrix. Parameters a : n by n sparse adjacency matrix Returns A tuple (c, counts) where c is an array of component ids (starting with 0) and counts is a #components array of counts for each component See also vertex_components face_components Notes Examples igl.vertex_triangle_adjacency = vertex_triangle_adjacency(\u2026) method of builtins.PyCapsule instance vertex_triangle_adjacency(f: array, n: int) -> Tuple[object, object] \u00b6 vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F) Parameters F #F by 3 list of triangle indices into some vertex list V n number of vertices, #V (e.g., F.maxCoeff()+1) Returns VF 3*#F list List of faces indice on each vertex, so that VF(NI(i)+j) = f, means that face f is the jth face (in no particular order) incident on vertex i. NI #V+1 list cumulative sum of vertex-triangle degrees with a preceeding zero. \u201cHow many faces\u201d have been seen before visiting this vertex and its incident faces. See also Notes None Examples igl.vertex_triangle_adjacency = vertex_triangle_adjacency(\u2026) method of builtins.PyCapsule instance vertex_triangle_adjacency(f: array, n: int) -> Tuple[object, object] \u00b6 vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F) Parameters F #F by 3 list of triangle indices into some vertex list V n number of vertices, #V (e.g., F.maxCoeff()+1) Returns VF 3*#F list List of faces indice on each vertex, so that VF(NI(i)+j) = f, means that face f is the jth face (in no particular order) incident on vertex i. NI #V+1 list cumulative sum of vertex-triangle degrees with a preceeding zero. \u201cHow many faces\u201d have been seen before visiting this vertex and its incident faces. See also Notes None Examples igl.winding_number = winding_number(\u2026) method of builtins.PyCapsule instance winding_number(v: array, f: array, o: array) -> object \u00b6 WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron described by points (vectors) V Parameters V n by 3 list of vertex positions F #F by 3 list of triangle indices, minimum index is 0 O no by 3 list of origin positions Returns S no by 1 list of winding numbers See also Notes None Examples igl.winding_number = winding_number(\u2026) method of builtins.PyCapsule instance winding_number(v: array, f: array, o: array) -> object \u00b6 WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron described by points (vectors) V Parameters V n by 3 list of vertex positions F #F by 3 list of triangle indices, minimum index is 0 O no by 3 list of origin positions Returns S no by 1 list of winding numbers See also Notes None Examples igl.winding_number_for_point = winding_number_for_point(\u2026) method of builtins.PyCapsule instance winding_number_for_point(v: array, f: array, p: array) -> float \u00b6 Compute winding number of a single point Parameters V n by dim list of vertex positions F #F by dim list of triangle indices, minimum index is 0 p single origin position Returns w winding number of this point See also Notes None Examples igl.winding_number_for_point = winding_number_for_point(\u2026) method of builtins.PyCapsule instance winding_number_for_point(v: array, f: array, p: array) -> float \u00b6 Compute winding number of a single point Parameters V n by dim list of vertex positions F #F by dim list of triangle indices, minimum index is 0 p single origin position Returns w winding number of this point See also Notes None Examples igl.write_obj = write_obj(\u2026) method of builtins.PyCapsule instance write_obj(filename: str, v: array, f: array) -> bool \u00b6 Write a mesh in an ascii obj file. Parameters filename : path to outputfile v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions Returns ret : bool if output was successful See also read_obj Notes None Examples Mesh in (v, f) success = write_obj(v, f) igl.write_obj = write_obj(\u2026) method of builtins.PyCapsule instance write_obj(filename: str, v: array, f: array) -> bool \u00b6 Write a mesh in an ascii obj file. Parameters filename : path to outputfile v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions Returns ret : bool if output was successful See also read_obj Notes None Examples Mesh in (v, f) success = write_obj(v, f) igl.write_off = write_off(\u2026) method of builtins.PyCapsule instance write_off(str: str, v: array, f: array, c: array) -> bool \u00b6 Export geometry and colors-by-vertex Export a mesh from an ascii OFF file, filling in vertex positions. Only triangle meshes are supported Parameters str path to .off output file V #V by 3 mesh vertex positions F #F by 3 mesh indices into V C double matrix of rgb values per vertex #V by 3 Returns Returns true on success, false on errors See also Notes None Examples igl.write_off = write_off(\u2026) method of builtins.PyCapsule instance write_off(str: str, v: array, f: array, c: array) -> bool \u00b6 Export geometry and colors-by-vertex Export a mesh from an ascii OFF file, filling in vertex positions. Only triangle meshes are supported Parameters str path to .off output file V #V by 3 mesh vertex positions F #F by 3 mesh indices into V C double matrix of rgb values per vertex #V by 3 Returns Returns true on success, false on errors See also Notes None Examples igl.write_triangle_mesh = write_triangle_mesh(\u2026) method of builtins.PyCapsule instance write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -> bool \u00b6 write mesh to a file with automatic detection of file format. supported: obj, off, stl, wrl, ply, mesh). Parameters str path to file V eigen double matrix #V by 3 F eigen int matrix #F by 3 force_ascii=True force ascii format even if binary is available Returns Returns true iff success See also Notes Examples igl.write_triangle_mesh = write_triangle_mesh(\u2026) method of builtins.PyCapsule instance write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -> bool \u00b6 write mesh to a file with automatic detection of file format. supported: obj, off, stl, wrl, ply, mesh). Parameters str path to file V eigen double matrix #V by 3 F eigen int matrix #F by 3 force_ascii=True force ascii format even if binary is available Returns Returns true iff success See also Notes Examples class ARAP solve(: igl.pyigl_classes.ARAP, arg0: numpy.ndarray, arg1: numpy.ndarray) -> object \u00b6 class BBW solve(: igl.pyigl_classes.BBW, arg0: numpy.ndarray, arg1: numpy.ndarray, arg2: numpy.ndarray[int32[m, 1]], arg3: numpy.ndarray) -> object \u00b6 class SLIM energy(: igl.pyigl_classes.SLIM) -> float \u00b6 solve(: igl.pyigl_classes.SLIM, arg0: int) \u00b6 vertices(: igl.pyigl_classes.SLIM) -> object \u00b6","title":"Docs"},{"location":"igl_docs/#adjacency_listf-array-handle","text":"Constructs the graph adjacency list of a given mesh (v, f) Parameters f : #f by dim array of fixed dimensional (e.g. triangle (#f by 3), tet (#f by 4), quad (#f by 4), etc\u2026) mesh faces Returns list of lists containing at index i the adjacent vertices of vertex i See also adjacency_matrix Notes Examples Mesh in (v, f) a = mesh_adjacency_list(f)","title":"adjacency_list(f: array) -&gt; handle"},{"location":"igl_docs/#adjacency_matrixf-array-object","text":"Constructs the graph adjacency matrix of a given mesh (v, f). Parameters f : #f by dim list of mesh simplices Returns a : max(f) by max(f) cotangent matrix, each row i corresponding to v(i, :) See also adjacency_list, edges, cotmatrix, diag Notes None Examples Mesh in (v, f) a = adjacency_matrix(f) Sum each row a_sum = np.sum(a, axis=1) Convert row sums into diagonal of sparse matrix a_diag = diag(a_sum) Build uniform laplacian u = a - a_diag","title":"adjacency_matrix(f: array) -&gt; object"},{"location":"igl_docs/#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object","text":"Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of ambient occusion values between 1 (fully occluded) and 0 (not occluded) See also Notes None Examples","title":"ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object"},{"location":"igl_docs/#arap_linear_blockv-array-f-array-d-int-energy-int-object","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns #v by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples","title":"arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object"},{"location":"igl_docs/#arap_linear_block_elementsv-array-f-array-d-int-object","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns #v by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples","title":"arap_linear_block_elements(v: array, f: array, d: int) -&gt; object"},{"location":"igl_docs/#arap_linear_block_spokesv-array-f-array-d-int-object","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns #v by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples","title":"arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object"},{"location":"igl_docs/#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns #v by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples","title":"arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object"},{"location":"igl_docs/#arap_rhsv-array-f-array-d-int-energy-int-object","text":"Guild right-hand side constructor of global poisson solve for various ARAP energies Inputs: Outputs: K #V*dim by #(FV)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); Parameters v : #v by Vdim list of initial domain positions f : #f by 3 list of triangle indices into v d : dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2 energy : ARAPEnergyType enum value defining which energy is being used. See igl.ARAPEnergyType for valid options and explanations. Returns #v*d by #(fv)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); See also arap_linear_block, arap Notes Examples","title":"arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object"},{"location":"igl_docs/#average_onto_verticesv-array-f-array-s-array-object","text":"Move a scalar field defined on faces to vertices by averaging Parameters v : #v by vdim array of mesh vertices f : #f by simplex_count array of simplex indices s : #f by dim scalar field defined on simplices Returns #v by dim scalar field defined on vertices See also average_onto_faces Notes Examples","title":"average_onto_vertices(v: array, f: array, s: array) -&gt; object"},{"location":"igl_docs/#avg_edge_lengthv-array-f-array-float","text":"Compute the average edge length for the given triangle mesh. Parameters v : array_like #v by 3 vertex array f : f #f by simplex-size list of mesh faces (must be simplex) Returns l : average edge length See also adjacency_matrix Notes None Examples Mesh in (v, f) length = avg_edge_length(v, f)","title":"avg_edge_length(v: array, f: array) -&gt; float"},{"location":"igl_docs/#barycenterv-array-f-array-object","text":"Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V Returns A #f x dim matrix where each row is the barycenter of each simplex See also Notes None Examples","title":"barycenter(v: array, f: array) -&gt; object"},{"location":"igl_docs/#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object","text":"Compute barycentric coordinates in a tet corresponding to the Euclidean coordinates in p . The input arrays a , b , c and d are the vertices of each tet. I.e. one tet is a[i, :], b[i, :], c[i, :], d[:, i] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tet corners in 3d b : #P by 3 Tet corners in 3d c : #P by 3 Tet corners in 3d d : #P by 3 Tet corners in 3d Returns #P by 4 list of barycentric coordinates See also Notes Examples","title":"barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object"},{"location":"igl_docs/#barycentric_coordinates_trip-array-a-array-b-array-c-array-object","text":"Compute barycentric coordinates in a triangle corresponding to the Euclidean coordinates in p . The input arrays a , b , and c are the vertices of each triangle. I.e. one triangle is a[i, :], b[i, :], c[i, :] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tri corners in 3d b : #P by 3 Tri corners in 3d c : #P by 3 Tri corners in 3d Returns #P by 3 list of barycentric coordinates See also Notes Examples","title":"barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object"},{"location":"igl_docs/#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object","text":"Construct an array indexing into a directed graph represented by an adjacency list using breadth first search. I.e. the output is an array of vertices in breadth-first order. Parameters A : #V list of adjacency lists or #V by #V adjacency matrix s : starting node (index into A) Returns A tuple, (d, p) where: d is a #V list of indices into rows of A in the order in which graph nodes are discovered p is a #V list of indices of A of predecsors where -1 indicates root/not discovered. I.e. p[i] is the index of the vertex v which preceded d[i] in the breadth first traversal. Note that together, (d, p) form a spanning tree of the input graph See also Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) A = igl.adjacency_matrix(V, F) d, p = igl.bfs(A, V[0])","title":"bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bfs_orientf-array-tupleobject-object","text":"Consistently orient faces in orientable patches using BFS. Parameters f : #F by 3 list of faces Returns A tuple, (ff, c) where: ff is a #F by 3 list of faces which are consistently oriented with c is a #F array of connected component ids See also Notes Examples v, f, _ = igl.readOFF(\u201ctest.off) ff, c = igl.bfs_orient(f)","title":"bfs_orient(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bone_parentsbe-array-object","text":"BONE_PARENTS Recover \u201cparent\u201d bones from directed graph representation. Parameters BE #BE by 2 list of directed bone edges Returns P #BE by 1 list of parent indices into BE, -1 means root. See also Notes None Examples","title":"bone_parents(be: array) -&gt; object"},{"location":"igl_docs/#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object","text":"Compute boundary conditions for automatic weights computation. This function expects that the given mesh (V,Ele) has sufficient samples (vertices) exactly at point handle locations and exactly along bone and cage edges. Parameters V #V by dim list of domain vertices Ele #Ele by simplex-size list of simplex indices C #C by dim list of handle positions P #P by 1 list of point handle indices into C BE #BE by 2 list of bone edge indices into C CE #CE by 2 list of cage edge indices into P Returns b #b list of boundary indices (indices into V of vertices which have known, fixed values) bc #b by #weights list of known/fixed values for boundary vertices (notice the #b != #weights in general because #b will include all the intermediary samples along each bone, etc.. The ordering of the weights corresponds to [P;BE] Returns false if boundary conditions are suspicious: P and BE are empty bc is empty some column of bc doesn\u2019t have a 0 (assuming bc has >1 columns) some column of bc doesn\u2019t have a 1 (assuming bc has >1 columns) See also Notes None Examples","title":"boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]"},{"location":"igl_docs/#boundary_facetst-array-object","text":"Determine boundary faces (edges) of tetrahedra (triangles). Parameters t : tetrahedron or triangle index list, m by 4/3, where m is the number of tetrahedra/triangles Returns f : list of boundary faces, n by 3/2, where n is the number of boundary faces/edges See also None Notes None Examples Mesh in (v, f) b = boundary_facets(f)","title":"boundary_facets(t: array) -&gt; object"},{"location":"igl_docs/#boundary_loopf-array-object","text":"Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. Parameters f : #v by dim array of mesh faces Returns l : ordered list of boundary vertices of longest boundary loop See also Notes None Examples Mesh in (v, f) l = boundary_loop(f)","title":"boundary_loop(f: array) -&gt; object"},{"location":"igl_docs/#bounding_boxargs-kwargs","text":"","title":"bounding_box(*args, **kwargs)"},{"location":"igl_docs/#bounding_boxv-array-tupleobject-object","text":"Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples","title":"bounding_box(v: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bounding_boxv-array-pad-float-tupleobject-object","text":"Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples","title":"bounding_box(v: array, pad: float) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bounding_box_diagonalv-array-float","text":"Compute the length of the diagonal of a given meshes axis-aligned bounding Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V Returns Returns length of bounding box diagonal See also Notes None Examples","title":"bounding_box_diagonal(v: array) -&gt; float"},{"location":"igl_docs/#centroidv-array-f-array-tupleobject","text":"Computes the centroid of a closed mesh using a surface integral. Parameters v : #v by dim array of rest domain positions f : #f by 3 array of triangle indices into v Returns c : dim array of centroid coordinates vol : total volume of solid See also None Notes None Examples Mesh in (v, f) c, vol = centroid(v, f)","title":"centroid(v: array, f: array) -&gt; Tuple[object]"},{"location":"igl_docs/#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint","text":"Return list of faces around the end point of an edge. Assumes data-structures are built from an edge-manifold closed mesh. Parameters e index into E of edge to circulate ccw whether to continue in ccw direction of edge (circulate around","title":"circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]"},{"location":"igl_docs/#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique","text":"unique edge in E EF #E by 2 list of edge flaps, EF(e,0)=f means e=(i\u2192j) is the edge of","title":"EMAP #F*3 list of indices into E, mapping each directed edge to unique"},{"location":"igl_docs/#ej-i","text":"EI #E by 2 list of edge flap corners (see above). Returns Returns list of faces touched by circulation (in cyclically order). See also Notes None Examples","title":"e=(j-&gt;i)"},{"location":"igl_docs/#circumradiusv-array-f-array-object","text":"Compute the circumradius of each triangle in a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of triangle indices into V Returns R #F list of circumradii See also Notes None Examples R = circumradius(V, F)","title":"circumradius(v: array, f: array) -&gt; object"},{"location":"igl_docs/#collapse_small_trianglesv-array-f-array-eps-float-object","text":"Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the original faces and vertices of (V,F) except any small triangles have been removed via collapse. We are not following the rules in \u201cMesh Optimization\u201d [Hoppe et al] Section 4.2. But for our purposes we don\u2019t care about this criteria. Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V eps epsilon for smallest allowed area treated as fraction of squared bounding box diagonal Returns FF #FF by 3 list of triangle indices into V See also Notes None Examples","title":"collapse_small_triangles(v: array, f: array, eps: float) -&gt; object"},{"location":"igl_docs/#connect_boundary_to_infinityf-array-object","text":"Connect all boundary edges to a fictitious point at infinity. Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into [V;inf inf inf], original F are guaranteed to come first. If (V,F) was a manifold mesh, now it is closed with a possibly non-manifold vertex at infinity (but it will be edge-manifold). See also Notes None Examples","title":"connect_boundary_to_infinity(f: array) -&gt; object"},{"location":"igl_docs/#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object","text":"Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into VO See also Notes None Examples","title":"connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#connect_boundary_to_infinity_indexf-array-inf_index-int-object","text":"Parameters inf_index index of point at infinity (usually V.rows() or F.maxCoeff()) Returns See also Notes None Examples","title":"connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object"},{"location":"igl_docs/#cotmatrixv-array-f-array-object","text":"Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (v, f). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) Returns l : #v by #v cotangent matrix, each row i corresponding to v(i, :) See also adjacency_matrix Notes This Laplacian uses the convention that diagonal entries are minus the sum of off-diagonal entries. The diagonal entries are therefore in general negative and the matrix is negative semi-definite (immediately, -L is positive semi-definite) Examples Mesh in (v, f) l = cotmatrix(v, f)","title":"cotmatrix(v: array, f: array) -&gt; object"},{"location":"igl_docs/#cotmatrix_entriesv-array-f-array-object","text":"COTMATRIX_ENTRIES compute the cotangents of each angle in mesh (V,F) Parameters V #V by dim list of rest domain positions F #F by {34} list of {triangletetrahedra} indices into V Returns C #F by 3 list of \u00bd*cotangents corresponding angles for triangles, columns correspond to edges [1,2],[2,0],[0,1] OR C #F by 6 list of \u2159*cotangents of dihedral angles*edge lengths for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2] See also Notes None Examples","title":"cotmatrix_entries(v: array, f: array) -&gt; object"},{"location":"igl_docs/#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object","text":"CROUZEIX_RAVIART_COTMATRIX Compute the Crouzeix-Raviart cotangent stiffness matrix. Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns L #E by #E edge/face-based diagonal cotangent matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also See also: crouzeix_raviart_massmatrix Notes None Examples See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007]","title":"crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object","text":"wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples","title":"crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object"},{"location":"igl_docs/#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object","text":"CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where","title":"crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#edge-e","text":"Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns M #E by #E edge/face-based diagonal mass matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also crouzeix_raviart_cotmatrix Notes See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] Examples","title":"edge e."},{"location":"igl_docs/#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object","text":"wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples","title":"crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object"},{"location":"igl_docs/#cut_meshv-array-f-array-cuts-array-tupleobject-object","text":"Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V cuts : #F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) Returns A pair (vcut, fcut) where: vcut is a #v by 3 list of the vertex positions of the cut mesh. This matrix will be similar to the original vertices except some rows will be duplicated. fcut is a #f by 3 list of the faces of the cut mesh (must be triangles). This matrix will be similar to the original face matrix except some indices will be redirected to point to the newly duplicated vertices. See also Notes Examples","title":"cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object","text":"Given a mesh (v,f) and the integer mismatch of a cross field per edge (mismatch), finds and returns the cut_graph connecting the singularities (seams) Parameters v : #v by 3 array of triangle vertices (each row is a vertex) f : #f by 3 array of triangle indices into v mismatch : #f by 3 array of per-corner integer mismatches Returns seams : #f by 3 array of per corner booleans that de**notes if an edge is a** seam or not See also cut_mesh Notes Examples","title":"cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object"},{"location":"igl_docs/#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object","text":"Construct a triangle mesh of a cylinder (without caps) Parameters axis_devisions number of vertices around the cylinder height_devisions number of vertices up the cylinder Returns V #V by 3 list of mesh vertex positions F #F by 3 list of triangle indices into V See also Notes None Examples","title":"cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object","text":"Assumes (V,F) is a manifold mesh (possibly with boundary) Collapses edges until desired number of faces is achieved. This uses default edge cost and merged vertex placement functions {edge length, edge midpoint}. Parameters V #V by dim list of vertex positions F #F by 3 list of face indices into V. max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices Returns true if m was reached (otherwise #G > m) See also Notes None Examples","title":"decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]"},{"location":"igl_docs/#dihedral_anglesv-array-t-array-tupleobject-object","text":"Compute dihedral angles for all tets of a given tet mesh (v, t). Parameters v : #v by dim list of vertex positions t : #v by 4 list of tet indices Returns theta : #t by 6 list of dihedral angles (in radians) cos_theta : #t by 6 list of cosine of dihedral angles (in radians) See also Notes None Examples TetMesh in (v, t) theta, cos_theta = dihedral_angles(v, t)","title":"dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#dihedral_angles_intrinsicl-array-a-array-tupleobject-object","text":"See dihedral_angles for the documentation.","title":"dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#directed_edge_parentse-array-object","text":"Recover \u201cparents\u201d (preceding edges) in a tree given just directed edges. Parameters e : #e by 2 list of directed edges Returns p : #e list of parent indices into e. (-1) means root See also Notes None Examples p = edges(e)","title":"directed_edge_parents(e: array) -&gt; object"},{"location":"igl_docs/#doubleareav-array-f-array-object","text":"Computes twice the area for each input triangle[quad] Parameters v : #v by dim array of mesh vertex positions f : #f by simplex_size array of mesh faces (must be triangles or quads) Returns d_area : #f list of triangle[quad] double areas (SIGNED only for 2D input) See also None Notes Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal if you have 1million unreferenced vertices and 1 face Examples Mesh in (v, f) dbl_area = doublearea(v, f)","title":"doublearea(v: array, f: array) -&gt; object"},{"location":"igl_docs/#earsf-array-tupleobject-object","text":"FIND_EARS Find all ears (faces with two boundary edges) in a given mesh Parameters F #F by 3 list of triangle mesh indices Returns ears #ears list of indices into F of ears ear_opp #ears list of indices indicating which edge is non-boundary (connecting to flops) See also Notes None Examples ears,ear_opp = find_ears(F)","title":"ears(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#edge_topologyv-array-f-array-tupleobject-object-object","text":"Initialize Edges and their topological relations (assumes an edge-manifold mesh) Parameters v : #v by dim, list of mesh vertex positions (unused) f : #f by 3, list of triangle indices into V Returns ev : #e by 2, list of edges described as pair of vertices. fe : #f by 3, list storing triangle-edge relation. ef : #e by w, list storing edge-triangle relation, uses -1 to indicate boundaries. See also Notes None Examples Mesh in (v, f) ev, fe, ef = edge_topology(v, f)","title":"edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#edgesf-array-object","text":"Constructs a list of unique edges represented in a given mesh (v, f) Parameters f : #F by dim list of mesh faces (must be triangles or tets) Returns #e by 2 list of edges in no particular order See also adjacency_matrix Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) E = igl.edges(F)","title":"edges(f: array) -&gt; object"},{"location":"igl_docs/#euler_characteristicf-array-int","text":"Computes the Euler characteristic of a given mesh (V,F) Parameters F #F by dim list of mesh faces (must be triangles) Returns Returns An int containing the Euler characteristic See also Notes None Examples","title":"euler_characteristic(f: array) -&gt; int"},{"location":"igl_docs/#euler_characteristic_completev-array-f-array-int","text":"Parameters V #V by dim list of mesh vertex positions Returns See also Notes None Examples","title":"euler_characteristic_complete(v: array, f: array) -&gt; int"},{"location":"igl_docs/#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object","text":"Exact geodesic algorithm for the calculation of geodesics on a triangular mesh. Parameters v : #v by 3 array of 3D vertex positions f : #f by 3 array of mesh faces vs : #vs by 1 array specifying indices of source vertices fs : #fs by 1 array specifying indices of source faces vt : #vt by 1 array specifying indices of target vertices ft : #ft by 1 array specifying indices of target faces Returns d : #vt+#ft by 1 array of geodesic distances of each target w.r.t. the nearest one in the source set See also Notes Specifying a face as target/source means its center. Implementation from https:code.google.com/archive/p/geodesic/ with the algorithm first described by Mitchell, Mount and Papadimitriou in 1987. Examples","title":"exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object"},{"location":"igl_docs/#face_componentsf-array-object","text":"Compute connected components of facets based on edge-edge adjacency, Parameters f : #f x 3 array of triangle indices Returns An array, c, with shape (#f,), of component ids See also vertex_components vertex_components_from_adjacency_matrix Notes Examples","title":"face_components(f: array) -&gt; object"},{"location":"igl_docs/#fit_planev-array-tupleobject-object","text":"This function fits a plane to a point cloud. Parameters V #Vx3 matrix. The 3D point cloud, one row for each vertex. Returns N 1x3 Vector. The normal of the fitted plane. C 1x3 Vector. A point that lies in the fitted plane. See also Notes From http:missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html Examples","title":"fit_plane(v: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object","text":"A bisection line search for a mesh based energy that avoids triangle flips as suggested in \u201cBijective Parameterization with Free Boundaries\u201d (Smith J. and Schaefer S., 2015). The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles). This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see igl::line_search). Supports both triangle and tet meshes. Parameters F #F by \u00be list of mesh faces or tets cur_v #V by dim list of variables dst_v #V by dim list of target vertices. This mesh may have flipped triangles energy A function to compute the mesh-based energy (return an energy that is bigger than 0)","title":"flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]"},{"location":"igl_docs/#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it","text":"Returns cur_v #V by dim list of variables at the new location Returns the energy at the new point See also Notes None Examples","title":"cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it."},{"location":"igl_docs/#gaussian_curvaturev-array-f-array-object","text":"Compute discrete local integral gaussian curvature (angle deficit, without averaging by local area). Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices Returns k : #v by 1 array of discrete gaussian curvature values See also principal_curvature Notes None Examples Mesh in (v, f) k = gaussian_curvature(v, f)","title":"gaussian_curvature(v: array, f: array) -&gt; object"},{"location":"igl_docs/#gradv-array-f-array-uniform-bool-false-object","text":"Compute the numerical gradient operator. Parameters v : #v by 3 list of mesh vertex positions f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices] uniform : boolean (default false). Use a uniform mesh instead of the vertices v Returns g : #faces * dim by #v gradient operator See also cotmatrix, massmatrix Notes Gradient of a scalar function defined on piecewise linear elements (mesh) is constant on each triangle [tetrahedron] i,j,k:","title":"grad(v: array, f: array, uniform: bool = False) -&gt; object"},{"location":"igl_docs/#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a","text":"where Xi is the scalar value at vertex i, Vi is the 3D position of vertex i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of 90 degrees. Examples Mesh in (v, f) g = grad(v, f)","title":"grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A"},{"location":"igl_docs/#harmonicl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-b-array-bc-array-k-int-object","text":"Compute a harmonic map using a given Laplacian and mass matrix Parameters L #V by #V discrete (integrated) Laplacian M #V by #V mass matrix b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #V list of weights See also Notes Examples","title":"harmonic(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, b: array, bc: array, k: int) -&gt; object"},{"location":"igl_docs/#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object","text":"Build the discrete k-harmonic operator (computing integrated quantities). That is, if the k-harmonic PDE is Q x = 0, then this minimizes x\u2019 Q x Parameters L #V by #V discrete (integrated) Laplacian M #V by #V mass matrix k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns Q #V by #V discrete (integrated) k-Laplacian See also Notes Examples","title":"harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object"},{"location":"igl_docs/#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object","text":"Compute harmonic map using uniform laplacian operator Parameters F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples","title":"harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object"},{"location":"igl_docs/#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object","text":"Compute k-harmonic weight functions \u201ccoordinates\u201d. Parameters V #V by dim vertex positions F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples","title":"harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object"},{"location":"igl_docs/#hausdorffva-array-fa-array-vb-array-fb-array-float","text":"HAUSDORFF compute the Hausdorff distance between mesh (VA,FA) and mesh (VB,FB). This is the","title":"hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float"},{"location":"igl_docs/#aa-bb-bb-aa","text":"Parameters VA #VA by 3 list of vertex positions FA #FA by 3 list of face indices into VA VB #VB by 3 list of vertex positions FB #FB by 3 list of face indices into VB Returns d hausdorff distance pair 2 by 3 list of \u201cdeterminer points\u201d so that pair(1,:) is from A and pair(2,:) is from B See also Notes Known issue: This is only computing max(min(va,B),min(vb,A)). This is better than max(min(va,Vb),min(vb,Va)). This (at least) is missing \u201cedge-edge\u201d cases like the distance between the two different triangulations of a non-planar quad in 3D. Even simpler, consider the Hausdorff distance between the non-convex, block letter V polygon (with 7 vertices) in 2D and its convex hull. The Hausdorff distance is defined by the midpoint in the middle of the segment across the concavity and some non-vertex point on the edge of the V. Examples","title":"a\u2208A b\u2208B          b\u2208B a\u2208A"},{"location":"igl_docs/#internal_anglesv-array-f-array-object","text":"Computes internal angles for a triangle mesh. Parameters v : #v by dim array of mesh vertex nD positions f : #f by poly-size array of face (triangle) indices Returns k : #f by poly-size array of internal angles. For triangles, columns correspond to edges [1,2],[2,0],[0,1]. See also None Notes If poly-size \u2260 3 then dim must equal 3. Examples","title":"internal_angles(v: array, f: array) -&gt; object"},{"location":"igl_docs/#is_edge_manifoldf-array-bool","text":"See is_edge_manifold for the documentation.","title":"is_edge_manifold(f: array) -&gt; bool"},{"location":"igl_docs/#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool","text":"Determine if a vertex is irregular, i.e. it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored. Parameters v : #v by dim array of vertex positions f : #f by 3[4] array of triangle[quads] indices Returns s : #v list of bools revealing whether vertices are singular See also None Notes None Examples","title":"is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;"},{"location":"igl_docs/#isolinesv-array-f-array-z-array-n-int-tupleobject-object","text":"Constructs isolines for a function z given on a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of mesh faces (must be triangles) z #V by 1 list of function values evaluated at vertices n the number of desired isolines Returns isoV #isoV by dim list of isoline vertex positions isoE #isoE by 2 list of isoline edge positions See also Notes None Examples","title":"isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#lscmv-array-f-array-b-array-bc-array-tuplebool-object","text":"Compute a Least-squares conformal map parametrization. Parameters v : #v by 3 array of mesh vertex positions f : #f by 3 array of mesh faces (must be triangles) b : #b boundary indices into v bc : #b by 3 list of boundary values Returns uv #v by 2 list of 2D mesh vertex positions in UV space See also None Notes Derived in \u201cIntrinsic Parameterizations of Surface Meshes\u201d [Desbrun et al. 2002] and \u201cLeast Squares Conformal Maps for Automatic Texture Atlas Generation\u201d [L\u00e9vy et al. 2002]), though this implementation follows the derivation in: \u201cSpectral Conformal Parameterization\u201d [Mullen et al. 2008] (note, this does not implement the Eigen-decomposition based method in [Mullen et al. 2008], which is not equivalent. Input should be a manifold mesh (also no unreferenced vertices) and \u201cboundary\u201d (fixed vertices) b should contain at least two vertices per connected component. Returns true only on solver success. Examples","title":"lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]"},{"location":"igl_docs/#map_vertices_to_circlev-array-bnd-array-object","text":"Map the vertices whose indices are in a given boundary loop (bnd) on the unit circle with spacing proportional to the original boundary edge lengths. Parameters v : #v by dim array of mesh vertex positions b : #w list of vertex ids Returns uv : #w by 2 list of 2D positions on the unit circle for the vertices in b See also None Notes None Examples","title":"map_vertices_to_circle(v: array, bnd: array) -&gt; object"},{"location":"igl_docs/#massmatrixv-array-f-array-type-int-1-object","text":"Constructs the mass (area) matrix for a given mesh (V,F). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) type : one of the following types: -igl.MASSMATRIX_TYPE_BARYCENTRIC barycentric -igl.MASSMATRIX_TYPE_VORONOI voronoi-hybrid (default) -igl.MASSMATRIX_TYPE_FULL full (not implemented) Returns m : #v by #v mass matrix See also adjacency_matrix, cotmatrix, grad Notes Examples","title":"massmatrix(v: array, f: array, type: int = 1) -&gt; object"},{"location":"igl_docs/#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object","text":"MIN_QUAD_WITH_FIXED Minimize quadratic energy Z\u2019*A*Z + Z\u2019*B + C subject to linear constraints Aeq*Z = Beq Parameters A n by n matrix of quadratic coefficients B n by 1 column of linear coefficients Aeq m by n list of linear equality constraint coefficients Beq m by 1 list of linear equality constraint constant values use_lu_decomposition use lu rather than SVD Returns S n by (n + m) \u201csolve\u201d matrix, such that S*[B\u2019, Beq\u2019] is a solution See also Notes None Examples","title":"min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object"},{"location":"igl_docs/#orientable_patchesf-array-tupleobject-object","text":"Compute connected components of facets connected by manifold edges. Parameters f : n by dim array of face ids Returns A tuple (c, A) where c is an array of component ids (starting with 0) and A is a #f x #f adjacency matri See also components Notes Known bugs: This will detect a moebius strip as a single patch (manifold, non-orientable) and also non-manfiold, yet orientable patches. Examples","title":"orientable_patches(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#oriented_facetsf-array-object","text":"Determines all \u2018directed facets \u2018 of a given set of simplicial elements. For a manifold triangle mesh, this computes all half-edges. For a manifold tetrahedral mesh, this computes all half-faces. Parameters f : #F by simplex_size list of simplices Returns #E : by simplex_size-1 list of half-edges/facets See also edges Notes This is not the same as igl::edges because this includes every directed edge including repeats (meaning interior edges on a surface will show up once for each direction and non-manifold edges may appear more than once for each direction). Examples","title":"oriented_facets(f: array) -&gt; object"},{"location":"igl_docs/#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object","text":"Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices weight weighting type FN #F by 3 matrix of 3D face normals per face Returns N #2 by 3 matrix of mesh edge 3D normals per row E #E by 2 matrix of edge indices per row EMAP #E by 1 matrix of indices from all edges to E See also Notes None Examples","title":"per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#per_face_normalsv-array-f-array-z-array-object","text":"Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices Z 3 vector normal given to faces with degenerate normal. Returns N #F by 3 eigen Matrix of mesh face (triangle) 3D normals See also Notes None Examples Give degenerate faces (\u2153,\u2153,\u2153)^0.5","title":"per_face_normals(v: array, f: array, z: array) -&gt; object"},{"location":"igl_docs/#per_face_normalsvfvector3d111normalizedn","text":"","title":"per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);"},{"location":"igl_docs/#per_vertex_attribute_smoothingain-array-f-array-object","text":"Smooth vertex attributes using uniform Laplacian Parameters Ain #V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes) F #F by 3 eigne Matrix of face (triangle) indices Returns Aout #V by #A eigen Matrix of mesh vertex attributes See also Notes None Examples","title":"per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object"},{"location":"igl_docs/#per_vertex_normalsv-array-f-array-weighting-int-0-object","text":"Compute vertex normals via vertex position list, face list. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices weighting : Weighting type, one of the following -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM uniform influence -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA area weighted -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE angle weighted Returns n #v by 3 array of mesh vertex 3D normals See also per_face_normals, per_edge_normals Notes None Examples Mesh in (v, f) n = per_vertex_normals(v, f)","title":"per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object"},{"location":"igl_docs/#piecewise_constant_winding_numberf-array-bool","text":"PIECEWISE_CONSTANT_WINDING_NUMBER Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input to solid set operations. Assumes that (V,F) contains no -intersections (including degeneracies and co-incidences). If there are co-planar and co-incident vertex placements, a mesh could fail this combinatorial test but still induce a piecewise-constant winding number geometrically . For example, consider a hemisphere with boundary and then pinch the boundary \u201cshut\u201d along a line segment. The bullet-proof check is to first resolve all -intersections in (V,F) -> (SV,SF) (i.e. what the igl::copyleft::cgal::piecewise_constant_winding_number overload does). Parameters F #F by 3 list of triangle indices into some (abstract) list of vertices V Returns Returns true if the mesh combinatorially induces a piecewise constant winding number field. See also Notes None Examples","title":"piecewise_constant_winding_number(f: array) -&gt; bool"},{"location":"igl_docs/#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object","text":"Compute the principal curvature directions and magnitude of the given triangle mesh. Parameters v : vertex array of size #V by 3 f : face index array #F by 3 list of mesh faces (must be triangles) radius : controls the size of the neighbourhood used, 1 = average edge length (default: 5) use_k_ring : (default: True) Returns pd1 : #v by 3 maximal curvature direction for each vertex pd2 : #v by 3 minimal curvature direction for each vertex pv1 : #v by 1 maximal curvature value for each vertex pv2 : #v by 1 minimal curvature value for each vertex See also average_onto_faces, average_onto_vertices Notes This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo. The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010 Examples Mesh in (v, f) pd1, pd2, pv1, pv2 = principal_curvature(v, f)","title":"principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]"},{"location":"igl_docs/#procrustesx-array-y-array-tuplebool-bool-float-object-object","text":"Solve Procrustes problem in d dimensions. Given two point sets X,Y in R^d find best scale s, orthogonal R and translation t s.t. s*X*R + t - Y^2 is minimized. Parameters X #V by DIM first list of points Y #V by DIM second list of points includeScaling if scaling should be allowed includeReflections if R is allowed to be a reflection Returns scale scaling R orthogonal matrix t translation See also Notes None Examples MatrixXd X, Y; (containing 3d points as rows) double scale; MatrixXd R; VectorXd t; igl::procrustes(X,Y,true,false,scale,R,t); R *= scale; MatrixXd Xprime = (X * R).rowwise() + t.transpose();","title":"procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]"},{"location":"igl_docs/#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object","text":"Decimate (simplify) a triangle mesh in nD according to the paper \u201cSimplifying Surfaces with Color and Texture using Quadric Error Metrics\u201d by [Garland and Heckbert, 1987] (technically a followup to qslim). The mesh can have open boundaries but should be edge-manifold. Parameters V #V by dim list of vertex positions. Assumes that vertices w F #F by 3 list of triangle indices into V max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices See also Notes None Examples","title":"qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]"},{"location":"igl_docs/#quad_planarityv-array-f-array-object","text":"Compute planarity of the faces of a quad mesh. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 4 array of face (quad) indices Returns p : #f by 1 array of mesh face (quad) planarities See also None Notes None Examples","title":"quad_planarity(v: array, f: array) -&gt; object"},{"location":"igl_docs/#random_points_on_meshn-int-v-array-f-array-tupleobject-object","text":"RANDOM_POINTS_ON_MESH Randomly sample a mesh (V,F) n times. Parameters n number of samples V #V by dim list of mesh vertex positions F #F by 3 list of mesh triangle indices Returns B n by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) FI n list of indices into F See also Notes None Examples","title":"random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object","text":"Read a matrix from an ascii dmat file, a simple ascii matrix file type, defined as follows. The first line is always: <#columns> <#rows> Then the coefficients of the matrix are given separated by whitespace with columns running fastest. Parameters filename : string, path to .dmat file dtype : data-type of the returned matrix. Default is float64 . (returned faces always have type int32.) Returns w : array containing read-in coefficients See also read_triangle_mesh, read_off Notes None Examples w = read_dmat(\u201cmy_model.dmat\u201d)","title":"read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object"},{"location":"igl_docs/#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object","text":"Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .obj file dtype : data-type of the returned faces, texture coordinates and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 tc : array of texture coordinats #tc by 2 n : array of corner normals #n by 3 f : #f array of face indices into vertex positions ftc : #f array of face indices into vertex texture coordinates fn : #f array of face indices into vertex normals See also read_triangle_mesh, read_off Notes None Examples v, _, n, f, _, _ = read_obj(\u201cmy_model.obj\u201d)","title":"read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]"},{"location":"igl_docs/#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object","text":"Read a mesh from an ascii off file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .off file read_normals : bool, determines whether normals are read. If false, returns [] dtype : data-type of the returned vertices, faces, and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions n : list of vertex normals #v by 3 See also read_triangle_mesh, read_obj Notes None Examples v, f, n, c = read_off(\u201cmy_model.off\u201d)","title":"read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object","text":"Read mesh from an ascii file with automatic detection of file format. Supported: obj, off, stl, wrl, ply, mesh. Parameters filename : string, path to mesh file dtype : data-type of the returned vertices, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions See also read_obj, read_off, read_stl Notes None Examples v, f = read_triangle_mesh(\u201cmy_model.obj\u201d)","title":"read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]"},{"location":"igl_docs/#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object","text":"REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness tolerance (epsilon) Parameters V #V by dim list of vertex positions epsilon uniqueness tolerance (significant digit), can probably think of this as a tolerance on L1 distance Returns SV #SV by dim new list of vertex positions SVI #V by 1 list of indices so SV = V(SVI,:) SVJ #SV by 1 list of indices so V = SV(SVJ,:) Wrapper that also remaps given faces (F) \u2192 (SF) so that SF index SV See also Notes None Examples % Mesh in (V,F) [SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7); % remap faces SF = SVJ(F);","title":"remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]"},{"location":"igl_docs/#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object","text":"Merge the duplicate vertices from V, fixing the topology accordingly Parameters V,F mesh description epsilon minimal distance to consider two vertices identical Returns NV, NF new mesh without duplicate vertices See also Notes None Examples","title":"remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#remove_unreferencedv-array-f-array-tupleobject-object-object-object","text":"Remove unreferenced vertices from V, updating F accordingly Parameters V #V by dim list of mesh vertex positions F #F by ss list of simplices (Values of -1 are quitely skipped) Returns NV #NV by dim list of mesh vertex positions NF #NF by ss list of simplices IM #V by 1 list of indices such that: NF = IM(F) and NT = IM(T) and V(find(IM<=size(NV,1)),:) = NV J #RV by 1 list, such that RV = V(J,:) See also Notes None Examples","title":"remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]"},{"location":"igl_docs/#resolve_duplicated_facesf1-array-tupleobject-object","text":"Resolve duplicated faces according to the following rules per unique face:","title":"resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#if-the-number-of-positively-oriented-faces-equals-the-number-of","text":"negatively oriented faces, remove all duplicated faces at this triangle.","title":"If the number of positively oriented faces equals the number of"},{"location":"igl_docs/#if-the-number-of-positively-oriented-faces-equals-the-number-of_1","text":"negatively oriented faces plus 1, keeps one of the positively oriented face.","title":"If the number of positively oriented faces equals the number of"},{"location":"igl_docs/#if-the-number-of-positively-oriented-faces-equals-the-number-of_2","text":"negatively oriented faces minus 1, keeps one of the negatively oriented face.","title":"If the number of positively oriented faces equals the number of"},{"location":"igl_docs/#if-the-number-of-postively-oriented-faces-differ-with-the-number-of","text":"negativley oriented faces by more than 1, the mesh is not orientable. An exception will be thrown. Parameters F1 #F1 by 3 array of input faces. Returns F2 #F2 by 3 array of output faces without duplicated faces. J #F2 list of indices into F1. See also Notes None Examples","title":"If the number of postively oriented faces differ with the number of"},{"location":"igl_docs/#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object","text":"Compute shape diamater function per given point. In the parlence of the paper \u201cConsistent Mesh Partitioning and Skeletonisation using the Shape Diameter Function\u201d [Shapiro et al. 2008], this implementation uses a 180\u00b0 cone and a uniform average ( not a average weighted by inverse angles). Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of shape diamater function values between bounding box diagonal (perfect sphere) and 0 (perfect needle hook) See also Notes None Examples","title":"shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object"},{"location":"igl_docs/#sort_anglesm-array-object","text":"Sort angles in ascending order in a numerically robust way. Instead of computing angles using atan2(y, x), sort directly on (y, x). Parameters - M: m by n matrix of scalars. (n >= 2). Assuming the first column of M contains values for y, and the second column is x. Using the rest of the columns as tie-breaker. Returns R: an array of m indices. M.row(R[i]) contains the i-th smallest angle. See also Notes None. Examples","title":"sort_angles(m: array) -&gt; object"},{"location":"igl_docs/#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object","text":"Mesh the interior of a surface mesh (V,F) using tetgen. Parameters v : #v by 3 vertex position array f : #v array of polygon face indices into V (0-indexed) switches : string of tetgen options (See tetgen documentation) e.g. \u201cpq1.414a0.01\u201d tries to mesh the interior of a given surface with quality and area constraints. Will mesh the convex hull constrained to pass through V (ignores F) Returns tv #v by 3 vertex position array tt #t by 4 array of tet face indices tf #f by 3 array of triangle face indices See also None Notes Returns status: 0 success 1 tetgen threw exception 2 tetgen did not crash but could not create any tets (probably there are holes, duplicate faces etc.) -1 other error Examples","title":"tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]"},{"location":"igl_docs/#triangle_triangle_adjacencyf-array-tupleobject-object","text":"Constructs the triangle-triangle adjacency matrix for a given mesh (V,F). Parameters F #F by simplex_size list of mesh faces (must be triangles) Returns TT #F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i TTi #F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i See also Notes NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third [2,3]. this convention is DIFFERENT from cotmatrix_entries.h Examples","title":"triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object","text":"Triangulate the interior of a polygon using the triangle library. Parameters v : #v by 2 array of 2D vertex positions e : #e by 2 array of vertex ids forming unoriented edges of the boundary of the polygon h : #h by 2 coordinates of points contained inside holes of the polygon m : optional #v list of markers for input vertices flags : string of options pass to triangle (see triangle documentation) (default \u2018a0.005q\u2019) Returns v2 : #v2 by 2 coordinates of the vertives of the generated triangulation f2 : #f2 by 3 array of indices forming the faces of the generated triangulation m2 : (only if you passed in m) #v2 list of markers for output vertices See also Notes Examples v2, f2 = triangulate(v, e, h)","title":"triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]"},{"location":"igl_docs/#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object","text":"Find uniform sampling up to placing samples on mesh vertices Parameters Returns See also Notes None Examples","title":"uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object"},{"location":"igl_docs/#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object","text":"UNIFORMLY_SAMPLE_TWO_MANIFOLD Attempt to sample a mesh uniformly by furthest point relaxation as described in \u201cFast Automatic Skinning Transformations\u201d [Jacobson et al. 12] Section 3.3. Parameters W #W by dim positions of mesh in weight space F #F by 3 indices of triangles k number of samplse push factor by which corners should be pushed away Returns WS k by dim locations in weights space See also Notes None Examples","title":"uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object"},{"location":"igl_docs/#unprojectwin-array-model-array-proj-array-viewport-array-object","text":"Reimplementation of gluUnproject Parameters win #P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns scene #P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates See also Notes None Examples","title":"unproject(win: array, model: array, proj: array, viewport: array) -&gt; object"},{"location":"igl_docs/#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit","text":"Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position inside a given mesh. If the ray through the given screen location (x,y) hits the mesh more than twice then the 3D midpoint between the first two hits is return. If it hits once, then that point is return. If it does not hit the mesh then obj is not set. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns obj 3d unprojected mouse point in mesh hits vector of hits Returns number of hits See also Notes None Examples","title":"unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]"},{"location":"igl_docs/#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object","text":"Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position onto a given mesh, if the ray through the given screen location (x,y) hits the mesh. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns fid id of the first face hit bc barycentric coordinates of hit Returns true if there\u2019s a hit See also Notes None Examples","title":"unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]"},{"location":"igl_docs/#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object","text":"Construct a ray (source point + direction vector) given a screen space positions (e.g. mouse) and a model-view projection constellation. Parameters pos 2d screen-space position (x,y) model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns s source of ray (pos unprojected with z=0) dir direction of ray (d - s) where d is pos unprojected with z=1 See also Notes None Examples","title":"unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object","text":"Subdivide a mesh without moving vertices: loop subdivision but odd vertices stay put and even vertices are just edge midpoints Parameters V #V by dim mesh vertices F #F by 3 mesh triangles Returns NV new vertex positions, V is guaranteed to be at top NF new list of face indices See also Notes assumes (V,F) is edge-manifold. Examples","title":"upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]"},{"location":"igl_docs/#vector_area_matrixf-array-object","text":"Constructs the symmetric area matrix A, s.t. [V.col(0)\u2019 V.col(1)\u2019] * A * [V.col(0); V.col(1)] is the vector area of the mesh (V,F). Parameters f : #f by 3 array of mesh faces (must be triangles) Returns a : #vx2 by #vx2 area matrix See also None Notes None Examples","title":"vector_area_matrix(f: array) -&gt; object"},{"location":"igl_docs/#vertex_componentsf-array-object","text":"Compute connected components of the vertices of a mesh given the mesh\u2019 face indices. Parameters f : #f x dim array of face indices Returns An array of component ids (starting with 0) See also vertex_components_from_adjacency_matrix face_components_from_faces Notes Examples","title":"vertex_components(f: array) -&gt; object"},{"location":"igl_docs/#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object","text":"Compute connected components of a graph represented by a sparse adjacency matrix. Parameters a : n by n sparse adjacency matrix Returns A tuple (c, counts) where c is an array of component ids (starting with 0) and counts is a #components array of counts for each component See also vertex_components face_components Notes Examples","title":"vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]"},{"location":"igl_docs/#vertex_triangle_adjacencyf-array-n-int-tupleobject-object","text":"vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F) Parameters F #F by 3 list of triangle indices into some vertex list V n number of vertices, #V (e.g., F.maxCoeff()+1) Returns VF 3*#F list List of faces indice on each vertex, so that VF(NI(i)+j) = f, means that face f is the jth face (in no particular order) incident on vertex i. NI #V+1 list cumulative sum of vertex-triangle degrees with a preceeding zero. \u201cHow many faces\u201d have been seen before visiting this vertex and its incident faces. See also Notes None Examples","title":"vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#winding_numberv-array-f-array-o-array-object","text":"WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron described by points (vectors) V Parameters V n by 3 list of vertex positions F #F by 3 list of triangle indices, minimum index is 0 O no by 3 list of origin positions Returns S no by 1 list of winding numbers See also Notes None Examples","title":"winding_number(v: array, f: array, o: array) -&gt; object"},{"location":"igl_docs/#winding_number_for_pointv-array-f-array-p-array-float","text":"Compute winding number of a single point Parameters V n by dim list of vertex positions F #F by dim list of triangle indices, minimum index is 0 p single origin position Returns w winding number of this point See also Notes None Examples","title":"winding_number_for_point(v: array, f: array, p: array) -&gt; float"},{"location":"igl_docs/#write_objfilename-str-v-array-f-array-bool","text":"Write a mesh in an ascii obj file. Parameters filename : path to outputfile v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions Returns ret : bool if output was successful See also read_obj Notes None Examples Mesh in (v, f) success = write_obj(v, f)","title":"write_obj(filename: str, v: array, f: array) -&gt; bool"},{"location":"igl_docs/#write_offstr-str-v-array-f-array-c-array-bool","text":"Export geometry and colors-by-vertex Export a mesh from an ascii OFF file, filling in vertex positions. Only triangle meshes are supported Parameters str path to .off output file V #V by 3 mesh vertex positions F #F by 3 mesh indices into V C double matrix of rgb values per vertex #V by 3 Returns Returns true on success, false on errors See also Notes None Examples","title":"write_off(str: str, v: array, f: array, c: array) -&gt; bool"},{"location":"igl_docs/#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool","text":"write mesh to a file with automatic detection of file format. supported: obj, off, stl, wrl, ply, mesh). Parameters str path to file V eigen double matrix #V by 3 F eigen int matrix #F by 3 force_ascii=True force ascii format even if binary is available Returns Returns true iff success See also Notes Examples VERSION dev FILE /Users/teseo/data/igl/python/igl/pyigl.cpython-36m-darwin.so igl.adjacency_list = adjacency_list(\u2026) method of builtins.PyCapsule instance","title":"write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool"},{"location":"igl_docs/#adjacency_listf-array-handle_1","text":"Constructs the graph adjacency list of a given mesh (v, f) Parameters f : #f by dim array of fixed dimensional (e.g. triangle (#f by 3), tet (#f by 4), quad (#f by 4), etc\u2026) mesh faces Returns list of lists containing at index i the adjacent vertices of vertex i See also adjacency_matrix Notes Examples Mesh in (v, f) a = mesh_adjacency_list(f) igl.adjacency_list = adjacency_list(\u2026) method of builtins.PyCapsule instance","title":"adjacency_list(f: array) -&gt; handle"},{"location":"igl_docs/#adjacency_listf-array-handle_2","text":"Constructs the graph adjacency list of a given mesh (v, f) Parameters f : #f by dim array of fixed dimensional (e.g. triangle (#f by 3), tet (#f by 4), quad (#f by 4), etc\u2026) mesh faces Returns list of lists containing at index i the adjacent vertices of vertex i See also adjacency_matrix Notes Examples Mesh in (v, f) a = mesh_adjacency_list(f) igl.adjacency_matrix = adjacency_matrix(\u2026) method of builtins.PyCapsule instance","title":"adjacency_list(f: array) -&gt; handle"},{"location":"igl_docs/#adjacency_matrixf-array-object_1","text":"Constructs the graph adjacency matrix of a given mesh (v, f). Parameters f : #f by dim list of mesh simplices Returns a : max(f) by max(f) cotangent matrix, each row i corresponding to v(i, :) See also adjacency_list, edges, cotmatrix, diag Notes None Examples Mesh in (v, f) a = adjacency_matrix(f) Sum each row a_sum = np.sum(a, axis=1) Convert row sums into diagonal of sparse matrix a_diag = diag(a_sum) Build uniform laplacian u = a - a_diag igl.adjacency_matrix = adjacency_matrix(\u2026) method of builtins.PyCapsule instance","title":"adjacency_matrix(f: array) -&gt; object"},{"location":"igl_docs/#adjacency_matrixf-array-object_2","text":"Constructs the graph adjacency matrix of a given mesh (v, f). Parameters f : #f by dim list of mesh simplices Returns a : max(f) by max(f) cotangent matrix, each row i corresponding to v(i, :) See also adjacency_list, edges, cotmatrix, diag Notes None Examples Mesh in (v, f) a = adjacency_matrix(f) Sum each row a_sum = np.sum(a, axis=1) Convert row sums into diagonal of sparse matrix a_diag = diag(a_sum) Build uniform laplacian u = a - a_diag igl.ambient_occlusion = ambient_occlusion(\u2026) method of builtins.PyCapsule instance","title":"adjacency_matrix(f: array) -&gt; object"},{"location":"igl_docs/#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object_1","text":"Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of ambient occusion values between 1 (fully occluded) and 0 (not occluded) See also Notes None Examples igl.ambient_occlusion = ambient_occlusion(\u2026) method of builtins.PyCapsule instance","title":"ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object"},{"location":"igl_docs/#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object_2","text":"Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of ambient occusion values between 1 (fully occluded) and 0 (not occluded) See also Notes None Examples igl.arap_linear_block = arap_linear_block(\u2026) method of builtins.PyCapsule instance","title":"ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object"},{"location":"igl_docs/#arap_linear_blockv-array-f-array-d-int-energy-int-object_1","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block = arap_linear_block(\u2026) method of builtins.PyCapsule instance","title":"arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object"},{"location":"igl_docs/#arap_linear_blockv-array-f-array-d-int-energy-int-object_2","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_elements = arap_linear_block_elements(\u2026) method of builtins.PyCapsule instance","title":"arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object"},{"location":"igl_docs/#arap_linear_block_elementsv-array-f-array-d-int-object_1","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_elements = arap_linear_block_elements(\u2026) method of builtins.PyCapsule instance","title":"arap_linear_block_elements(v: array, f: array, d: int) -&gt; object"},{"location":"igl_docs/#arap_linear_block_elementsv-array-f-array-d-int-object_2","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_spokes = arap_linear_block_spokes(\u2026) method of builtins.PyCapsule instance","title":"arap_linear_block_elements(v: array, f: array, d: int) -&gt; object"},{"location":"igl_docs/#arap_linear_block_spokesv-array-f-array-d-int-object_1","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_spokes = arap_linear_block_spokes(\u2026) method of builtins.PyCapsule instance","title":"arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object"},{"location":"igl_docs/#arap_linear_block_spokesv-array-f-array-d-int-object_2","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_spokes_and_rims = arap_linear_block_spokes_and_rims(\u2026) method of builtins.PyCapsule instance","title":"arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object"},{"location":"igl_docs/#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object_1","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_linear_block_spokes_and_rims = arap_linear_block_spokes_and_rims(\u2026) method of builtins.PyCapsule instance","title":"arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object"},{"location":"igl_docs/#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object_2","text":"Constructs a block of the matrix which constructs the linear terms of a given arap energy. When treating rotations as knowns (arranged in a column), then this constructs Kd of K such that the linear portion of the energy is as a column: K * R = [Kx Z \u2026 Ky Z \u2026 Z Kx \u2026 Z Ky \u2026 \u2026 ] These blocks are also used to build the \u201ccovariance scatter matrices\u201d. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each. Parameters v : #v by dim list of initial domain positions f : #f by #simplex size list of triangle indices into V d : coordinate of linear constructor to build Returns by #v/#f block of the linear constructor matrix corresponding to coordinate d See also arap, arap_dof Notes Examples igl.arap_rhs = arap_rhs(\u2026) method of builtins.PyCapsule instance","title":"arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object"},{"location":"igl_docs/#arap_rhsv-array-f-array-d-int-energy-int-object_1","text":"Guild right-hand side constructor of global poisson solve for various ARAP energies Inputs: Outputs: K #V*dim by #(FV)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); Parameters v : #v by Vdim list of initial domain positions f : #f by 3 list of triangle indices into v d : dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2 energy : ARAPEnergyType enum value defining which energy is being used. See igl.ARAPEnergyType for valid options and explanations. Returns *d by #(fv)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); See also arap_linear_block, arap Notes Examples igl.arap_rhs = arap_rhs(\u2026) method of builtins.PyCapsule instance","title":"arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object"},{"location":"igl_docs/#arap_rhsv-array-f-array-d-int-energy-int-object_2","text":"Guild right-hand side constructor of global poisson solve for various ARAP energies Inputs: Outputs: K #V*dim by #(FV)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); Parameters v : #v by Vdim list of initial domain positions f : #f by 3 list of triangle indices into v d : dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2 energy : ARAPEnergyType enum value defining which energy is being used. See igl.ARAPEnergyType for valid options and explanations. Returns *d by #(fv)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1); See also arap_linear_block, arap Notes Examples igl.average_onto_vertices = average_onto_vertices(\u2026) method of builtins.PyCapsule instance","title":"arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object"},{"location":"igl_docs/#average_onto_verticesv-array-f-array-s-array-object_1","text":"Move a scalar field defined on faces to vertices by averaging Parameters v : #v by vdim array of mesh vertices f : #f by simplex_count array of simplex indices s : #f by dim scalar field defined on simplices Returns by dim scalar field defined on vertices See also average_onto_faces Notes Examples igl.average_onto_vertices = average_onto_vertices(\u2026) method of builtins.PyCapsule instance","title":"average_onto_vertices(v: array, f: array, s: array) -&gt; object"},{"location":"igl_docs/#average_onto_verticesv-array-f-array-s-array-object_2","text":"Move a scalar field defined on faces to vertices by averaging Parameters v : #v by vdim array of mesh vertices f : #f by simplex_count array of simplex indices s : #f by dim scalar field defined on simplices Returns by dim scalar field defined on vertices See also average_onto_faces Notes Examples igl.avg_edge_length = avg_edge_length(\u2026) method of builtins.PyCapsule instance","title":"average_onto_vertices(v: array, f: array, s: array) -&gt; object"},{"location":"igl_docs/#avg_edge_lengthv-array-f-array-float_1","text":"Compute the average edge length for the given triangle mesh. Parameters v : array_like #v by 3 vertex array f : f #f by simplex-size list of mesh faces (must be simplex) Returns l : average edge length See also adjacency_matrix Notes None Examples Mesh in (v, f) length = avg_edge_length(v, f) igl.avg_edge_length = avg_edge_length(\u2026) method of builtins.PyCapsule instance","title":"avg_edge_length(v: array, f: array) -&gt; float"},{"location":"igl_docs/#avg_edge_lengthv-array-f-array-float_2","text":"Compute the average edge length for the given triangle mesh. Parameters v : array_like #v by 3 vertex array f : f #f by simplex-size list of mesh faces (must be simplex) Returns l : average edge length See also adjacency_matrix Notes None Examples Mesh in (v, f) length = avg_edge_length(v, f) igl.barycenter = barycenter(\u2026) method of builtins.PyCapsule instance","title":"avg_edge_length(v: array, f: array) -&gt; float"},{"location":"igl_docs/#barycenterv-array-f-array-object_1","text":"Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V Returns A #f x dim matrix where each row is the barycenter of each simplex See also Notes None Examples igl.barycenter = barycenter(\u2026) method of builtins.PyCapsule instance","title":"barycenter(v: array, f: array) -&gt; object"},{"location":"igl_docs/#barycenterv-array-f-array-object_2","text":"Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V Returns A #f x dim matrix where each row is the barycenter of each simplex See also Notes None Examples igl.barycentric_coordinates_tet = barycentric_coordinates_tet(\u2026) method of builtins.PyCapsule instance","title":"barycenter(v: array, f: array) -&gt; object"},{"location":"igl_docs/#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object_1","text":"Compute barycentric coordinates in a tet corresponding to the Euclidean coordinates in p . The input arrays a , b , c and d are the vertices of each tet. I.e. one tet is a[i, :], b[i, :], c[i, :], d[:, i] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tet corners in 3d b : #P by 3 Tet corners in 3d c : #P by 3 Tet corners in 3d d : #P by 3 Tet corners in 3d Returns by 4 list of barycentric coordinates See also Notes Examples igl.barycentric_coordinates_tet = barycentric_coordinates_tet(\u2026) method of builtins.PyCapsule instance","title":"barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object"},{"location":"igl_docs/#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object_2","text":"Compute barycentric coordinates in a tet corresponding to the Euclidean coordinates in p . The input arrays a , b , c and d are the vertices of each tet. I.e. one tet is a[i, :], b[i, :], c[i, :], d[:, i] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tet corners in 3d b : #P by 3 Tet corners in 3d c : #P by 3 Tet corners in 3d d : #P by 3 Tet corners in 3d Returns by 4 list of barycentric coordinates See also Notes Examples igl.barycentric_coordinates_tri = barycentric_coordinates_tri(\u2026) method of builtins.PyCapsule instance","title":"barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object"},{"location":"igl_docs/#barycentric_coordinates_trip-array-a-array-b-array-c-array-object_1","text":"Compute barycentric coordinates in a triangle corresponding to the Euclidean coordinates in p . The input arrays a , b , and c are the vertices of each triangle. I.e. one triangle is a[i, :], b[i, :], c[i, :] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tri corners in 3d b : #P by 3 Tri corners in 3d c : #P by 3 Tri corners in 3d Returns by 3 list of barycentric coordinates See also Notes Examples igl.barycentric_coordinates_tri = barycentric_coordinates_tri(\u2026) method of builtins.PyCapsule instance","title":"barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object"},{"location":"igl_docs/#barycentric_coordinates_trip-array-a-array-b-array-c-array-object_2","text":"Compute barycentric coordinates in a triangle corresponding to the Euclidean coordinates in p . The input arrays a , b , and c are the vertices of each triangle. I.e. one triangle is a[i, :], b[i, :], c[i, :] . Parameters p : #P by 3 Query points in 3d a : #P by 3 Tri corners in 3d b : #P by 3 Tri corners in 3d c : #P by 3 Tri corners in 3d Returns by 3 list of barycentric coordinates See also Notes Examples igl.bfs = bfs(\u2026) method of builtins.PyCapsule instance","title":"barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object"},{"location":"igl_docs/#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object_1","text":"Construct an array indexing into a directed graph represented by an adjacency list using breadth first search. I.e. the output is an array of vertices in breadth-first order. Parameters A : #V list of adjacency lists or #V by #V adjacency matrix s : starting node (index into A) Returns A tuple, (d, p) where: d is a #V list of indices into rows of A in the order in which graph nodes are discovered p is a #V list of indices of A of predecsors where -1 indicates root/not discovered. I.e. p[i] is the index of the vertex v which preceded d[i] in the breadth first traversal. Note that together, (d, p) form a spanning tree of the input graph See also Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) A = igl.adjacency_matrix(V, F) d, p = igl.bfs(A, V[0]) igl.bfs = bfs(\u2026) method of builtins.PyCapsule instance","title":"bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object_2","text":"Construct an array indexing into a directed graph represented by an adjacency list using breadth first search. I.e. the output is an array of vertices in breadth-first order. Parameters A : #V list of adjacency lists or #V by #V adjacency matrix s : starting node (index into A) Returns A tuple, (d, p) where: d is a #V list of indices into rows of A in the order in which graph nodes are discovered p is a #V list of indices of A of predecsors where -1 indicates root/not discovered. I.e. p[i] is the index of the vertex v which preceded d[i] in the breadth first traversal. Note that together, (d, p) form a spanning tree of the input graph See also Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) A = igl.adjacency_matrix(V, F) d, p = igl.bfs(A, V[0]) igl.bfs_orient = bfs_orient(\u2026) method of builtins.PyCapsule instance","title":"bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bfs_orientf-array-tupleobject-object_1","text":"Consistently orient faces in orientable patches using BFS. Parameters f : #F by 3 list of faces Returns A tuple, (ff, c) where: ff is a #F by 3 list of faces which are consistently oriented with c is a #F array of connected component ids See also Notes Examples v, f, _ = igl.readOFF(\u201ctest.off) ff, c = igl.bfs_orient(f) igl.bfs_orient = bfs_orient(\u2026) method of builtins.PyCapsule instance","title":"bfs_orient(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bfs_orientf-array-tupleobject-object_2","text":"Consistently orient faces in orientable patches using BFS. Parameters f : #F by 3 list of faces Returns A tuple, (ff, c) where: ff is a #F by 3 list of faces which are consistently oriented with c is a #F array of connected component ids See also Notes Examples v, f, _ = igl.readOFF(\u201ctest.off) ff, c = igl.bfs_orient(f) igl.bone_parents = bone_parents(\u2026) method of builtins.PyCapsule instance","title":"bfs_orient(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bone_parentsbe-array-object_1","text":"BONE_PARENTS Recover \u201cparent\u201d bones from directed graph representation. Parameters BE #BE by 2 list of directed bone edges Returns P #BE by 1 list of parent indices into BE, -1 means root. See also Notes None Examples igl.bone_parents = bone_parents(\u2026) method of builtins.PyCapsule instance","title":"bone_parents(be: array) -&gt; object"},{"location":"igl_docs/#bone_parentsbe-array-object_2","text":"BONE_PARENTS Recover \u201cparent\u201d bones from directed graph representation. Parameters BE #BE by 2 list of directed bone edges Returns P #BE by 1 list of parent indices into BE, -1 means root. See also Notes None Examples igl.boundary_conditions = boundary_conditions(\u2026) method of builtins.PyCapsule instance","title":"bone_parents(be: array) -&gt; object"},{"location":"igl_docs/#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object_1","text":"Compute boundary conditions for automatic weights computation. This function expects that the given mesh (V,Ele) has sufficient samples (vertices) exactly at point handle locations and exactly along bone and cage edges. Parameters V #V by dim list of domain vertices Ele #Ele by simplex-size list of simplex indices C #C by dim list of handle positions P #P by 1 list of point handle indices into C BE #BE by 2 list of bone edge indices into C CE #CE by 2 list of cage edge indices into P Returns b #b list of boundary indices (indices into V of vertices which have known, fixed values) bc #b by #weights list of known/fixed values for boundary vertices (notice the #b != #weights in general because #b will include all the intermediary samples along each bone, etc.. The ordering of the weights corresponds to [P;BE] Returns false if boundary conditions are suspicious: P and BE are empty bc is empty some column of bc doesn\u2019t have a 0 (assuming bc has >1 columns) some column of bc doesn\u2019t have a 1 (assuming bc has >1 columns) See also Notes None Examples igl.boundary_conditions = boundary_conditions(\u2026) method of builtins.PyCapsule instance","title":"boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]"},{"location":"igl_docs/#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object_2","text":"Compute boundary conditions for automatic weights computation. This function expects that the given mesh (V,Ele) has sufficient samples (vertices) exactly at point handle locations and exactly along bone and cage edges. Parameters V #V by dim list of domain vertices Ele #Ele by simplex-size list of simplex indices C #C by dim list of handle positions P #P by 1 list of point handle indices into C BE #BE by 2 list of bone edge indices into C CE #CE by 2 list of cage edge indices into P Returns b #b list of boundary indices (indices into V of vertices which have known, fixed values) bc #b by #weights list of known/fixed values for boundary vertices (notice the #b != #weights in general because #b will include all the intermediary samples along each bone, etc.. The ordering of the weights corresponds to [P;BE] Returns false if boundary conditions are suspicious: P and BE are empty bc is empty some column of bc doesn\u2019t have a 0 (assuming bc has >1 columns) some column of bc doesn\u2019t have a 1 (assuming bc has >1 columns) See also Notes None Examples igl.boundary_facets = boundary_facets(\u2026) method of builtins.PyCapsule instance","title":"boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]"},{"location":"igl_docs/#boundary_facetst-array-object_1","text":"Determine boundary faces (edges) of tetrahedra (triangles). Parameters t : tetrahedron or triangle index list, m by 4/3, where m is the number of tetrahedra/triangles Returns f : list of boundary faces, n by 3/2, where n is the number of boundary faces/edges See also None Notes None Examples Mesh in (v, f) b = boundary_facets(f) igl.boundary_facets = boundary_facets(\u2026) method of builtins.PyCapsule instance","title":"boundary_facets(t: array) -&gt; object"},{"location":"igl_docs/#boundary_facetst-array-object_2","text":"Determine boundary faces (edges) of tetrahedra (triangles). Parameters t : tetrahedron or triangle index list, m by 4/3, where m is the number of tetrahedra/triangles Returns f : list of boundary faces, n by 3/2, where n is the number of boundary faces/edges See also None Notes None Examples Mesh in (v, f) b = boundary_facets(f) igl.boundary_loop = boundary_loop(\u2026) method of builtins.PyCapsule instance","title":"boundary_facets(t: array) -&gt; object"},{"location":"igl_docs/#boundary_loopf-array-object_1","text":"Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. Parameters f : #v by dim array of mesh faces Returns l : ordered list of boundary vertices of longest boundary loop See also Notes None Examples Mesh in (v, f) l = boundary_loop(f) igl.boundary_loop = boundary_loop(\u2026) method of builtins.PyCapsule instance","title":"boundary_loop(f: array) -&gt; object"},{"location":"igl_docs/#boundary_loopf-array-object_2","text":"Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. Parameters f : #v by dim array of mesh faces Returns l : ordered list of boundary vertices of longest boundary loop See also Notes None Examples Mesh in (v, f) l = boundary_loop(f) igl.bounding_box = bounding_box(\u2026) method of builtins.PyCapsule instance","title":"boundary_loop(f: array) -&gt; object"},{"location":"igl_docs/#bounding_boxargs-kwargs_1","text":"","title":"bounding_box(*args, **kwargs)"},{"location":"igl_docs/#bounding_boxv-array-tupleobject-object_1","text":"Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples","title":"bounding_box(v: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bounding_boxv-array-pad-float-tupleobject-object_1","text":"Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples igl.bounding_box = bounding_box(\u2026) method of builtins.PyCapsule instance","title":"bounding_box(v: array, pad: float) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bounding_boxargs-kwargs_2","text":"","title":"bounding_box(*args, **kwargs)"},{"location":"igl_docs/#bounding_boxv-array-tupleobject-object_2","text":"Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples","title":"bounding_box(v: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bounding_boxv-array-pad-float-tupleobject-object_2","text":"Build a triangle mesh of the bounding box of a given list of vertices Parameters V #V by dim list of rest domain positions Returns BV 2^dim by dim list of bounding box corners positions BF #BF by dim list of simplex facets See also Notes None Examples igl.bounding_box_diagonal = bounding_box_diagonal(\u2026) method of builtins.PyCapsule instance","title":"bounding_box(v: array, pad: float) -&gt; Tuple[object, object]"},{"location":"igl_docs/#bounding_box_diagonalv-array-float_1","text":"Compute the length of the diagonal of a given meshes axis-aligned bounding Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V Returns Returns length of bounding box diagonal See also Notes None Examples igl.bounding_box_diagonal = bounding_box_diagonal(\u2026) method of builtins.PyCapsule instance","title":"bounding_box_diagonal(v: array) -&gt; float"},{"location":"igl_docs/#bounding_box_diagonalv-array-float_2","text":"Compute the length of the diagonal of a given meshes axis-aligned bounding Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V Returns Returns length of bounding box diagonal See also Notes None Examples igl.centroid = centroid(\u2026) method of builtins.PyCapsule instance","title":"bounding_box_diagonal(v: array) -&gt; float"},{"location":"igl_docs/#centroidv-array-f-array-tupleobject_1","text":"Computes the centroid of a closed mesh using a surface integral. Parameters v : #v by dim array of rest domain positions f : #f by 3 array of triangle indices into v Returns c : dim array of centroid coordinates vol : total volume of solid See also None Notes None Examples Mesh in (v, f) c, vol = centroid(v, f) igl.centroid = centroid(\u2026) method of builtins.PyCapsule instance","title":"centroid(v: array, f: array) -&gt; Tuple[object]"},{"location":"igl_docs/#centroidv-array-f-array-tupleobject_2","text":"Computes the centroid of a closed mesh using a surface integral. Parameters v : #v by dim array of rest domain positions f : #f by 3 array of triangle indices into v Returns c : dim array of centroid coordinates vol : total volume of solid See also None Notes None Examples Mesh in (v, f) c, vol = centroid(v, f) igl.circulation = circulation(\u2026) method of builtins.PyCapsule instance","title":"centroid(v: array, f: array) -&gt; Tuple[object]"},{"location":"igl_docs/#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint_1","text":"Return list of faces around the end point of an edge. Assumes data-structures are built from an edge-manifold closed mesh. Parameters e index into E of edge to circulate ccw whether to continue in ccw direction of edge (circulate around","title":"circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]"},{"location":"igl_docs/#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique_1","text":"unique edge in E EF #E by 2 list of edge flaps, EF(e,0)=f means e=(i\u2192j) is the edge of","title":"EMAP #F*3 list of indices into E, mapping each directed edge to unique"},{"location":"igl_docs/#ej-i_1","text":"EI #E by 2 list of edge flap corners (see above). Returns Returns list of faces touched by circulation (in cyclically order). See also Notes None Examples igl.circulation = circulation(\u2026) method of builtins.PyCapsule instance","title":"e=(j-&gt;i)"},{"location":"igl_docs/#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint_2","text":"Return list of faces around the end point of an edge. Assumes data-structures are built from an edge-manifold closed mesh. Parameters e index into E of edge to circulate ccw whether to continue in ccw direction of edge (circulate around","title":"circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]"},{"location":"igl_docs/#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique_2","text":"unique edge in E EF #E by 2 list of edge flaps, EF(e,0)=f means e=(i\u2192j) is the edge of","title":"EMAP #F*3 list of indices into E, mapping each directed edge to unique"},{"location":"igl_docs/#ej-i_2","text":"EI #E by 2 list of edge flap corners (see above). Returns Returns list of faces touched by circulation (in cyclically order). See also Notes None Examples igl.circumradius = circumradius(\u2026) method of builtins.PyCapsule instance","title":"e=(j-&gt;i)"},{"location":"igl_docs/#circumradiusv-array-f-array-object_1","text":"Compute the circumradius of each triangle in a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of triangle indices into V Returns R #F list of circumradii See also Notes None Examples R = circumradius(V, F) igl.circumradius = circumradius(\u2026) method of builtins.PyCapsule instance","title":"circumradius(v: array, f: array) -&gt; object"},{"location":"igl_docs/#circumradiusv-array-f-array-object_2","text":"Compute the circumradius of each triangle in a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of triangle indices into V Returns R #F list of circumradii See also Notes None Examples R = circumradius(V, F) igl.collapse_small_triangles = collapse_small_triangles(\u2026) method of builtins.PyCapsule instance","title":"circumradius(v: array, f: array) -&gt; object"},{"location":"igl_docs/#collapse_small_trianglesv-array-f-array-eps-float-object_1","text":"Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the original faces and vertices of (V,F) except any small triangles have been removed via collapse. We are not following the rules in \u201cMesh Optimization\u201d [Hoppe et al] Section 4.2. But for our purposes we don\u2019t care about this criteria. Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V eps epsilon for smallest allowed area treated as fraction of squared bounding box diagonal Returns FF #FF by 3 list of triangle indices into V See also Notes None Examples igl.collapse_small_triangles = collapse_small_triangles(\u2026) method of builtins.PyCapsule instance","title":"collapse_small_triangles(v: array, f: array, eps: float) -&gt; object"},{"location":"igl_docs/#collapse_small_trianglesv-array-f-array-eps-float-object_2","text":"Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the original faces and vertices of (V,F) except any small triangles have been removed via collapse. We are not following the rules in \u201cMesh Optimization\u201d [Hoppe et al] Section 4.2. But for our purposes we don\u2019t care about this criteria. Parameters V #V by 3 list of vertex positions F #F by 3 list of triangle indices into V eps epsilon for smallest allowed area treated as fraction of squared bounding box diagonal Returns FF #FF by 3 list of triangle indices into V See also Notes None Examples igl.connect_boundary_to_infinity = connect_boundary_to_infinity(\u2026) method of builtins.PyCapsule instance","title":"collapse_small_triangles(v: array, f: array, eps: float) -&gt; object"},{"location":"igl_docs/#connect_boundary_to_infinityf-array-object_1","text":"Connect all boundary edges to a fictitious point at infinity. Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into [V;inf inf inf], original F are guaranteed to come first. If (V,F) was a manifold mesh, now it is closed with a possibly non-manifold vertex at infinity (but it will be edge-manifold). See also Notes None Examples igl.connect_boundary_to_infinity = connect_boundary_to_infinity(\u2026) method of builtins.PyCapsule instance","title":"connect_boundary_to_infinity(f: array) -&gt; object"},{"location":"igl_docs/#connect_boundary_to_infinityf-array-object_2","text":"Connect all boundary edges to a fictitious point at infinity. Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into [V;inf inf inf], original F are guaranteed to come first. If (V,F) was a manifold mesh, now it is closed with a possibly non-manifold vertex at infinity (but it will be edge-manifold). See also Notes None Examples igl.connect_boundary_to_infinity_face = connect_boundary_to_infinity_face(\u2026) method of builtins.PyCapsule instance","title":"connect_boundary_to_infinity(f: array) -&gt; object"},{"location":"igl_docs/#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object_1","text":"Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into VO See also Notes None Examples igl.connect_boundary_to_infinity_face = connect_boundary_to_infinity_face(\u2026) method of builtins.PyCapsule instance","title":"connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object_2","text":"Parameters F #F by 3 list of face indices into some V Returns FO #F+#O by 3 list of face indices into VO See also Notes None Examples igl.connect_boundary_to_infinity_index = connect_boundary_to_infinity_index(\u2026) method of builtins.PyCapsule instance","title":"connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#connect_boundary_to_infinity_indexf-array-inf_index-int-object_1","text":"Parameters inf_index index of point at infinity (usually V.rows() or F.maxCoeff()) Returns See also Notes None Examples igl.connect_boundary_to_infinity_index = connect_boundary_to_infinity_index(\u2026) method of builtins.PyCapsule instance","title":"connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object"},{"location":"igl_docs/#connect_boundary_to_infinity_indexf-array-inf_index-int-object_2","text":"Parameters inf_index index of point at infinity (usually V.rows() or F.maxCoeff()) Returns See also Notes None Examples igl.cotmatrix = cotmatrix(\u2026) method of builtins.PyCapsule instance","title":"connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object"},{"location":"igl_docs/#cotmatrixv-array-f-array-object_1","text":"Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (v, f). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) Returns l : #v by #v cotangent matrix, each row i corresponding to v(i, :) See also adjacency_matrix Notes This Laplacian uses the convention that diagonal entries are minus the sum of off-diagonal entries. The diagonal entries are therefore in general negative and the matrix is negative semi-definite (immediately, -L is positive semi-definite) Examples Mesh in (v, f) l = cotmatrix(v, f) igl.cotmatrix = cotmatrix(\u2026) method of builtins.PyCapsule instance","title":"cotmatrix(v: array, f: array) -&gt; object"},{"location":"igl_docs/#cotmatrixv-array-f-array-object_2","text":"Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (v, f). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) Returns l : #v by #v cotangent matrix, each row i corresponding to v(i, :) See also adjacency_matrix Notes This Laplacian uses the convention that diagonal entries are minus the sum of off-diagonal entries. The diagonal entries are therefore in general negative and the matrix is negative semi-definite (immediately, -L is positive semi-definite) Examples Mesh in (v, f) l = cotmatrix(v, f) igl.cotmatrix_entries = cotmatrix_entries(\u2026) method of builtins.PyCapsule instance","title":"cotmatrix(v: array, f: array) -&gt; object"},{"location":"igl_docs/#cotmatrix_entriesv-array-f-array-object_1","text":"COTMATRIX_ENTRIES compute the cotangents of each angle in mesh (V,F) Parameters V #V by dim list of rest domain positions F #F by {34} list of {triangletetrahedra} indices into V Returns C #F by 3 list of \u00bd*cotangents corresponding angles for triangles, columns correspond to edges [1,2],[2,0],[0,1] OR C #F by 6 list of \u2159*cotangents of dihedral angles*edge lengths for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2] See also Notes None Examples igl.cotmatrix_entries = cotmatrix_entries(\u2026) method of builtins.PyCapsule instance","title":"cotmatrix_entries(v: array, f: array) -&gt; object"},{"location":"igl_docs/#cotmatrix_entriesv-array-f-array-object_2","text":"COTMATRIX_ENTRIES compute the cotangents of each angle in mesh (V,F) Parameters V #V by dim list of rest domain positions F #F by {34} list of {triangletetrahedra} indices into V Returns C #F by 3 list of \u00bd*cotangents corresponding angles for triangles, columns correspond to edges [1,2],[2,0],[0,1] OR C #F by 6 list of \u2159*cotangents of dihedral angles*edge lengths for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2] See also Notes None Examples igl.crouzeix_raviart_cotmatrix = crouzeix_raviart_cotmatrix(\u2026) method of builtins.PyCapsule instance","title":"cotmatrix_entries(v: array, f: array) -&gt; object"},{"location":"igl_docs/#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object_1","text":"CROUZEIX_RAVIART_COTMATRIX Compute the Crouzeix-Raviart cotangent stiffness matrix. Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns L #E by #E edge/face-based diagonal cotangent matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also See also: crouzeix_raviart_massmatrix Notes None Examples See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] igl.crouzeix_raviart_cotmatrix = crouzeix_raviart_cotmatrix(\u2026) method of builtins.PyCapsule instance","title":"crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object_2","text":"CROUZEIX_RAVIART_COTMATRIX Compute the Crouzeix-Raviart cotangent stiffness matrix. Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns L #E by #E edge/face-based diagonal cotangent matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also See also: crouzeix_raviart_massmatrix Notes None Examples See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] igl.crouzeix_raviart_cotmatrix_known_e = crouzeix_raviart_cotmatrix_known_e(\u2026) method of builtins.PyCapsule instance","title":"crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object_1","text":"wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples igl.crouzeix_raviart_cotmatrix_known_e = crouzeix_raviart_cotmatrix_known_e(\u2026) method of builtins.PyCapsule instance","title":"crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object"},{"location":"igl_docs/#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object_2","text":"wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples igl.crouzeix_raviart_massmatrix = crouzeix_raviart_massmatrix(\u2026) method of builtins.PyCapsule instance","title":"crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object"},{"location":"igl_docs/#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object_1","text":"CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where","title":"crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#edge-e_1","text":"Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns M #E by #E edge/face-based diagonal mass matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also crouzeix_raviart_cotmatrix Notes See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] Examples igl.crouzeix_raviart_massmatrix = crouzeix_raviart_massmatrix(\u2026) method of builtins.PyCapsule instance","title":"edge e."},{"location":"igl_docs/#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object_2","text":"CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where","title":"crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#edge-e_2","text":"Parameters V #V by dim list of vertex positions F #F by \u00be list of triangle/tetrahedron indices Returns M #E by #E edge/face-based diagonal mass matrix E #E by \u2154 list of edges/faces EMAP #F*\u00be list of indices mapping allE to E See also crouzeix_raviart_cotmatrix Notes See for example \u201cDiscrete Quadratic Curvature Energies\u201d [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007] Examples igl.crouzeix_raviart_massmatrix_known_e = crouzeix_raviart_massmatrix_known_e(\u2026) method of builtins.PyCapsule instance","title":"edge e."},{"location":"igl_docs/#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object_1","text":"wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples igl.crouzeix_raviart_massmatrix_known_e = crouzeix_raviart_massmatrix_known_e(\u2026) method of builtins.PyCapsule instance","title":"crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object"},{"location":"igl_docs/#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object_2","text":"wrapper if E and EMAP are already computed (better match!) Parameters Returns See also Notes None Examples igl.cut_mesh = cut_mesh(\u2026) method of builtins.PyCapsule instance","title":"crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object"},{"location":"igl_docs/#cut_meshv-array-f-array-cuts-array-tupleobject-object_1","text":"Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V cuts : #F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) Returns A pair (vcut, fcut) where: vcut is a #v by 3 list of the vertex positions of the cut mesh. This matrix will be similar to the original vertices except some rows will be duplicated. fcut is a #f by 3 list of the faces of the cut mesh (must be triangles). This matrix will be similar to the original face matrix except some indices will be redirected to point to the newly duplicated vertices. See also Notes Examples igl.cut_mesh = cut_mesh(\u2026) method of builtins.PyCapsule instance","title":"cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#cut_meshv-array-f-array-cuts-array-tupleobject-object_2","text":"Compute the barycenter of every simplex Parameters v : #v x dim matrix of vertex coordinates f : #f x simplex_size matrix of indices of simplex corners into V cuts : #F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) Returns A pair (vcut, fcut) where: vcut is a #v by 3 list of the vertex positions of the cut mesh. This matrix will be similar to the original vertices except some rows will be duplicated. fcut is a #f by 3 list of the faces of the cut mesh (must be triangles). This matrix will be similar to the original face matrix except some indices will be redirected to point to the newly duplicated vertices. See also Notes Examples igl.cut_mesh_from_singularities = cut_mesh_from_singularities(\u2026) method of builtins.PyCapsule instance","title":"cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object_1","text":"Given a mesh (v,f) and the integer mismatch of a cross field per edge (mismatch), finds and returns the cut_graph connecting the singularities (seams) Parameters v : #v by 3 array of triangle vertices (each row is a vertex) f : #f by 3 array of triangle indices into v mismatch : #f by 3 array of per-corner integer mismatches Returns seams : #f by 3 array of per corner booleans that de**notes if an edge is a** seam or not See also cut_mesh Notes Examples igl.cut_mesh_from_singularities = cut_mesh_from_singularities(\u2026) method of builtins.PyCapsule instance","title":"cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object"},{"location":"igl_docs/#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object_2","text":"Given a mesh (v,f) and the integer mismatch of a cross field per edge (mismatch), finds and returns the cut_graph connecting the singularities (seams) Parameters v : #v by 3 array of triangle vertices (each row is a vertex) f : #f by 3 array of triangle indices into v mismatch : #f by 3 array of per-corner integer mismatches Returns seams : #f by 3 array of per corner booleans that de**notes if an edge is a** seam or not See also cut_mesh Notes Examples igl.cylinder = cylinder(\u2026) method of builtins.PyCapsule instance","title":"cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object"},{"location":"igl_docs/#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object_1","text":"Construct a triangle mesh of a cylinder (without caps) Parameters axis_devisions number of vertices around the cylinder height_devisions number of vertices up the cylinder Returns V #V by 3 list of mesh vertex positions F #F by 3 list of triangle indices into V See also Notes None Examples igl.cylinder = cylinder(\u2026) method of builtins.PyCapsule instance","title":"cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object_2","text":"Construct a triangle mesh of a cylinder (without caps) Parameters axis_devisions number of vertices around the cylinder height_devisions number of vertices up the cylinder Returns V #V by 3 list of mesh vertex positions F #F by 3 list of triangle indices into V See also Notes None Examples igl.decimate = decimate(\u2026) method of builtins.PyCapsule instance","title":"cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object_1","text":"Assumes (V,F) is a manifold mesh (possibly with boundary) Collapses edges until desired number of faces is achieved. This uses default edge cost and merged vertex placement functions {edge length, edge midpoint}. Parameters V #V by dim list of vertex positions F #F by 3 list of face indices into V. max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices Returns true if m was reached (otherwise #G > m) See also Notes None Examples igl.decimate = decimate(\u2026) method of builtins.PyCapsule instance","title":"decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]"},{"location":"igl_docs/#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object_2","text":"Assumes (V,F) is a manifold mesh (possibly with boundary) Collapses edges until desired number of faces is achieved. This uses default edge cost and merged vertex placement functions {edge length, edge midpoint}. Parameters V #V by dim list of vertex positions F #F by 3 list of face indices into V. max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices Returns true if m was reached (otherwise #G > m) See also Notes None Examples igl.dihedral_angles = dihedral_angles(\u2026) method of builtins.PyCapsule instance","title":"decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]"},{"location":"igl_docs/#dihedral_anglesv-array-t-array-tupleobject-object_1","text":"Compute dihedral angles for all tets of a given tet mesh (v, t). Parameters v : #v by dim list of vertex positions t : #v by 4 list of tet indices Returns theta : #t by 6 list of dihedral angles (in radians) cos_theta : #t by 6 list of cosine of dihedral angles (in radians) See also Notes None Examples TetMesh in (v, t) theta, cos_theta = dihedral_angles(v, t) igl.dihedral_angles = dihedral_angles(\u2026) method of builtins.PyCapsule instance","title":"dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#dihedral_anglesv-array-t-array-tupleobject-object_2","text":"Compute dihedral angles for all tets of a given tet mesh (v, t). Parameters v : #v by dim list of vertex positions t : #v by 4 list of tet indices Returns theta : #t by 6 list of dihedral angles (in radians) cos_theta : #t by 6 list of cosine of dihedral angles (in radians) See also Notes None Examples TetMesh in (v, t) theta, cos_theta = dihedral_angles(v, t) igl.dihedral_angles_intrinsic = dihedral_angles_intrinsic(\u2026) method of builtins.PyCapsule instance","title":"dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#dihedral_angles_intrinsicl-array-a-array-tupleobject-object_1","text":"See dihedral_angles for the documentation. igl.dihedral_angles_intrinsic = dihedral_angles_intrinsic(\u2026) method of builtins.PyCapsule instance","title":"dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#dihedral_angles_intrinsicl-array-a-array-tupleobject-object_2","text":"See dihedral_angles for the documentation. igl.directed_edge_parents = directed_edge_parents(\u2026) method of builtins.PyCapsule instance","title":"dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#directed_edge_parentse-array-object_1","text":"Recover \u201cparents\u201d (preceding edges) in a tree given just directed edges. Parameters e : #e by 2 list of directed edges Returns p : #e list of parent indices into e. (-1) means root See also Notes None Examples p = edges(e) igl.directed_edge_parents = directed_edge_parents(\u2026) method of builtins.PyCapsule instance","title":"directed_edge_parents(e: array) -&gt; object"},{"location":"igl_docs/#directed_edge_parentse-array-object_2","text":"Recover \u201cparents\u201d (preceding edges) in a tree given just directed edges. Parameters e : #e by 2 list of directed edges Returns p : #e list of parent indices into e. (-1) means root See also Notes None Examples p = edges(e) igl.doublearea = doublearea(\u2026) method of builtins.PyCapsule instance","title":"directed_edge_parents(e: array) -&gt; object"},{"location":"igl_docs/#doubleareav-array-f-array-object_1","text":"Computes twice the area for each input triangle[quad] Parameters v : #v by dim array of mesh vertex positions f : #f by simplex_size array of mesh faces (must be triangles or quads) Returns d_area : #f list of triangle[quad] double areas (SIGNED only for 2D input) See also None Notes Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal if you have 1million unreferenced vertices and 1 face Examples Mesh in (v, f) dbl_area = doublearea(v, f) igl.doublearea = doublearea(\u2026) method of builtins.PyCapsule instance","title":"doublearea(v: array, f: array) -&gt; object"},{"location":"igl_docs/#doubleareav-array-f-array-object_2","text":"Computes twice the area for each input triangle[quad] Parameters v : #v by dim array of mesh vertex positions f : #f by simplex_size array of mesh faces (must be triangles or quads) Returns d_area : #f list of triangle[quad] double areas (SIGNED only for 2D input) See also None Notes Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal if you have 1million unreferenced vertices and 1 face Examples Mesh in (v, f) dbl_area = doublearea(v, f) igl.ears = ears(\u2026) method of builtins.PyCapsule instance","title":"doublearea(v: array, f: array) -&gt; object"},{"location":"igl_docs/#earsf-array-tupleobject-object_1","text":"FIND_EARS Find all ears (faces with two boundary edges) in a given mesh Parameters F #F by 3 list of triangle mesh indices Returns ears #ears list of indices into F of ears ear_opp #ears list of indices indicating which edge is non-boundary (connecting to flops) See also Notes None Examples ears,ear_opp = find_ears(F) igl.ears = ears(\u2026) method of builtins.PyCapsule instance","title":"ears(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#earsf-array-tupleobject-object_2","text":"FIND_EARS Find all ears (faces with two boundary edges) in a given mesh Parameters F #F by 3 list of triangle mesh indices Returns ears #ears list of indices into F of ears ear_opp #ears list of indices indicating which edge is non-boundary (connecting to flops) See also Notes None Examples ears,ear_opp = find_ears(F) igl.edge_topology = edge_topology(\u2026) method of builtins.PyCapsule instance","title":"ears(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#edge_topologyv-array-f-array-tupleobject-object-object_1","text":"Initialize Edges and their topological relations (assumes an edge-manifold mesh) Parameters v : #v by dim, list of mesh vertex positions (unused) f : #f by 3, list of triangle indices into V Returns ev : #e by 2, list of edges described as pair of vertices. fe : #f by 3, list storing triangle-edge relation. ef : #e by w, list storing edge-triangle relation, uses -1 to indicate boundaries. See also Notes None Examples Mesh in (v, f) ev, fe, ef = edge_topology(v, f) igl.edge_topology = edge_topology(\u2026) method of builtins.PyCapsule instance","title":"edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#edge_topologyv-array-f-array-tupleobject-object-object_2","text":"Initialize Edges and their topological relations (assumes an edge-manifold mesh) Parameters v : #v by dim, list of mesh vertex positions (unused) f : #f by 3, list of triangle indices into V Returns ev : #e by 2, list of edges described as pair of vertices. fe : #f by 3, list storing triangle-edge relation. ef : #e by w, list storing edge-triangle relation, uses -1 to indicate boundaries. See also Notes None Examples Mesh in (v, f) ev, fe, ef = edge_topology(v, f) igl.edges = edges(\u2026) method of builtins.PyCapsule instance","title":"edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#edgesf-array-object_1","text":"Constructs a list of unique edges represented in a given mesh (v, f) Parameters f : #F by dim list of mesh faces (must be triangles or tets) Returns by 2 list of edges in no particular order See also adjacency_matrix Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) E = igl.edges(F) igl.edges = edges(\u2026) method of builtins.PyCapsule instance","title":"edges(f: array) -&gt; object"},{"location":"igl_docs/#edgesf-array-object_2","text":"Constructs a list of unique edges represented in a given mesh (v, f) Parameters f : #F by dim list of mesh faces (must be triangles or tets) Returns by 2 list of edges in no particular order See also adjacency_matrix Notes Examples V, F, _ = igl.readOFF(\u201ctest.off) E = igl.edges(F) igl.euler_characteristic = euler_characteristic(\u2026) method of builtins.PyCapsule instance","title":"edges(f: array) -&gt; object"},{"location":"igl_docs/#euler_characteristicf-array-int_1","text":"Computes the Euler characteristic of a given mesh (V,F) Parameters F #F by dim list of mesh faces (must be triangles) Returns Returns An int containing the Euler characteristic See also Notes None Examples igl.euler_characteristic = euler_characteristic(\u2026) method of builtins.PyCapsule instance","title":"euler_characteristic(f: array) -&gt; int"},{"location":"igl_docs/#euler_characteristicf-array-int_2","text":"Computes the Euler characteristic of a given mesh (V,F) Parameters F #F by dim list of mesh faces (must be triangles) Returns Returns An int containing the Euler characteristic See also Notes None Examples igl.euler_characteristic_complete = euler_characteristic_complete(\u2026) method of builtins.PyCapsule instance","title":"euler_characteristic(f: array) -&gt; int"},{"location":"igl_docs/#euler_characteristic_completev-array-f-array-int_1","text":"Parameters V #V by dim list of mesh vertex positions Returns See also Notes None Examples igl.euler_characteristic_complete = euler_characteristic_complete(\u2026) method of builtins.PyCapsule instance","title":"euler_characteristic_complete(v: array, f: array) -&gt; int"},{"location":"igl_docs/#euler_characteristic_completev-array-f-array-int_2","text":"Parameters V #V by dim list of mesh vertex positions Returns See also Notes None Examples igl.exact_geodesic = exact_geodesic(\u2026) method of builtins.PyCapsule instance","title":"euler_characteristic_complete(v: array, f: array) -&gt; int"},{"location":"igl_docs/#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object_1","text":"Exact geodesic algorithm for the calculation of geodesics on a triangular mesh. Parameters v : #v by 3 array of 3D vertex positions f : #f by 3 array of mesh faces vs : #vs by 1 array specifying indices of source vertices fs : #fs by 1 array specifying indices of source faces vt : #vt by 1 array specifying indices of target vertices ft : #ft by 1 array specifying indices of target faces Returns d : #vt+#ft by 1 array of geodesic distances of each target w.r.t. the nearest one in the source set See also Notes Specifying a face as target/source means its center. Implementation from https:code.google.com/archive/p/geodesic/ with the algorithm first described by Mitchell, Mount and Papadimitriou in 1987. Examples igl.exact_geodesic = exact_geodesic(\u2026) method of builtins.PyCapsule instance","title":"exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object"},{"location":"igl_docs/#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object_2","text":"Exact geodesic algorithm for the calculation of geodesics on a triangular mesh. Parameters v : #v by 3 array of 3D vertex positions f : #f by 3 array of mesh faces vs : #vs by 1 array specifying indices of source vertices fs : #fs by 1 array specifying indices of source faces vt : #vt by 1 array specifying indices of target vertices ft : #ft by 1 array specifying indices of target faces Returns d : #vt+#ft by 1 array of geodesic distances of each target w.r.t. the nearest one in the source set See also Notes Specifying a face as target/source means its center. Implementation from https:code.google.com/archive/p/geodesic/ with the algorithm first described by Mitchell, Mount and Papadimitriou in 1987. Examples igl.face_components = face_components(\u2026) method of builtins.PyCapsule instance","title":"exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object"},{"location":"igl_docs/#face_componentsf-array-object_1","text":"Compute connected components of facets based on edge-edge adjacency, Parameters f : #f x 3 array of triangle indices Returns An array, c, with shape (#f,), of component ids See also vertex_components vertex_components_from_adjacency_matrix Notes Examples igl.face_components = face_components(\u2026) method of builtins.PyCapsule instance","title":"face_components(f: array) -&gt; object"},{"location":"igl_docs/#face_componentsf-array-object_2","text":"Compute connected components of facets based on edge-edge adjacency, Parameters f : #f x 3 array of triangle indices Returns An array, c, with shape (#f,), of component ids See also vertex_components vertex_components_from_adjacency_matrix Notes Examples igl.fit_plane = fit_plane(\u2026) method of builtins.PyCapsule instance","title":"face_components(f: array) -&gt; object"},{"location":"igl_docs/#fit_planev-array-tupleobject-object_1","text":"This function fits a plane to a point cloud. Parameters V #Vx3 matrix. The 3D point cloud, one row for each vertex. Returns N 1x3 Vector. The normal of the fitted plane. C 1x3 Vector. A point that lies in the fitted plane. See also Notes From http:missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html Examples igl.fit_plane = fit_plane(\u2026) method of builtins.PyCapsule instance","title":"fit_plane(v: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#fit_planev-array-tupleobject-object_2","text":"This function fits a plane to a point cloud. Parameters V #Vx3 matrix. The 3D point cloud, one row for each vertex. Returns N 1x3 Vector. The normal of the fitted plane. C 1x3 Vector. A point that lies in the fitted plane. See also Notes From http:missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html Examples igl.flip_avoiding_line_search = flip_avoiding_line_search(\u2026) method of builtins.PyCapsule instance","title":"fit_plane(v: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object_1","text":"A bisection line search for a mesh based energy that avoids triangle flips as suggested in \u201cBijective Parameterization with Free Boundaries\u201d (Smith J. and Schaefer S., 2015). The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles). This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see igl::line_search). Supports both triangle and tet meshes. Parameters F #F by \u00be list of mesh faces or tets cur_v #V by dim list of variables dst_v #V by dim list of target vertices. This mesh may have flipped triangles energy A function to compute the mesh-based energy (return an energy that is bigger than 0)","title":"flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]"},{"location":"igl_docs/#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it_1","text":"Returns cur_v #V by dim list of variables at the new location Returns the energy at the new point See also Notes None Examples igl.flip_avoiding_line_search = flip_avoiding_line_search(\u2026) method of builtins.PyCapsule instance","title":"cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it."},{"location":"igl_docs/#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object_2","text":"A bisection line search for a mesh based energy that avoids triangle flips as suggested in \u201cBijective Parameterization with Free Boundaries\u201d (Smith J. and Schaefer S., 2015). The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles). This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see igl::line_search). Supports both triangle and tet meshes. Parameters F #F by \u00be list of mesh faces or tets cur_v #V by dim list of variables dst_v #V by dim list of target vertices. This mesh may have flipped triangles energy A function to compute the mesh-based energy (return an energy that is bigger than 0)","title":"flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]"},{"location":"igl_docs/#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it_2","text":"Returns cur_v #V by dim list of variables at the new location Returns the energy at the new point See also Notes None Examples igl.gaussian_curvature = gaussian_curvature(\u2026) method of builtins.PyCapsule instance","title":"cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it."},{"location":"igl_docs/#gaussian_curvaturev-array-f-array-object_1","text":"Compute discrete local integral gaussian curvature (angle deficit, without averaging by local area). Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices Returns k : #v by 1 array of discrete gaussian curvature values See also principal_curvature Notes None Examples Mesh in (v, f) k = gaussian_curvature(v, f) igl.gaussian_curvature = gaussian_curvature(\u2026) method of builtins.PyCapsule instance","title":"gaussian_curvature(v: array, f: array) -&gt; object"},{"location":"igl_docs/#gaussian_curvaturev-array-f-array-object_2","text":"Compute discrete local integral gaussian curvature (angle deficit, without averaging by local area). Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices Returns k : #v by 1 array of discrete gaussian curvature values See also principal_curvature Notes None Examples Mesh in (v, f) k = gaussian_curvature(v, f) igl.grad = grad(\u2026) method of builtins.PyCapsule instance","title":"gaussian_curvature(v: array, f: array) -&gt; object"},{"location":"igl_docs/#gradv-array-f-array-uniform-bool-false-object_1","text":"Compute the numerical gradient operator. Parameters v : #v by 3 list of mesh vertex positions f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices] uniform : boolean (default false). Use a uniform mesh instead of the vertices v Returns g : #faces * dim by #v gradient operator See also cotmatrix, massmatrix Notes Gradient of a scalar function defined on piecewise linear elements (mesh) is constant on each triangle [tetrahedron] i,j,k:","title":"grad(v: array, f: array, uniform: bool = False) -&gt; object"},{"location":"igl_docs/#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_1","text":"where Xi is the scalar value at vertex i, Vi is the 3D position of vertex i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of 90 degrees. Examples Mesh in (v, f) g = grad(v, f) igl.grad = grad(\u2026) method of builtins.PyCapsule instance","title":"grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A"},{"location":"igl_docs/#gradv-array-f-array-uniform-bool-false-object_2","text":"Compute the numerical gradient operator. Parameters v : #v by 3 list of mesh vertex positions f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices] uniform : boolean (default false). Use a uniform mesh instead of the vertices v Returns g : #faces * dim by #v gradient operator See also cotmatrix, massmatrix Notes Gradient of a scalar function defined on piecewise linear elements (mesh) is constant on each triangle [tetrahedron] i,j,k:","title":"grad(v: array, f: array, uniform: bool = False) -&gt; object"},{"location":"igl_docs/#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_2","text":"where Xi is the scalar value at vertex i, Vi is the 3D position of vertex i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of 90 degrees. Examples Mesh in (v, f) g = grad(v, f) igl.grad = grad(\u2026) method of builtins.PyCapsule instance","title":"grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A"},{"location":"igl_docs/#gradv-array-f-array-uniform-bool-false-object_3","text":"Compute the numerical gradient operator. Parameters v : #v by 3 list of mesh vertex positions f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices] uniform : boolean (default false). Use a uniform mesh instead of the vertices v Returns g : #faces * dim by #v gradient operator See also cotmatrix, massmatrix Notes Gradient of a scalar function defined on piecewise linear elements (mesh) is constant on each triangle [tetrahedron] i,j,k:","title":"grad(v: array, f: array, uniform: bool = False) -&gt; object"},{"location":"igl_docs/#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_3","text":"where Xi is the scalar value at vertex i, Vi is the 3D position of vertex i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of 90 degrees. Examples Mesh in (v, f) g = grad(v, f) igl.harmonic_integrated_with_laplacian = harmonic_integrated_with_laplacian(\u2026) method of builtins.PyCapsule instance","title":"grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A"},{"location":"igl_docs/#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object_1","text":"Build the discrete k-harmonic operator (computing integrated quantities). That is, if the k-harmonic PDE is Q x = 0, then this minimizes x\u2019 Q x Parameters L #V by #V discrete (integrated) Laplacian M #V by #V mass matrix k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns Q #V by #V discrete (integrated) k-Laplacian See also Notes Examples igl.harmonic_integrated_with_laplacian = harmonic_integrated_with_laplacian(\u2026) method of builtins.PyCapsule instance","title":"harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object"},{"location":"igl_docs/#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object_2","text":"Build the discrete k-harmonic operator (computing integrated quantities). That is, if the k-harmonic PDE is Q x = 0, then this minimizes x\u2019 Q x Parameters L #V by #V discrete (integrated) Laplacian M #V by #V mass matrix k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns Q #V by #V discrete (integrated) k-Laplacian See also Notes Examples igl.harmonic_uniform_laplacian = harmonic_uniform_laplacian(\u2026) method of builtins.PyCapsule instance","title":"harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object"},{"location":"igl_docs/#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object_1","text":"Compute harmonic map using uniform laplacian operator Parameters F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples igl.harmonic_uniform_laplacian = harmonic_uniform_laplacian(\u2026) method of builtins.PyCapsule instance","title":"harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object"},{"location":"igl_docs/#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object_2","text":"Compute harmonic map using uniform laplacian operator Parameters F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples igl.harmonic_weights = harmonic_weights(\u2026) method of builtins.PyCapsule instance","title":"harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object"},{"location":"igl_docs/#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object_1","text":"Compute k-harmonic weight functions \u201ccoordinates\u201d. Parameters V #V by dim vertex positions F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples igl.harmonic_weights = harmonic_weights(\u2026) method of builtins.PyCapsule instance","title":"harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object"},{"location":"igl_docs/#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object_2","text":"Compute k-harmonic weight functions \u201ccoordinates\u201d. Parameters V #V by dim vertex positions F #F by simplex-size list of element indices b #b boundary indices into V bc #b by #W list of boundary values k power of harmonic operation (1: harmonic, 2: biharmonic, etc) Returns W #V by #W list of weights See also Notes Examples igl.hausdorff = hausdorff(\u2026) method of builtins.PyCapsule instance","title":"harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object"},{"location":"igl_docs/#hausdorffva-array-fa-array-vb-array-fb-array-float_1","text":"HAUSDORFF compute the Hausdorff distance between mesh (VA,FA) and mesh (VB,FB). This is the","title":"hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float"},{"location":"igl_docs/#aa-bb-bb-aa_1","text":"Parameters VA #VA by 3 list of vertex positions FA #FA by 3 list of face indices into VA VB #VB by 3 list of vertex positions FB #FB by 3 list of face indices into VB Returns d hausdorff distance pair 2 by 3 list of \u201cdeterminer points\u201d so that pair(1,:) is from A and pair(2,:) is from B See also Notes Known issue: This is only computing max(min(va,B),min(vb,A)). This is better than max(min(va,Vb),min(vb,Va)). This (at least) is missing \u201cedge-edge\u201d cases like the distance between the two different triangulations of a non-planar quad in 3D. Even simpler, consider the Hausdorff distance between the non-convex, block letter V polygon (with 7 vertices) in 2D and its convex hull. The Hausdorff distance is defined by the midpoint in the middle of the segment across the concavity and some non-vertex point on the edge of the V. Examples igl.hausdorff = hausdorff(\u2026) method of builtins.PyCapsule instance","title":"a\u2208A b\u2208B          b\u2208B a\u2208A"},{"location":"igl_docs/#hausdorffva-array-fa-array-vb-array-fb-array-float_2","text":"HAUSDORFF compute the Hausdorff distance between mesh (VA,FA) and mesh (VB,FB). This is the","title":"hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float"},{"location":"igl_docs/#aa-bb-bb-aa_2","text":"Parameters VA #VA by 3 list of vertex positions FA #FA by 3 list of face indices into VA VB #VB by 3 list of vertex positions FB #FB by 3 list of face indices into VB Returns d hausdorff distance pair 2 by 3 list of \u201cdeterminer points\u201d so that pair(1,:) is from A and pair(2,:) is from B See also Notes Known issue: This is only computing max(min(va,B),min(vb,A)). This is better than max(min(va,Vb),min(vb,Va)). This (at least) is missing \u201cedge-edge\u201d cases like the distance between the two different triangulations of a non-planar quad in 3D. Even simpler, consider the Hausdorff distance between the non-convex, block letter V polygon (with 7 vertices) in 2D and its convex hull. The Hausdorff distance is defined by the midpoint in the middle of the segment across the concavity and some non-vertex point on the edge of the V. Examples igl.internal_angles = internal_angles(\u2026) method of builtins.PyCapsule instance","title":"a\u2208A b\u2208B          b\u2208B a\u2208A"},{"location":"igl_docs/#internal_anglesv-array-f-array-object_1","text":"Computes internal angles for a triangle mesh. Parameters v : #v by dim array of mesh vertex nD positions f : #f by poly-size array of face (triangle) indices Returns k : #f by poly-size array of internal angles. For triangles, columns correspond to edges [1,2],[2,0],[0,1]. See also None Notes If poly-size \u2260 3 then dim must equal 3. Examples igl.internal_angles = internal_angles(\u2026) method of builtins.PyCapsule instance","title":"internal_angles(v: array, f: array) -&gt; object"},{"location":"igl_docs/#internal_anglesv-array-f-array-object_2","text":"Computes internal angles for a triangle mesh. Parameters v : #v by dim array of mesh vertex nD positions f : #f by poly-size array of face (triangle) indices Returns k : #f by poly-size array of internal angles. For triangles, columns correspond to edges [1,2],[2,0],[0,1]. See also None Notes If poly-size \u2260 3 then dim must equal 3. Examples igl.is_edge_manifold = is_edge_manifold(\u2026) method of builtins.PyCapsule instance","title":"internal_angles(v: array, f: array) -&gt; object"},{"location":"igl_docs/#is_edge_manifoldf-array-bool_1","text":"See is_edge_manifold for the documentation. igl.is_edge_manifold = is_edge_manifold(\u2026) method of builtins.PyCapsule instance","title":"is_edge_manifold(f: array) -&gt; bool"},{"location":"igl_docs/#is_edge_manifoldf-array-bool_2","text":"See is_edge_manifold for the documentation. igl.is_irregular_vertex = is_irregular_vertex(\u2026) method of builtins.PyCapsule instance","title":"is_edge_manifold(f: array) -&gt; bool"},{"location":"igl_docs/#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool_1","text":"Determine if a vertex is irregular, i.e. it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored. Parameters v : #v by dim array of vertex positions f : #f by 3[4] array of triangle[quads] indices Returns s : #v list of bools revealing whether vertices are singular See also None Notes None Examples igl.is_irregular_vertex = is_irregular_vertex(\u2026) method of builtins.PyCapsule instance","title":"is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;"},{"location":"igl_docs/#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool_2","text":"Determine if a vertex is irregular, i.e. it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored. Parameters v : #v by dim array of vertex positions f : #f by 3[4] array of triangle[quads] indices Returns s : #v list of bools revealing whether vertices are singular See also None Notes None Examples igl.isolines = isolines(\u2026) method of builtins.PyCapsule instance","title":"is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;"},{"location":"igl_docs/#isolinesv-array-f-array-z-array-n-int-tupleobject-object_1","text":"Constructs isolines for a function z given on a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of mesh faces (must be triangles) z #V by 1 list of function values evaluated at vertices n the number of desired isolines Returns isoV #isoV by dim list of isoline vertex positions isoE #isoE by 2 list of isoline edge positions See also Notes None Examples igl.isolines = isolines(\u2026) method of builtins.PyCapsule instance","title":"isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#isolinesv-array-f-array-z-array-n-int-tupleobject-object_2","text":"Constructs isolines for a function z given on a mesh (V,F) Parameters V #V by dim list of mesh vertex positions F #F by 3 list of mesh faces (must be triangles) z #V by 1 list of function values evaluated at vertices n the number of desired isolines Returns isoV #isoV by dim list of isoline vertex positions isoE #isoE by 2 list of isoline edge positions See also Notes None Examples igl.lscm = lscm(\u2026) method of builtins.PyCapsule instance","title":"isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#lscmv-array-f-array-b-array-bc-array-tuplebool-object_1","text":"Compute a Least-squares conformal map parametrization. Parameters v : #v by 3 array of mesh vertex positions f : #f by 3 array of mesh faces (must be triangles) b : #b boundary indices into v bc : #b by 3 list of boundary values Returns uv #v by 2 list of 2D mesh vertex positions in UV space See also None Notes Derived in \u201cIntrinsic Parameterizations of Surface Meshes\u201d [Desbrun et al. 2002] and \u201cLeast Squares Conformal Maps for Automatic Texture Atlas Generation\u201d [L\u00e9vy et al. 2002]), though this implementation follows the derivation in: \u201cSpectral Conformal Parameterization\u201d [Mullen et al. 2008] (note, this does not implement the Eigen-decomposition based method in [Mullen et al. 2008], which is not equivalent. Input should be a manifold mesh (also no unreferenced vertices) and \u201cboundary\u201d (fixed vertices) b should contain at least two vertices per connected component. Returns true only on solver success. Examples igl.lscm = lscm(\u2026) method of builtins.PyCapsule instance","title":"lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]"},{"location":"igl_docs/#lscmv-array-f-array-b-array-bc-array-tuplebool-object_2","text":"Compute a Least-squares conformal map parametrization. Parameters v : #v by 3 array of mesh vertex positions f : #f by 3 array of mesh faces (must be triangles) b : #b boundary indices into v bc : #b by 3 list of boundary values Returns uv #v by 2 list of 2D mesh vertex positions in UV space See also None Notes Derived in \u201cIntrinsic Parameterizations of Surface Meshes\u201d [Desbrun et al. 2002] and \u201cLeast Squares Conformal Maps for Automatic Texture Atlas Generation\u201d [L\u00e9vy et al. 2002]), though this implementation follows the derivation in: \u201cSpectral Conformal Parameterization\u201d [Mullen et al. 2008] (note, this does not implement the Eigen-decomposition based method in [Mullen et al. 2008], which is not equivalent. Input should be a manifold mesh (also no unreferenced vertices) and \u201cboundary\u201d (fixed vertices) b should contain at least two vertices per connected component. Returns true only on solver success. Examples igl.massmatrix = massmatrix(\u2026) method of builtins.PyCapsule instance","title":"lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]"},{"location":"igl_docs/#massmatrixv-array-f-array-type-int-1-object_1","text":"Constructs the mass (area) matrix for a given mesh (V,F). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) type : one of the following types: -igl.MASSMATRIX_TYPE_BARYCENTRIC barycentric -igl.MASSMATRIX_TYPE_VORONOI voronoi-hybrid (default) -igl.MASSMATRIX_TYPE_FULL full (not implemented) Returns m : #v by #v mass matrix See also adjacency_matrix, cotmatrix, grad Notes Examples igl.massmatrix = massmatrix(\u2026) method of builtins.PyCapsule instance","title":"massmatrix(v: array, f: array, type: int = 1) -&gt; object"},{"location":"igl_docs/#massmatrixv-array-f-array-type-int-1-object_2","text":"Constructs the mass (area) matrix for a given mesh (V,F). Parameters v : #v by dim list of mesh vertex positions f : #f by simplex_size list of mesh faces (must be triangles) type : one of the following types: -igl.MASSMATRIX_TYPE_BARYCENTRIC barycentric -igl.MASSMATRIX_TYPE_VORONOI voronoi-hybrid (default) -igl.MASSMATRIX_TYPE_FULL full (not implemented) Returns m : #v by #v mass matrix See also adjacency_matrix, cotmatrix, grad Notes Examples igl.min_quad_dense_precompute = min_quad_dense_precompute(\u2026) method of builtins.PyCapsule instance","title":"massmatrix(v: array, f: array, type: int = 1) -&gt; object"},{"location":"igl_docs/#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object_1","text":"MIN_QUAD_WITH_FIXED Minimize quadratic energy Z\u2019*A*Z + Z\u2019*B + C subject to linear constraints Aeq*Z = Beq Parameters A n by n matrix of quadratic coefficients B n by 1 column of linear coefficients Aeq m by n list of linear equality constraint coefficients Beq m by 1 list of linear equality constraint constant values use_lu_decomposition use lu rather than SVD Returns S n by (n + m) \u201csolve\u201d matrix, such that S*[B\u2019, Beq\u2019] is a solution See also Notes None Examples igl.min_quad_dense_precompute = min_quad_dense_precompute(\u2026) method of builtins.PyCapsule instance","title":"min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object"},{"location":"igl_docs/#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object_2","text":"MIN_QUAD_WITH_FIXED Minimize quadratic energy Z\u2019*A*Z + Z\u2019*B + C subject to linear constraints Aeq*Z = Beq Parameters A n by n matrix of quadratic coefficients B n by 1 column of linear coefficients Aeq m by n list of linear equality constraint coefficients Beq m by 1 list of linear equality constraint constant values use_lu_decomposition use lu rather than SVD Returns S n by (n + m) \u201csolve\u201d matrix, such that S*[B\u2019, Beq\u2019] is a solution See also Notes None Examples igl.orientable_patches = orientable_patches(\u2026) method of builtins.PyCapsule instance","title":"min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object"},{"location":"igl_docs/#orientable_patchesf-array-tupleobject-object_1","text":"Compute connected components of facets connected by manifold edges. Parameters f : n by dim array of face ids Returns A tuple (c, A) where c is an array of component ids (starting with 0) and A is a #f x #f adjacency matri See also components Notes Known bugs: This will detect a moebius strip as a single patch (manifold, non-orientable) and also non-manfiold, yet orientable patches. Examples igl.orientable_patches = orientable_patches(\u2026) method of builtins.PyCapsule instance","title":"orientable_patches(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#orientable_patchesf-array-tupleobject-object_2","text":"Compute connected components of facets connected by manifold edges. Parameters f : n by dim array of face ids Returns A tuple (c, A) where c is an array of component ids (starting with 0) and A is a #f x #f adjacency matri See also components Notes Known bugs: This will detect a moebius strip as a single patch (manifold, non-orientable) and also non-manfiold, yet orientable patches. Examples igl.oriented_facets = oriented_facets(\u2026) method of builtins.PyCapsule instance","title":"orientable_patches(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#oriented_facetsf-array-object_1","text":"Determines all \u2018directed facets \u2018 of a given set of simplicial elements. For a manifold triangle mesh, this computes all half-edges. For a manifold tetrahedral mesh, this computes all half-faces. Parameters f : #F by simplex_size list of simplices Returns : by simplex_size-1 list of half-edges/facets See also edges Notes This is not the same as igl::edges because this includes every directed edge including repeats (meaning interior edges on a surface will show up once for each direction and non-manifold edges may appear more than once for each direction). Examples igl.oriented_facets = oriented_facets(\u2026) method of builtins.PyCapsule instance","title":"oriented_facets(f: array) -&gt; object"},{"location":"igl_docs/#oriented_facetsf-array-object_2","text":"Determines all \u2018directed facets \u2018 of a given set of simplicial elements. For a manifold triangle mesh, this computes all half-edges. For a manifold tetrahedral mesh, this computes all half-faces. Parameters f : #F by simplex_size list of simplices Returns : by simplex_size-1 list of half-edges/facets See also edges Notes This is not the same as igl::edges because this includes every directed edge including repeats (meaning interior edges on a surface will show up once for each direction and non-manifold edges may appear more than once for each direction). Examples igl.per_edge_normals = per_edge_normals(\u2026) method of builtins.PyCapsule instance","title":"oriented_facets(f: array) -&gt; object"},{"location":"igl_docs/#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object_1","text":"Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices weight weighting type FN #F by 3 matrix of 3D face normals per face Returns N #2 by 3 matrix of mesh edge 3D normals per row E #E by 2 matrix of edge indices per row EMAP #E by 1 matrix of indices from all edges to E See also Notes None Examples igl.per_edge_normals = per_edge_normals(\u2026) method of builtins.PyCapsule instance","title":"per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object_2","text":"Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices weight weighting type FN #F by 3 matrix of 3D face normals per face Returns N #2 by 3 matrix of mesh edge 3D normals per row E #E by 2 matrix of edge indices per row EMAP #E by 1 matrix of indices from all edges to E See also Notes None Examples igl.per_face_normals = per_face_normals(\u2026) method of builtins.PyCapsule instance","title":"per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#per_face_normalsv-array-f-array-z-array-object_1","text":"Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices Z 3 vector normal given to faces with degenerate normal. Returns N #F by 3 eigen Matrix of mesh face (triangle) 3D normals See also Notes None Examples Give degenerate faces (\u2153,\u2153,\u2153)^0.5","title":"per_face_normals(v: array, f: array, z: array) -&gt; object"},{"location":"igl_docs/#per_face_normalsvfvector3d111normalizedn_1","text":"igl.per_face_normals = per_face_normals(\u2026) method of builtins.PyCapsule instance","title":"per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);"},{"location":"igl_docs/#per_face_normalsv-array-f-array-z-array-object_2","text":"Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices Z 3 vector normal given to faces with degenerate normal. Returns N #F by 3 eigen Matrix of mesh face (triangle) 3D normals See also Notes None Examples Give degenerate faces (\u2153,\u2153,\u2153)^0.5","title":"per_face_normals(v: array, f: array, z: array) -&gt; object"},{"location":"igl_docs/#per_face_normalsvfvector3d111normalizedn_2","text":"igl.per_face_normals = per_face_normals(\u2026) method of builtins.PyCapsule instance","title":"per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);"},{"location":"igl_docs/#per_face_normalsv-array-f-array-z-array-object_3","text":"Compute face normals via vertex position list, face list Parameters V #V by 3 eigen Matrix of mesh vertex 3D positions F #F by 3 eigen Matrix of face (triangle) indices Z 3 vector normal given to faces with degenerate normal. Returns N #F by 3 eigen Matrix of mesh face (triangle) 3D normals See also Notes None Examples Give degenerate faces (\u2153,\u2153,\u2153)^0.5","title":"per_face_normals(v: array, f: array, z: array) -&gt; object"},{"location":"igl_docs/#per_face_normalsvfvector3d111normalizedn_3","text":"igl.per_vertex_attribute_smoothing = per_vertex_attribute_smoothing(\u2026) method of builtins.PyCapsule instance","title":"per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);"},{"location":"igl_docs/#per_vertex_attribute_smoothingain-array-f-array-object_1","text":"Smooth vertex attributes using uniform Laplacian Parameters Ain #V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes) F #F by 3 eigne Matrix of face (triangle) indices Returns Aout #V by #A eigen Matrix of mesh vertex attributes See also Notes None Examples igl.per_vertex_attribute_smoothing = per_vertex_attribute_smoothing(\u2026) method of builtins.PyCapsule instance","title":"per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object"},{"location":"igl_docs/#per_vertex_attribute_smoothingain-array-f-array-object_2","text":"Smooth vertex attributes using uniform Laplacian Parameters Ain #V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes) F #F by 3 eigne Matrix of face (triangle) indices Returns Aout #V by #A eigen Matrix of mesh vertex attributes See also Notes None Examples igl.per_vertex_normals = per_vertex_normals(\u2026) method of builtins.PyCapsule instance","title":"per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object"},{"location":"igl_docs/#per_vertex_normalsv-array-f-array-weighting-int-0-object_1","text":"Compute vertex normals via vertex position list, face list. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices weighting : Weighting type, one of the following -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM uniform influence -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA area weighted -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE angle weighted Returns n #v by 3 array of mesh vertex 3D normals See also per_face_normals, per_edge_normals Notes None Examples Mesh in (v, f) n = per_vertex_normals(v, f) igl.per_vertex_normals = per_vertex_normals(\u2026) method of builtins.PyCapsule instance","title":"per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object"},{"location":"igl_docs/#per_vertex_normalsv-array-f-array-weighting-int-0-object_2","text":"Compute vertex normals via vertex position list, face list. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 3 array of face (triangle) indices weighting : Weighting type, one of the following -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM uniform influence -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA area weighted -igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE angle weighted Returns n #v by 3 array of mesh vertex 3D normals See also per_face_normals, per_edge_normals Notes None Examples Mesh in (v, f) n = per_vertex_normals(v, f) igl.piecewise_constant_winding_number = piecewise_constant_winding_number(\u2026) method of builtins.PyCapsule instance","title":"per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object"},{"location":"igl_docs/#piecewise_constant_winding_numberf-array-bool_1","text":"PIECEWISE_CONSTANT_WINDING_NUMBER Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input to solid set operations. Assumes that (V,F) contains no -intersections (including degeneracies and co-incidences). If there are co-planar and co-incident vertex placements, a mesh could fail this combinatorial test but still induce a piecewise-constant winding number geometrically . For example, consider a hemisphere with boundary and then pinch the boundary \u201cshut\u201d along a line segment. The bullet-proof check is to first resolve all -intersections in (V,F) -> (SV,SF) (i.e. what the igl::copyleft::cgal::piecewise_constant_winding_number overload does). Parameters F #F by 3 list of triangle indices into some (abstract) list of vertices V Returns Returns true if the mesh combinatorially induces a piecewise constant winding number field. See also Notes None Examples igl.piecewise_constant_winding_number = piecewise_constant_winding_number(\u2026) method of builtins.PyCapsule instance","title":"piecewise_constant_winding_number(f: array) -&gt; bool"},{"location":"igl_docs/#piecewise_constant_winding_numberf-array-bool_2","text":"PIECEWISE_CONSTANT_WINDING_NUMBER Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input to solid set operations. Assumes that (V,F) contains no -intersections (including degeneracies and co-incidences). If there are co-planar and co-incident vertex placements, a mesh could fail this combinatorial test but still induce a piecewise-constant winding number geometrically . For example, consider a hemisphere with boundary and then pinch the boundary \u201cshut\u201d along a line segment. The bullet-proof check is to first resolve all -intersections in (V,F) -> (SV,SF) (i.e. what the igl::copyleft::cgal::piecewise_constant_winding_number overload does). Parameters F #F by 3 list of triangle indices into some (abstract) list of vertices V Returns Returns true if the mesh combinatorially induces a piecewise constant winding number field. See also Notes None Examples igl.principal_curvature = principal_curvature(\u2026) method of builtins.PyCapsule instance","title":"piecewise_constant_winding_number(f: array) -&gt; bool"},{"location":"igl_docs/#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object_1","text":"Compute the principal curvature directions and magnitude of the given triangle mesh. Parameters v : vertex array of size #V by 3 f : face index array #F by 3 list of mesh faces (must be triangles) radius : controls the size of the neighbourhood used, 1 = average edge length (default: 5) use_k_ring : (default: True) Returns pd1 : #v by 3 maximal curvature direction for each vertex pd2 : #v by 3 minimal curvature direction for each vertex pv1 : #v by 1 maximal curvature value for each vertex pv2 : #v by 1 minimal curvature value for each vertex See also average_onto_faces, average_onto_vertices Notes This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo. The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010 Examples Mesh in (v, f) pd1, pd2, pv1, pv2 = principal_curvature(v, f) igl.principal_curvature = principal_curvature(\u2026) method of builtins.PyCapsule instance","title":"principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]"},{"location":"igl_docs/#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object_2","text":"Compute the principal curvature directions and magnitude of the given triangle mesh. Parameters v : vertex array of size #V by 3 f : face index array #F by 3 list of mesh faces (must be triangles) radius : controls the size of the neighbourhood used, 1 = average edge length (default: 5) use_k_ring : (default: True) Returns pd1 : #v by 3 maximal curvature direction for each vertex pd2 : #v by 3 minimal curvature direction for each vertex pv1 : #v by 1 maximal curvature value for each vertex pv2 : #v by 1 minimal curvature value for each vertex See also average_onto_faces, average_onto_vertices Notes This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo. The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010 Examples Mesh in (v, f) pd1, pd2, pv1, pv2 = principal_curvature(v, f) igl.procrustes = procrustes(\u2026) method of builtins.PyCapsule instance","title":"principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]"},{"location":"igl_docs/#procrustesx-array-y-array-tuplebool-bool-float-object-object_1","text":"Solve Procrustes problem in d dimensions. Given two point sets X,Y in R^d find best scale s, orthogonal R and translation t s.t. s*X*R + t - Y^2 is minimized. Parameters X #V by DIM first list of points Y #V by DIM second list of points includeScaling if scaling should be allowed includeReflections if R is allowed to be a reflection Returns scale scaling R orthogonal matrix t translation See also Notes None Examples MatrixXd X, Y; (containing 3d points as rows) double scale; MatrixXd R; VectorXd t; igl::procrustes(X,Y,true,false,scale,R,t); R *= scale; MatrixXd Xprime = (X * R).rowwise() + t.transpose(); igl.procrustes = procrustes(\u2026) method of builtins.PyCapsule instance","title":"procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]"},{"location":"igl_docs/#procrustesx-array-y-array-tuplebool-bool-float-object-object_2","text":"Solve Procrustes problem in d dimensions. Given two point sets X,Y in R^d find best scale s, orthogonal R and translation t s.t. s*X*R + t - Y^2 is minimized. Parameters X #V by DIM first list of points Y #V by DIM second list of points includeScaling if scaling should be allowed includeReflections if R is allowed to be a reflection Returns scale scaling R orthogonal matrix t translation See also Notes None Examples MatrixXd X, Y; (containing 3d points as rows) double scale; MatrixXd R; VectorXd t; igl::procrustes(X,Y,true,false,scale,R,t); R *= scale; MatrixXd Xprime = (X * R).rowwise() + t.transpose(); igl.qslim = qslim(\u2026) method of builtins.PyCapsule instance","title":"procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]"},{"location":"igl_docs/#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object_1","text":"Decimate (simplify) a triangle mesh in nD according to the paper \u201cSimplifying Surfaces with Color and Texture using Quadric Error Metrics\u201d by [Garland and Heckbert, 1987] (technically a followup to qslim). The mesh can have open boundaries but should be edge-manifold. Parameters V #V by dim list of vertex positions. Assumes that vertices w F #F by 3 list of triangle indices into V max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices See also Notes None Examples igl.qslim = qslim(\u2026) method of builtins.PyCapsule instance","title":"qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]"},{"location":"igl_docs/#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object_2","text":"Decimate (simplify) a triangle mesh in nD according to the paper \u201cSimplifying Surfaces with Color and Texture using Quadric Error Metrics\u201d by [Garland and Heckbert, 1987] (technically a followup to qslim). The mesh can have open boundaries but should be edge-manifold. Parameters V #V by dim list of vertex positions. Assumes that vertices w F #F by 3 list of triangle indices into V max_m desired number of output faces Returns U #U by dim list of output vertex posistions (can be same ref as V) G #G by 3 list of output face indices into U (can be same ref as G) J #G list of indices into F of birth face I #U list of indices into V of birth vertices See also Notes None Examples igl.quad_planarity = quad_planarity(\u2026) method of builtins.PyCapsule instance","title":"qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]"},{"location":"igl_docs/#quad_planarityv-array-f-array-object_1","text":"Compute planarity of the faces of a quad mesh. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 4 array of face (quad) indices Returns p : #f by 1 array of mesh face (quad) planarities See also None Notes None Examples igl.quad_planarity = quad_planarity(\u2026) method of builtins.PyCapsule instance","title":"quad_planarity(v: array, f: array) -&gt; object"},{"location":"igl_docs/#quad_planarityv-array-f-array-object_2","text":"Compute planarity of the faces of a quad mesh. Parameters v : #v by 3 array of mesh vertex 3D positions f : #f by 4 array of face (quad) indices Returns p : #f by 1 array of mesh face (quad) planarities See also None Notes None Examples igl.random_points_on_mesh = random_points_on_mesh(\u2026) method of builtins.PyCapsule instance","title":"quad_planarity(v: array, f: array) -&gt; object"},{"location":"igl_docs/#random_points_on_meshn-int-v-array-f-array-tupleobject-object_1","text":"RANDOM_POINTS_ON_MESH Randomly sample a mesh (V,F) n times. Parameters n number of samples V #V by dim list of mesh vertex positions F #F by 3 list of mesh triangle indices Returns B n by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) FI n list of indices into F See also Notes None Examples igl.random_points_on_mesh = random_points_on_mesh(\u2026) method of builtins.PyCapsule instance","title":"random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#random_points_on_meshn-int-v-array-f-array-tupleobject-object_2","text":"RANDOM_POINTS_ON_MESH Randomly sample a mesh (V,F) n times. Parameters n number of samples V #V by dim list of mesh vertex positions F #F by 3 list of mesh triangle indices Returns B n by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) FI n list of indices into F See also Notes None Examples igl.read_dmat = read_dmat(\u2026) method of builtins.PyCapsule instance","title":"random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object_1","text":"Read a matrix from an ascii dmat file, a simple ascii matrix file type, defined as follows. The first line is always: <#columns> <#rows> Then the coefficients of the matrix are given separated by whitespace with columns running fastest. Parameters filename : string, path to .dmat file dtype : data-type of the returned matrix. Default is float64 . (returned faces always have type int32.) Returns w : array containing read-in coefficients See also read_triangle_mesh, read_off Notes None Examples w = read_dmat(\u201cmy_model.dmat\u201d) igl.read_dmat = read_dmat(\u2026) method of builtins.PyCapsule instance","title":"read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object"},{"location":"igl_docs/#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object_2","text":"Read a matrix from an ascii dmat file, a simple ascii matrix file type, defined as follows. The first line is always: <#columns> <#rows> Then the coefficients of the matrix are given separated by whitespace with columns running fastest. Parameters filename : string, path to .dmat file dtype : data-type of the returned matrix. Default is float64 . (returned faces always have type int32.) Returns w : array containing read-in coefficients See also read_triangle_mesh, read_off Notes None Examples w = read_dmat(\u201cmy_model.dmat\u201d) igl.read_obj = read_obj(\u2026) method of builtins.PyCapsule instance","title":"read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object"},{"location":"igl_docs/#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object_1","text":"Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .obj file dtype : data-type of the returned faces, texture coordinates and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 tc : array of texture coordinats #tc by 2 n : array of corner normals #n by 3 f : #f array of face indices into vertex positions ftc : #f array of face indices into vertex texture coordinates fn : #f array of face indices into vertex normals See also read_triangle_mesh, read_off Notes None Examples v, _, n, f, _, _ = read_obj(\u201cmy_model.obj\u201d) igl.read_obj = read_obj(\u2026) method of builtins.PyCapsule instance","title":"read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]"},{"location":"igl_docs/#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object_2","text":"Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .obj file dtype : data-type of the returned faces, texture coordinates and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 tc : array of texture coordinats #tc by 2 n : array of corner normals #n by 3 f : #f array of face indices into vertex positions ftc : #f array of face indices into vertex texture coordinates fn : #f array of face indices into vertex normals See also read_triangle_mesh, read_off Notes None Examples v, _, n, f, _, _ = read_obj(\u201cmy_model.obj\u201d) igl.read_off = read_off(\u2026) method of builtins.PyCapsule instance","title":"read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]"},{"location":"igl_docs/#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object_1","text":"Read a mesh from an ascii off file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .off file read_normals : bool, determines whether normals are read. If false, returns [] dtype : data-type of the returned vertices, faces, and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions n : list of vertex normals #v by 3 See also read_triangle_mesh, read_obj Notes None Examples v, f, n, c = read_off(\u201cmy_model.off\u201d) igl.read_off = read_off(\u2026) method of builtins.PyCapsule instance","title":"read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object_2","text":"Read a mesh from an ascii off file, filling in vertex positions, normals and texture coordinates. Mesh may have faces of any number of degree. Parameters filename : string, path to .off file read_normals : bool, determines whether normals are read. If false, returns [] dtype : data-type of the returned vertices, faces, and normals, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions n : list of vertex normals #v by 3 See also read_triangle_mesh, read_obj Notes None Examples v, f, n, c = read_off(\u201cmy_model.off\u201d) igl.read_triangle_mesh = read_triangle_mesh(\u2026) method of builtins.PyCapsule instance","title":"read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object_1","text":"Read mesh from an ascii file with automatic detection of file format. Supported: obj, off, stl, wrl, ply, mesh. Parameters filename : string, path to mesh file dtype : data-type of the returned vertices, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions See also read_obj, read_off, read_stl Notes None Examples v, f = read_triangle_mesh(\u201cmy_model.obj\u201d) igl.read_triangle_mesh = read_triangle_mesh(\u2026) method of builtins.PyCapsule instance","title":"read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]"},{"location":"igl_docs/#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object_2","text":"Read mesh from an ascii file with automatic detection of file format. Supported: obj, off, stl, wrl, ply, mesh. Parameters filename : string, path to mesh file dtype : data-type of the returned vertices, optional. Default is float64 . (returned faces always have type int32.) Returns v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions See also read_obj, read_off, read_stl Notes None Examples v, f = read_triangle_mesh(\u201cmy_model.obj\u201d) igl.remove_duplicate_vertices = remove_duplicate_vertices(\u2026) method of builtins.PyCapsule instance","title":"read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]"},{"location":"igl_docs/#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object_1","text":"REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness tolerance (epsilon) Parameters V #V by dim list of vertex positions epsilon uniqueness tolerance (significant digit), can probably think of this as a tolerance on L1 distance Returns SV #SV by dim new list of vertex positions SVI #V by 1 list of indices so SV = V(SVI,:) SVJ #SV by 1 list of indices so V = SV(SVJ,:) Wrapper that also remaps given faces (F) \u2192 (SF) so that SF index SV See also Notes None Examples % Mesh in (V,F) [SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7); % remap faces SF = SVJ(F); igl.remove_duplicate_vertices = remove_duplicate_vertices(\u2026) method of builtins.PyCapsule instance","title":"remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]"},{"location":"igl_docs/#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object_2","text":"REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness tolerance (epsilon) Parameters V #V by dim list of vertex positions epsilon uniqueness tolerance (significant digit), can probably think of this as a tolerance on L1 distance Returns SV #SV by dim new list of vertex positions SVI #V by 1 list of indices so SV = V(SVI,:) SVJ #SV by 1 list of indices so V = SV(SVJ,:) Wrapper that also remaps given faces (F) \u2192 (SF) so that SF index SV See also Notes None Examples % Mesh in (V,F) [SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7); % remap faces SF = SVJ(F); igl.remove_duplicates = remove_duplicates(\u2026) method of builtins.PyCapsule instance","title":"remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]"},{"location":"igl_docs/#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object_1","text":"Merge the duplicate vertices from V, fixing the topology accordingly Parameters V,F mesh description epsilon minimal distance to consider two vertices identical Returns NV, NF new mesh without duplicate vertices See also Notes None Examples igl.remove_duplicates = remove_duplicates(\u2026) method of builtins.PyCapsule instance","title":"remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object_2","text":"Merge the duplicate vertices from V, fixing the topology accordingly Parameters V,F mesh description epsilon minimal distance to consider two vertices identical Returns NV, NF new mesh without duplicate vertices See also Notes None Examples igl.remove_unreferenced = remove_unreferenced(\u2026) method of builtins.PyCapsule instance","title":"remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]"},{"location":"igl_docs/#remove_unreferencedv-array-f-array-tupleobject-object-object-object_1","text":"Remove unreferenced vertices from V, updating F accordingly Parameters V #V by dim list of mesh vertex positions F #F by ss list of simplices (Values of -1 are quitely skipped) Returns NV #NV by dim list of mesh vertex positions NF #NF by ss list of simplices IM #V by 1 list of indices such that: NF = IM(F) and NT = IM(T) and V(find(IM<=size(NV,1)),:) = NV J #RV by 1 list, such that RV = V(J,:) See also Notes None Examples igl.remove_unreferenced = remove_unreferenced(\u2026) method of builtins.PyCapsule instance","title":"remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]"},{"location":"igl_docs/#remove_unreferencedv-array-f-array-tupleobject-object-object-object_2","text":"Remove unreferenced vertices from V, updating F accordingly Parameters V #V by dim list of mesh vertex positions F #F by ss list of simplices (Values of -1 are quitely skipped) Returns NV #NV by dim list of mesh vertex positions NF #NF by ss list of simplices IM #V by 1 list of indices such that: NF = IM(F) and NT = IM(T) and V(find(IM<=size(NV,1)),:) = NV J #RV by 1 list, such that RV = V(J,:) See also Notes None Examples igl.resolve_duplicated_faces = resolve_duplicated_faces(\u2026) method of builtins.PyCapsule instance","title":"remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]"},{"location":"igl_docs/#resolve_duplicated_facesf1-array-tupleobject-object_1","text":"Resolve duplicated faces according to the following rules per unique face:","title":"resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#if-the-number-of-positively-oriented-faces-equals-the-number-of_3","text":"negatively oriented faces, remove all duplicated faces at this triangle.","title":"If the number of positively oriented faces equals the number of"},{"location":"igl_docs/#if-the-number-of-positively-oriented-faces-equals-the-number-of_4","text":"negatively oriented faces plus 1, keeps one of the positively oriented face.","title":"If the number of positively oriented faces equals the number of"},{"location":"igl_docs/#if-the-number-of-positively-oriented-faces-equals-the-number-of_5","text":"negatively oriented faces minus 1, keeps one of the negatively oriented face.","title":"If the number of positively oriented faces equals the number of"},{"location":"igl_docs/#if-the-number-of-postively-oriented-faces-differ-with-the-number-of_1","text":"negativley oriented faces by more than 1, the mesh is not orientable. An exception will be thrown. Parameters F1 #F1 by 3 array of input faces. Returns F2 #F2 by 3 array of output faces without duplicated faces. J #F2 list of indices into F1. See also Notes None Examples igl.resolve_duplicated_faces = resolve_duplicated_faces(\u2026) method of builtins.PyCapsule instance","title":"If the number of postively oriented faces differ with the number of"},{"location":"igl_docs/#resolve_duplicated_facesf1-array-tupleobject-object_2","text":"Resolve duplicated faces according to the following rules per unique face:","title":"resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#if-the-number-of-positively-oriented-faces-equals-the-number-of_6","text":"negatively oriented faces, remove all duplicated faces at this triangle.","title":"If the number of positively oriented faces equals the number of"},{"location":"igl_docs/#if-the-number-of-positively-oriented-faces-equals-the-number-of_7","text":"negatively oriented faces plus 1, keeps one of the positively oriented face.","title":"If the number of positively oriented faces equals the number of"},{"location":"igl_docs/#if-the-number-of-positively-oriented-faces-equals-the-number-of_8","text":"negatively oriented faces minus 1, keeps one of the negatively oriented face.","title":"If the number of positively oriented faces equals the number of"},{"location":"igl_docs/#if-the-number-of-postively-oriented-faces-differ-with-the-number-of_2","text":"negativley oriented faces by more than 1, the mesh is not orientable. An exception will be thrown. Parameters F1 #F1 by 3 array of input faces. Returns F2 #F2 by 3 array of output faces without duplicated faces. J #F2 list of indices into F1. See also Notes None Examples igl.shape_diameter_function = shape_diameter_function(\u2026) method of builtins.PyCapsule instance","title":"If the number of postively oriented faces differ with the number of"},{"location":"igl_docs/#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object_1","text":"Compute shape diamater function per given point. In the parlence of the paper \u201cConsistent Mesh Partitioning and Skeletonisation using the Shape Diameter Function\u201d [Shapiro et al. 2008], this implementation uses a 180\u00b0 cone and a uniform average ( not a average weighted by inverse angles). Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of shape diamater function values between bounding box diagonal (perfect sphere) and 0 (perfect needle hook) See also Notes None Examples igl.shape_diameter_function = shape_diameter_function(\u2026) method of builtins.PyCapsule instance","title":"shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object"},{"location":"igl_docs/#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object_2","text":"Compute shape diamater function per given point. In the parlence of the paper \u201cConsistent Mesh Partitioning and Skeletonisation using the Shape Diameter Function\u201d [Shapiro et al. 2008], this implementation uses a 180\u00b0 cone and a uniform average ( not a average weighted by inverse angles). Parameters V #V by 3 list of mesh vertex positions F #F by 3 list of mesh face indices into V P #P by 3 list of origin points N #P by 3 list of origin normals Returns S #P list of shape diamater function values between bounding box diagonal (perfect sphere) and 0 (perfect needle hook) See also Notes None Examples igl.sort_angles = sort_angles(\u2026) method of builtins.PyCapsule instance","title":"shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object"},{"location":"igl_docs/#sort_anglesm-array-object_1","text":"Sort angles in ascending order in a numerically robust way. Instead of computing angles using atan2(y, x), sort directly on (y, x). Parameters - M: m by n matrix of scalars. (n >= 2). Assuming the first column of M contains values for y, and the second column is x. Using the rest of the columns as tie-breaker. Returns R: an array of m indices. M.row(R[i]) contains the i-th smallest angle. See also Notes None. Examples igl.sort_angles = sort_angles(\u2026) method of builtins.PyCapsule instance","title":"sort_angles(m: array) -&gt; object"},{"location":"igl_docs/#sort_anglesm-array-object_2","text":"Sort angles in ascending order in a numerically robust way. Instead of computing angles using atan2(y, x), sort directly on (y, x). Parameters - M: m by n matrix of scalars. (n >= 2). Assuming the first column of M contains values for y, and the second column is x. Using the rest of the columns as tie-breaker. Returns R: an array of m indices. M.row(R[i]) contains the i-th smallest angle. See also Notes None. Examples igl.tetrahedralize = tetrahedralize(\u2026) method of builtins.PyCapsule instance","title":"sort_angles(m: array) -&gt; object"},{"location":"igl_docs/#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object_1","text":"Mesh the interior of a surface mesh (V,F) using tetgen. Parameters v : #v by 3 vertex position array f : #v array of polygon face indices into V (0-indexed) switches : string of tetgen options (See tetgen documentation) e.g. \u201cpq1.414a0.01\u201d tries to mesh the interior of a given surface with quality and area constraints. Will mesh the convex hull constrained to pass through V (ignores F) Returns tv #v by 3 vertex position array tt #t by 4 array of tet face indices tf #f by 3 array of triangle face indices See also None Notes Returns status: 0 success 1 tetgen threw exception 2 tetgen did not crash but could not create any tets (probably there are holes, duplicate faces etc.) -1 other error Examples igl.tetrahedralize = tetrahedralize(\u2026) method of builtins.PyCapsule instance","title":"tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]"},{"location":"igl_docs/#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object_2","text":"Mesh the interior of a surface mesh (V,F) using tetgen. Parameters v : #v by 3 vertex position array f : #v array of polygon face indices into V (0-indexed) switches : string of tetgen options (See tetgen documentation) e.g. \u201cpq1.414a0.01\u201d tries to mesh the interior of a given surface with quality and area constraints. Will mesh the convex hull constrained to pass through V (ignores F) Returns tv #v by 3 vertex position array tt #t by 4 array of tet face indices tf #f by 3 array of triangle face indices See also None Notes Returns status: 0 success 1 tetgen threw exception 2 tetgen did not crash but could not create any tets (probably there are holes, duplicate faces etc.) -1 other error Examples igl.triangle_triangle_adjacency = triangle_triangle_adjacency(\u2026) method of builtins.PyCapsule instance","title":"tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]"},{"location":"igl_docs/#triangle_triangle_adjacencyf-array-tupleobject-object_1","text":"Constructs the triangle-triangle adjacency matrix for a given mesh (V,F). Parameters F #F by simplex_size list of mesh faces (must be triangles) Returns TT #F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i TTi #F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i See also Notes NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third [2,3]. this convention is DIFFERENT from cotmatrix_entries.h Examples igl.triangle_triangle_adjacency = triangle_triangle_adjacency(\u2026) method of builtins.PyCapsule instance","title":"triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#triangle_triangle_adjacencyf-array-tupleobject-object_2","text":"Constructs the triangle-triangle adjacency matrix for a given mesh (V,F). Parameters F #F by simplex_size list of mesh faces (must be triangles) Returns TT #F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i TTi #F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i See also Notes NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third [2,3]. this convention is DIFFERENT from cotmatrix_entries.h Examples igl.triangulate = triangulate(\u2026) method of builtins.PyCapsule instance","title":"triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object_1","text":"Triangulate the interior of a polygon using the triangle library. Parameters v : #v by 2 array of 2D vertex positions e : #e by 2 array of vertex ids forming unoriented edges of the boundary of the polygon h : #h by 2 coordinates of points contained inside holes of the polygon m : optional #v list of markers for input vertices flags : string of options pass to triangle (see triangle documentation) (default \u2018a0.005q\u2019) Returns v2 : #v2 by 2 coordinates of the vertives of the generated triangulation f2 : #f2 by 3 array of indices forming the faces of the generated triangulation m2 : (only if you passed in m) #v2 list of markers for output vertices See also Notes Examples v2, f2 = triangulate(v, e, h) igl.triangulate = triangulate(\u2026) method of builtins.PyCapsule instance","title":"triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]"},{"location":"igl_docs/#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object_2","text":"Triangulate the interior of a polygon using the triangle library. Parameters v : #v by 2 array of 2D vertex positions e : #e by 2 array of vertex ids forming unoriented edges of the boundary of the polygon h : #h by 2 coordinates of points contained inside holes of the polygon m : optional #v list of markers for input vertices flags : string of options pass to triangle (see triangle documentation) (default \u2018a0.005q\u2019) Returns v2 : #v2 by 2 coordinates of the vertives of the generated triangulation f2 : #f2 by 3 array of indices forming the faces of the generated triangulation m2 : (only if you passed in m) #v2 list of markers for output vertices See also Notes Examples v2, f2 = triangulate(v, e, h) igl.uniformly_sample_two_manifold_at_vertices = uniformly_sample_two_manifold_at_vertices(\u2026) method of builtins.PyCapsule instance","title":"triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]"},{"location":"igl_docs/#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object_1","text":"Find uniform sampling up to placing samples on mesh vertices Parameters Returns See also Notes None Examples igl.uniformly_sample_two_manifold_at_vertices = uniformly_sample_two_manifold_at_vertices(\u2026) method of builtins.PyCapsule instance","title":"uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object"},{"location":"igl_docs/#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object_2","text":"Find uniform sampling up to placing samples on mesh vertices Parameters Returns See also Notes None Examples igl.uniformly_sample_two_manifold_internal = uniformly_sample_two_manifold_internal(\u2026) method of builtins.PyCapsule instance","title":"uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object"},{"location":"igl_docs/#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object_1","text":"UNIFORMLY_SAMPLE_TWO_MANIFOLD Attempt to sample a mesh uniformly by furthest point relaxation as described in \u201cFast Automatic Skinning Transformations\u201d [Jacobson et al. 12] Section 3.3. Parameters W #W by dim positions of mesh in weight space F #F by 3 indices of triangles k number of samplse push factor by which corners should be pushed away Returns WS k by dim locations in weights space See also Notes None Examples igl.uniformly_sample_two_manifold_internal = uniformly_sample_two_manifold_internal(\u2026) method of builtins.PyCapsule instance","title":"uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object"},{"location":"igl_docs/#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object_2","text":"UNIFORMLY_SAMPLE_TWO_MANIFOLD Attempt to sample a mesh uniformly by furthest point relaxation as described in \u201cFast Automatic Skinning Transformations\u201d [Jacobson et al. 12] Section 3.3. Parameters W #W by dim positions of mesh in weight space F #F by 3 indices of triangles k number of samplse push factor by which corners should be pushed away Returns WS k by dim locations in weights space See also Notes None Examples igl.unproject = unproject(\u2026) method of builtins.PyCapsule instance","title":"uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object"},{"location":"igl_docs/#unprojectwin-array-model-array-proj-array-viewport-array-object_1","text":"Reimplementation of gluUnproject Parameters win #P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns scene #P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates See also Notes None Examples igl.unproject = unproject(\u2026) method of builtins.PyCapsule instance","title":"unproject(win: array, model: array, proj: array, viewport: array) -&gt; object"},{"location":"igl_docs/#unprojectwin-array-model-array-proj-array-viewport-array-object_2","text":"Reimplementation of gluUnproject Parameters win #P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns scene #P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates See also Notes None Examples igl.unproject_in_mesh = unproject_in_mesh(\u2026) method of builtins.PyCapsule instance","title":"unproject(win: array, model: array, proj: array, viewport: array) -&gt; object"},{"location":"igl_docs/#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit_1","text":"Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position inside a given mesh. If the ray through the given screen location (x,y) hits the mesh more than twice then the 3D midpoint between the first two hits is return. If it hits once, then that point is return. If it does not hit the mesh then obj is not set. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns obj 3d unprojected mouse point in mesh hits vector of hits Returns number of hits See also Notes None Examples igl.unproject_in_mesh = unproject_in_mesh(\u2026) method of builtins.PyCapsule instance","title":"unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]"},{"location":"igl_docs/#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit_2","text":"Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position inside a given mesh. If the ray through the given screen location (x,y) hits the mesh more than twice then the 3D midpoint between the first two hits is return. If it hits once, then that point is return. If it does not hit the mesh then obj is not set. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns obj 3d unprojected mouse point in mesh hits vector of hits Returns number of hits See also Notes None Examples igl.unproject_onto_mesh = unproject_onto_mesh(\u2026) method of builtins.PyCapsule instance","title":"unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]"},{"location":"igl_docs/#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object_1","text":"Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position onto a given mesh, if the ray through the given screen location (x,y) hits the mesh. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns fid id of the first face hit bc barycentric coordinates of hit Returns true if there\u2019s a hit See also Notes None Examples igl.unproject_onto_mesh = unproject_onto_mesh(\u2026) method of builtins.PyCapsule instance","title":"unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]"},{"location":"igl_docs/#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object_2","text":"Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position onto a given mesh, if the ray through the given screen location (x,y) hits the mesh. Parameters pos screen space coordinates model model matrix proj projection matrix viewport vieweport vector V #V by 3 list of mesh vertex positions F #F by 3 list of mesh triangle indices into V Returns fid id of the first face hit bc barycentric coordinates of hit Returns true if there\u2019s a hit See also Notes None Examples igl.unproject_ray = unproject_ray(\u2026) method of builtins.PyCapsule instance","title":"unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]"},{"location":"igl_docs/#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object_1","text":"Construct a ray (source point + direction vector) given a screen space positions (e.g. mouse) and a model-view projection constellation. Parameters pos 2d screen-space position (x,y) model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns s source of ray (pos unprojected with z=0) dir direction of ray (d - s) where d is pos unprojected with z=1 See also Notes None Examples igl.unproject_ray = unproject_ray(\u2026) method of builtins.PyCapsule instance","title":"unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object_2","text":"Construct a ray (source point + direction vector) given a screen space positions (e.g. mouse) and a model-view projection constellation. Parameters pos 2d screen-space position (x,y) model 4x4 model-view matrix proj 4x4 projection matrix viewport 4-long viewport vector Returns s source of ray (pos unprojected with z=0) dir direction of ray (d - s) where d is pos unprojected with z=1 See also Notes None Examples igl.upsample = upsample(\u2026) method of builtins.PyCapsule instance","title":"unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]"},{"location":"igl_docs/#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object_1","text":"Subdivide a mesh without moving vertices: loop subdivision but odd vertices stay put and even vertices are just edge midpoints Parameters V #V by dim mesh vertices F #F by 3 mesh triangles Returns NV new vertex positions, V is guaranteed to be at top NF new list of face indices See also Notes assumes (V,F) is edge-manifold. Examples igl.upsample = upsample(\u2026) method of builtins.PyCapsule instance","title":"upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]"},{"location":"igl_docs/#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object_2","text":"Subdivide a mesh without moving vertices: loop subdivision but odd vertices stay put and even vertices are just edge midpoints Parameters V #V by dim mesh vertices F #F by 3 mesh triangles Returns NV new vertex positions, V is guaranteed to be at top NF new list of face indices See also Notes assumes (V,F) is edge-manifold. Examples igl.vector_area_matrix = vector_area_matrix(\u2026) method of builtins.PyCapsule instance","title":"upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]"},{"location":"igl_docs/#vector_area_matrixf-array-object_1","text":"Constructs the symmetric area matrix A, s.t. [V.col(0)\u2019 V.col(1)\u2019] * A * [V.col(0); V.col(1)] is the vector area of the mesh (V,F). Parameters f : #f by 3 array of mesh faces (must be triangles) Returns a : #vx2 by #vx2 area matrix See also None Notes None Examples igl.vector_area_matrix = vector_area_matrix(\u2026) method of builtins.PyCapsule instance","title":"vector_area_matrix(f: array) -&gt; object"},{"location":"igl_docs/#vector_area_matrixf-array-object_2","text":"Constructs the symmetric area matrix A, s.t. [V.col(0)\u2019 V.col(1)\u2019] * A * [V.col(0); V.col(1)] is the vector area of the mesh (V,F). Parameters f : #f by 3 array of mesh faces (must be triangles) Returns a : #vx2 by #vx2 area matrix See also None Notes None Examples igl.vertex_components = vertex_components(\u2026) method of builtins.PyCapsule instance","title":"vector_area_matrix(f: array) -&gt; object"},{"location":"igl_docs/#vertex_componentsf-array-object_1","text":"Compute connected components of the vertices of a mesh given the mesh\u2019 face indices. Parameters f : #f x dim array of face indices Returns An array of component ids (starting with 0) See also vertex_components_from_adjacency_matrix face_components_from_faces Notes Examples igl.vertex_components = vertex_components(\u2026) method of builtins.PyCapsule instance","title":"vertex_components(f: array) -&gt; object"},{"location":"igl_docs/#vertex_componentsf-array-object_2","text":"Compute connected components of the vertices of a mesh given the mesh\u2019 face indices. Parameters f : #f x dim array of face indices Returns An array of component ids (starting with 0) See also vertex_components_from_adjacency_matrix face_components_from_faces Notes Examples igl.vertex_components_from_adjacency_matrix = vertex_components_from_adjacency_matrix(\u2026) method of builtins.PyCapsule instance","title":"vertex_components(f: array) -&gt; object"},{"location":"igl_docs/#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object_1","text":"Compute connected components of a graph represented by a sparse adjacency matrix. Parameters a : n by n sparse adjacency matrix Returns A tuple (c, counts) where c is an array of component ids (starting with 0) and counts is a #components array of counts for each component See also vertex_components face_components Notes Examples igl.vertex_components_from_adjacency_matrix = vertex_components_from_adjacency_matrix(\u2026) method of builtins.PyCapsule instance","title":"vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]"},{"location":"igl_docs/#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object_2","text":"Compute connected components of a graph represented by a sparse adjacency matrix. Parameters a : n by n sparse adjacency matrix Returns A tuple (c, counts) where c is an array of component ids (starting with 0) and counts is a #components array of counts for each component See also vertex_components face_components Notes Examples igl.vertex_triangle_adjacency = vertex_triangle_adjacency(\u2026) method of builtins.PyCapsule instance","title":"vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]"},{"location":"igl_docs/#vertex_triangle_adjacencyf-array-n-int-tupleobject-object_1","text":"vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F) Parameters F #F by 3 list of triangle indices into some vertex list V n number of vertices, #V (e.g., F.maxCoeff()+1) Returns VF 3*#F list List of faces indice on each vertex, so that VF(NI(i)+j) = f, means that face f is the jth face (in no particular order) incident on vertex i. NI #V+1 list cumulative sum of vertex-triangle degrees with a preceeding zero. \u201cHow many faces\u201d have been seen before visiting this vertex and its incident faces. See also Notes None Examples igl.vertex_triangle_adjacency = vertex_triangle_adjacency(\u2026) method of builtins.PyCapsule instance","title":"vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#vertex_triangle_adjacencyf-array-n-int-tupleobject-object_2","text":"vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F) Parameters F #F by 3 list of triangle indices into some vertex list V n number of vertices, #V (e.g., F.maxCoeff()+1) Returns VF 3*#F list List of faces indice on each vertex, so that VF(NI(i)+j) = f, means that face f is the jth face (in no particular order) incident on vertex i. NI #V+1 list cumulative sum of vertex-triangle degrees with a preceeding zero. \u201cHow many faces\u201d have been seen before visiting this vertex and its incident faces. See also Notes None Examples igl.winding_number = winding_number(\u2026) method of builtins.PyCapsule instance","title":"vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]"},{"location":"igl_docs/#winding_numberv-array-f-array-o-array-object_1","text":"WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron described by points (vectors) V Parameters V n by 3 list of vertex positions F #F by 3 list of triangle indices, minimum index is 0 O no by 3 list of origin positions Returns S no by 1 list of winding numbers See also Notes None Examples igl.winding_number = winding_number(\u2026) method of builtins.PyCapsule instance","title":"winding_number(v: array, f: array, o: array) -&gt; object"},{"location":"igl_docs/#winding_numberv-array-f-array-o-array-object_2","text":"WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron described by points (vectors) V Parameters V n by 3 list of vertex positions F #F by 3 list of triangle indices, minimum index is 0 O no by 3 list of origin positions Returns S no by 1 list of winding numbers See also Notes None Examples igl.winding_number_for_point = winding_number_for_point(\u2026) method of builtins.PyCapsule instance","title":"winding_number(v: array, f: array, o: array) -&gt; object"},{"location":"igl_docs/#winding_number_for_pointv-array-f-array-p-array-float_1","text":"Compute winding number of a single point Parameters V n by dim list of vertex positions F #F by dim list of triangle indices, minimum index is 0 p single origin position Returns w winding number of this point See also Notes None Examples igl.winding_number_for_point = winding_number_for_point(\u2026) method of builtins.PyCapsule instance","title":"winding_number_for_point(v: array, f: array, p: array) -&gt; float"},{"location":"igl_docs/#winding_number_for_pointv-array-f-array-p-array-float_2","text":"Compute winding number of a single point Parameters V n by dim list of vertex positions F #F by dim list of triangle indices, minimum index is 0 p single origin position Returns w winding number of this point See also Notes None Examples igl.write_obj = write_obj(\u2026) method of builtins.PyCapsule instance","title":"winding_number_for_point(v: array, f: array, p: array) -&gt; float"},{"location":"igl_docs/#write_objfilename-str-v-array-f-array-bool_1","text":"Write a mesh in an ascii obj file. Parameters filename : path to outputfile v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions Returns ret : bool if output was successful See also read_obj Notes None Examples Mesh in (v, f) success = write_obj(v, f) igl.write_obj = write_obj(\u2026) method of builtins.PyCapsule instance","title":"write_obj(filename: str, v: array, f: array) -&gt; bool"},{"location":"igl_docs/#write_objfilename-str-v-array-f-array-bool_2","text":"Write a mesh in an ascii obj file. Parameters filename : path to outputfile v : array of vertex positions #v by 3 f : #f list of face indices into vertex positions Returns ret : bool if output was successful See also read_obj Notes None Examples Mesh in (v, f) success = write_obj(v, f) igl.write_off = write_off(\u2026) method of builtins.PyCapsule instance","title":"write_obj(filename: str, v: array, f: array) -&gt; bool"},{"location":"igl_docs/#write_offstr-str-v-array-f-array-c-array-bool_1","text":"Export geometry and colors-by-vertex Export a mesh from an ascii OFF file, filling in vertex positions. Only triangle meshes are supported Parameters str path to .off output file V #V by 3 mesh vertex positions F #F by 3 mesh indices into V C double matrix of rgb values per vertex #V by 3 Returns Returns true on success, false on errors See also Notes None Examples igl.write_off = write_off(\u2026) method of builtins.PyCapsule instance","title":"write_off(str: str, v: array, f: array, c: array) -&gt; bool"},{"location":"igl_docs/#write_offstr-str-v-array-f-array-c-array-bool_2","text":"Export geometry and colors-by-vertex Export a mesh from an ascii OFF file, filling in vertex positions. Only triangle meshes are supported Parameters str path to .off output file V #V by 3 mesh vertex positions F #F by 3 mesh indices into V C double matrix of rgb values per vertex #V by 3 Returns Returns true on success, false on errors See also Notes None Examples igl.write_triangle_mesh = write_triangle_mesh(\u2026) method of builtins.PyCapsule instance","title":"write_off(str: str, v: array, f: array, c: array) -&gt; bool"},{"location":"igl_docs/#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool_1","text":"write mesh to a file with automatic detection of file format. supported: obj, off, stl, wrl, ply, mesh). Parameters str path to file V eigen double matrix #V by 3 F eigen int matrix #F by 3 force_ascii=True force ascii format even if binary is available Returns Returns true iff success See also Notes Examples igl.write_triangle_mesh = write_triangle_mesh(\u2026) method of builtins.PyCapsule instance","title":"write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool"},{"location":"igl_docs/#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool_2","text":"write mesh to a file with automatic detection of file format. supported: obj, off, stl, wrl, ply, mesh). Parameters str path to file V eigen double matrix #V by 3 F eigen int matrix #F by 3 force_ascii=True force ascii format even if binary is available Returns Returns true iff success See also Notes Examples class ARAP","title":"write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool"},{"location":"igl_docs/#solve-iglpyigl_classesarap-arg0-numpyndarray-arg1-numpyndarray-object","text":"class BBW","title":"solve(: igl.pyigl_classes.ARAP, arg0: numpy.ndarray, arg1: numpy.ndarray) -&gt; object"},{"location":"igl_docs/#solve-iglpyigl_classesbbw-arg0-numpyndarray-arg1-numpyndarray-arg2-numpyndarrayint32m-1-arg3-numpyndarray-object","text":"class SLIM","title":"solve(: igl.pyigl_classes.BBW, arg0: numpy.ndarray, arg1: numpy.ndarray, arg2: numpy.ndarray[int32[m, 1]], arg3: numpy.ndarray) -&gt; object"},{"location":"igl_docs/#energy-iglpyigl_classesslim-float","text":"","title":"energy(: igl.pyigl_classes.SLIM) -&gt; float"},{"location":"igl_docs/#solve-iglpyigl_classesslim-arg0-int","text":"","title":"solve(: igl.pyigl_classes.SLIM, arg0: int)"},{"location":"igl_docs/#vertices-iglpyigl_classesslim-object","text":"","title":"vertices(: igl.pyigl_classes.SLIM) -&gt; object"},{"location":"data/","text":"This directory contains a slew of models and data needed to run the tutorial examples. This README.md contains an attempt to track down original sources of this data for purposes of attribution. In some cases, only the oldest known use is listed. Filename Source 2triangles.off [#libigl][] 3holes.off ? arm-weights.dmat [#libigl][] arm.obj ? arm.tgf [#libigl][] armadillo-weights.dmat [#libigl][] armadillo.obj [#stanford][] beetle.off [#ivan][] big-sigcat.mesh [#jacobson_2013][] bump-domain.obj ? bumpy-cube.dmat ? bumpy-cube.obj ? bumpy.off ? bunny.mesh [#stanford][] bunny.off [#stanford][] camelhead.off [#sorkine_2004][] cheburashka-scalar.dmat [#libigl][] cheburashka.off [#cosmic_blobs][] cow.off ? cube.obj [#libigl][] cube.off [#libigl][] decimated-knight-selection.dmat [#libigl][] decimated-knight.off [#cosmic_blobs][] decimated-max-selection.dmat [#libigl][] decimated-max.obj [#mpi][] fandisk.off [#aim_at_shape][] fertility.off [#aim_at_shape][] grid.off [#libigl][] hand-pose.dmat [#libigl][] hand.mesh ? hand.tgf [#libigl][] horse_quad.obj ? inspired_mesh.dmat [#libigl][] inspired_mesh.obj ? inspired_mesh_b.dmat [#libigl][] inspired_mesh_bc.dmat [#libigl][] inspired_mesh_quads_Conjugate.off ? inspired_mesh_quads_Smooth.off ? lilium.crossfield [#libigl][] lilium.obj ? lilium.samples.0.2 [#libigl][] lilium_b.dmat [#libigl][] lilium_bc.dmat [#libigl][] lion.off ? octopus-high.mesh [#pauly][] octopus-low.mesh [#pauly][] planexy.off ? screwdriver.off ? snail.dmat [#libigl][] snail.obj ? snail.samples.0.2 [#libigl][] snail1.dmat [#libigl][] snail2.dmat [#libigl][] snail3.dmat [#libigl][] snail4.dmat [#libigl][] sphere.obj ? truck.obj [#shrec][] xcylinder.obj [#libigl][] ycylinder.obj [#libigl][] zcylinder.obj [#libigl][] [#aim_at_shape]: AIM@SHAPE,IAL_SHARED_PATH \u201c/cow.off\u201d.cnr.it:8080/ontologies/shapes/viewgroup.jsp?id=225-Fandisk_MC [#cosmic_blobs]: Cosmic blobs, http://www.mit.edu/~ibaran/autorig/ [#ivan]: Hand measured from physical object, http://www.cs.utah.edu/docs/misc/Uteapot03.pdf [#jacobson_2013]: Alec Jacobson, Ladislav Kavan, and Olga Sorkine. Robust Inside-Outside Segmentation using Generalized Winding Numbers , 2013. [#libigl]: Original data produced by libigl authors, http://libigl.github.io/libigl/ [#mpi]: Max Planck Institute at Saarbrucken. [#pauly]: Modeled by Mark Pauly, \u201cShape Modeling with Point-Sampled Geometry\u201d [#shrec]: SHREC 2009 Dataset, http://www.itl.nist.gov/iad/vug/sharp/benchmark/shrecPartial/data.html [#sorkine_2004]: Olga Sorkine, Daniel Cohen-Or, Least-squares Meshes , 2004. [#stanford]: The Stanford 3D Scanning Repository, http://graphics.stanford.edu/data/3Dscanrep/","title":"Home"}]}