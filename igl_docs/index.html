



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="Simple Python geometry processing library">
      
      
        <link rel="canonical" href="https://libigl.github.io/igl_docs/">
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../favicon.ico">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-3.1.0">
    
    
      
        <title>Docs - igl</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.11e41852.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
      
      
        
        
        <meta name="theme-color" content="#03a9f4">
      
    
    
      <script src="../assets/javascripts/modernizr.20ef595d.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="light-blue" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#adjacency_listf-array-handle" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://libigl.github.io/" title="igl" class="md-header-nav__button md-logo">
          
            <i class="md-icon"> </i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                igl
              </span>
              <span class="md-header-nav__topic">
                Docs
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/geometryprocessing/libigl-python-bindings/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#__github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      libigl-python-bindings
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://libigl.github.io/" title="igl" class="md-nav__button md-logo">
      
        <i class="md-icon"> </i>
      
    </a>
    igl
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/geometryprocessing/libigl-python-bindings/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#__github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      libigl-python-bindings
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../tutorials.ipynb" title="Tutorial" class="md-nav__link">
      Tutorial
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Docs
      </label>
    
    <a href="./" title="Docs" class="md-nav__link md-nav__link--active">
      Docs
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#adjacency_listf-array-handle" title="adjacency_list(f: array) -&gt; handle" class="md-nav__link">
    adjacency_list(f: array) -&gt; handle
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency_matrixf-array-object" title="adjacency_matrix(f: array) -&gt; object" class="md-nav__link">
    adjacency_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object" title="ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_blockv-array-f-array-d-int-energy-int-object" title="arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_elementsv-array-f-array-d-int-object" title="arap_linear_block_elements(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_elements(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokesv-array-f-array-d-int-object" title="arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object" title="arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_rhsv-array-f-array-d-int-energy-int-object" title="arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#average_onto_verticesv-array-f-array-s-array-object" title="average_onto_vertices(v: array, f: array, s: array) -&gt; object" class="md-nav__link">
    average_onto_vertices(v: array, f: array, s: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avg_edge_lengthv-array-f-array-float" title="avg_edge_length(v: array, f: array) -&gt; float" class="md-nav__link">
    avg_edge_length(v: array, f: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycenterv-array-f-array-object" title="barycenter(v: array, f: array) -&gt; object" class="md-nav__link">
    barycenter(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object" title="barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_trip-array-a-array-b-array-c-array-object" title="barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object" title="bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfs_orientf-array-tupleobject-object" title="bfs_orient(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs_orient(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bone_parentsbe-array-object" title="bone_parents(be: array) -&gt; object" class="md-nav__link">
    bone_parents(be: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object" title="boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]" class="md-nav__link">
    boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_facetst-array-object" title="boundary_facets(t: array) -&gt; object" class="md-nav__link">
    boundary_facets(t: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_loopf-array-object" title="boundary_loop(f: array) -&gt; object" class="md-nav__link">
    boundary_loop(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxargs-kwargs" title="bounding_box(*args, **kwargs)" class="md-nav__link">
    bounding_box(*args, **kwargs)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-tupleobject-object" title="bounding_box(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-pad-float-tupleobject-object" title="bounding_box(v: array, pad: float) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array, pad: float) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_box_diagonalv-array-float" title="bounding_box_diagonal(v: array) -&gt; float" class="md-nav__link">
    bounding_box_diagonal(v: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centroidv-array-f-array-tupleobject" title="centroid(v: array, f: array) -&gt; Tuple[object]" class="md-nav__link">
    centroid(v: array, f: array) -&gt; Tuple[object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint" title="circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]" class="md-nav__link">
    circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique" title="EMAP #F*3 list of indices into E, mapping each directed edge to unique" class="md-nav__link">
    EMAP #F*3 list of indices into E, mapping each directed edge to unique
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ej-i" title="e=(j-&gt;i)" class="md-nav__link">
    e=(j-&gt;i)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circumradiusv-array-f-array-object" title="circumradius(v: array, f: array) -&gt; object" class="md-nav__link">
    circumradius(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#collapse_small_trianglesv-array-f-array-eps-float-object" title="collapse_small_triangles(v: array, f: array, eps: float) -&gt; object" class="md-nav__link">
    collapse_small_triangles(v: array, f: array, eps: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinityf-array-object" title="connect_boundary_to_infinity(f: array) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object" title="connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_indexf-array-inf_index-int-object" title="connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrixv-array-f-array-object" title="cotmatrix(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrix_entriesv-array-f-array-object" title="cotmatrix_entries(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix_entries(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object" title="crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object" title="crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object" title="crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge-e" title="edge e." class="md-nav__link">
    edge e.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object" title="crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_meshv-array-f-array-cuts-array-tupleobject-object" title="cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]" class="md-nav__link">
    cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object" title="cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object" class="md-nav__link">
    cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object" title="cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]" class="md-nav__link">
    cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object" title="decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_anglesv-array-t-array-tupleobject-object" title="dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_angles_intrinsicl-array-a-array-tupleobject-object" title="dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#directed_edge_parentse-array-object" title="directed_edge_parents(e: array) -&gt; object" class="md-nav__link">
    directed_edge_parents(e: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#doubleareav-array-f-array-object" title="doublearea(v: array, f: array) -&gt; object" class="md-nav__link">
    doublearea(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#earsf-array-tupleobject-object" title="ears(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    ears(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge_topologyv-array-f-array-tupleobject-object-object" title="edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edgesf-array-object" title="edges(f: array) -&gt; object" class="md-nav__link">
    edges(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristicf-array-int" title="euler_characteristic(f: array) -&gt; int" class="md-nav__link">
    euler_characteristic(f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristic_completev-array-f-array-int" title="euler_characteristic_complete(v: array, f: array) -&gt; int" class="md-nav__link">
    euler_characteristic_complete(v: array, f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object" title="exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object" class="md-nav__link">
    exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#face_componentsf-array-object" title="face_components(f: array) -&gt; object" class="md-nav__link">
    face_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fit_planev-array-tupleobject-object" title="fit_plane(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    fit_plane(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object" title="flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]" class="md-nav__link">
    flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it" title="cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it." class="md-nav__link">
    cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gaussian_curvaturev-array-f-array-object" title="gaussian_curvature(v: array, f: array) -&gt; object" class="md-nav__link">
    gaussian_curvature(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradv-array-f-array-uniform-bool-false-object" title="grad(v: array, f: array, uniform: bool = False) -&gt; object" class="md-nav__link">
    grad(v: array, f: array, uniform: bool = False) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a" title="grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A" class="md-nav__link">
    grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonicl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-b-array-bc-array-k-int-object" title="harmonic(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object" title="harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object" class="md-nav__link">
    harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object" title="harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object" title="harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hausdorffva-array-fa-array-vb-array-fb-array-float" title="hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float" class="md-nav__link">
    hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aa-bb-bb-aa" title="a∈A b∈B          b∈B a∈A" class="md-nav__link">
    a∈A b∈B          b∈B a∈A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#internal_anglesv-array-f-array-object" title="internal_angles(v: array, f: array) -&gt; object" class="md-nav__link">
    internal_angles(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_edge_manifoldf-array-bool" title="is_edge_manifold(f: array) -&gt; bool" class="md-nav__link">
    is_edge_manifold(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool" title="is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;" class="md-nav__link">
    is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#isolinesv-array-f-array-z-array-n-int-tupleobject-object" title="isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lscmv-array-f-array-b-array-bc-array-tuplebool-object" title="lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]" class="md-nav__link">
    lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#map_vertices_to_circlev-array-bnd-array-object" title="map_vertices_to_circle(v: array, bnd: array) -&gt; object" class="md-nav__link">
    map_vertices_to_circle(v: array, bnd: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#massmatrixv-array-f-array-type-int-1-object" title="massmatrix(v: array, f: array, type: int = 1) -&gt; object" class="md-nav__link">
    massmatrix(v: array, f: array, type: int = 1) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object" title="min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object" class="md-nav__link">
    min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#orientable_patchesf-array-tupleobject-object" title="orientable_patches(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    orientable_patches(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oriented_facetsf-array-object" title="oriented_facets(f: array) -&gt; object" class="md-nav__link">
    oriented_facets(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object" title="per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsv-array-f-array-z-array-object" title="per_face_normals(v: array, f: array, z: array) -&gt; object" class="md-nav__link">
    per_face_normals(v: array, f: array, z: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsvfvector3d111normalizedn" title="per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);" class="md-nav__link">
    per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_attribute_smoothingain-array-f-array-object" title="per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object" class="md-nav__link">
    per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_normalsv-array-f-array-weighting-int-0-object" title="per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object" class="md-nav__link">
    per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#piecewise_constant_winding_numberf-array-bool" title="piecewise_constant_winding_number(f: array) -&gt; bool" class="md-nav__link">
    piecewise_constant_winding_number(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object" title="principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#procrustesx-array-y-array-tuplebool-bool-float-object-object" title="procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]" class="md-nav__link">
    procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object" title="qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quad_planarityv-array-f-array-object" title="quad_planarity(v: array, f: array) -&gt; object" class="md-nav__link">
    quad_planarity(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#random_points_on_meshn-int-v-array-f-array-tupleobject-object" title="random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object" title="read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object" class="md-nav__link">
    read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object" title="read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]" class="md-nav__link">
    read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object" title="read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]" class="md-nav__link">
    read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object" title="read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object" title="remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object" title="remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]" class="md-nav__link">
    remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_unreferencedv-array-f-array-tupleobject-object-object-object" title="remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#resolve_duplicated_facesf1-array-tupleobject-object" title="resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]" class="md-nav__link">
    resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_1" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_2" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of" title="If the number of postively oriented faces differ with the number of" class="md-nav__link">
    If the number of postively oriented faces differ with the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object" title="shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sort_anglesm-array-object" title="sort_angles(m: array) -&gt; object" class="md-nav__link">
    sort_angles(m: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object" title="tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]" class="md-nav__link">
    tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangle_triangle_adjacencyf-array-tupleobject-object" title="triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object" title="triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object" title="uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object" title="uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unprojectwin-array-model-array-proj-array-viewport-array-object" title="unproject(win: array, model: array, proj: array, viewport: array) -&gt; object" class="md-nav__link">
    unproject(win: array, model: array, proj: array, viewport: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit" title="unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]" class="md-nav__link">
    unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object" title="unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]" class="md-nav__link">
    unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object" title="unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]" class="md-nav__link">
    unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object" title="upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]" class="md-nav__link">
    upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector_area_matrixf-array-object" title="vector_area_matrix(f: array) -&gt; object" class="md-nav__link">
    vector_area_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_componentsf-array-object" title="vertex_components(f: array) -&gt; object" class="md-nav__link">
    vertex_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object" title="vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_triangle_adjacencyf-array-n-int-tupleobject-object" title="vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_numberv-array-f-array-o-array-object" title="winding_number(v: array, f: array, o: array) -&gt; object" class="md-nav__link">
    winding_number(v: array, f: array, o: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_number_for_pointv-array-f-array-p-array-float" title="winding_number_for_point(v: array, f: array, p: array) -&gt; float" class="md-nav__link">
    winding_number_for_point(v: array, f: array, p: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_objfilename-str-v-array-f-array-bool" title="write_obj(filename: str, v: array, f: array) -&gt; bool" class="md-nav__link">
    write_obj(filename: str, v: array, f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_offstr-str-v-array-f-array-c-array-bool" title="write_off(str: str, v: array, f: array, c: array) -&gt; bool" class="md-nav__link">
    write_off(str: str, v: array, f: array, c: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool" title="write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool" class="md-nav__link">
    write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency_listf-array-handle_1" title="adjacency_list(f: array) -&gt; handle" class="md-nav__link">
    adjacency_list(f: array) -&gt; handle
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency_listf-array-handle_2" title="adjacency_list(f: array) -&gt; handle" class="md-nav__link">
    adjacency_list(f: array) -&gt; handle
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency_matrixf-array-object_1" title="adjacency_matrix(f: array) -&gt; object" class="md-nav__link">
    adjacency_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency_matrixf-array-object_2" title="adjacency_matrix(f: array) -&gt; object" class="md-nav__link">
    adjacency_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object_1" title="ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object_2" title="ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_blockv-array-f-array-d-int-energy-int-object_1" title="arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_blockv-array-f-array-d-int-energy-int-object_2" title="arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_elementsv-array-f-array-d-int-object_1" title="arap_linear_block_elements(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_elements(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_elementsv-array-f-array-d-int-object_2" title="arap_linear_block_elements(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_elements(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokesv-array-f-array-d-int-object_1" title="arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokesv-array-f-array-d-int-object_2" title="arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object_1" title="arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object_2" title="arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_rhsv-array-f-array-d-int-energy-int-object_1" title="arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_rhsv-array-f-array-d-int-energy-int-object_2" title="arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#average_onto_verticesv-array-f-array-s-array-object_1" title="average_onto_vertices(v: array, f: array, s: array) -&gt; object" class="md-nav__link">
    average_onto_vertices(v: array, f: array, s: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#average_onto_verticesv-array-f-array-s-array-object_2" title="average_onto_vertices(v: array, f: array, s: array) -&gt; object" class="md-nav__link">
    average_onto_vertices(v: array, f: array, s: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avg_edge_lengthv-array-f-array-float_1" title="avg_edge_length(v: array, f: array) -&gt; float" class="md-nav__link">
    avg_edge_length(v: array, f: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avg_edge_lengthv-array-f-array-float_2" title="avg_edge_length(v: array, f: array) -&gt; float" class="md-nav__link">
    avg_edge_length(v: array, f: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycenterv-array-f-array-object_1" title="barycenter(v: array, f: array) -&gt; object" class="md-nav__link">
    barycenter(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycenterv-array-f-array-object_2" title="barycenter(v: array, f: array) -&gt; object" class="md-nav__link">
    barycenter(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object_1" title="barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object_2" title="barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_trip-array-a-array-b-array-c-array-object_1" title="barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_trip-array-a-array-b-array-c-array-object_2" title="barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object_1" title="bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object_2" title="bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfs_orientf-array-tupleobject-object_1" title="bfs_orient(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs_orient(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfs_orientf-array-tupleobject-object_2" title="bfs_orient(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs_orient(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bone_parentsbe-array-object_1" title="bone_parents(be: array) -&gt; object" class="md-nav__link">
    bone_parents(be: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bone_parentsbe-array-object_2" title="bone_parents(be: array) -&gt; object" class="md-nav__link">
    bone_parents(be: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object_1" title="boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]" class="md-nav__link">
    boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object_2" title="boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]" class="md-nav__link">
    boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_facetst-array-object_1" title="boundary_facets(t: array) -&gt; object" class="md-nav__link">
    boundary_facets(t: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_facetst-array-object_2" title="boundary_facets(t: array) -&gt; object" class="md-nav__link">
    boundary_facets(t: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_loopf-array-object_1" title="boundary_loop(f: array) -&gt; object" class="md-nav__link">
    boundary_loop(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_loopf-array-object_2" title="boundary_loop(f: array) -&gt; object" class="md-nav__link">
    boundary_loop(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxargs-kwargs_1" title="bounding_box(*args, **kwargs)" class="md-nav__link">
    bounding_box(*args, **kwargs)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-tupleobject-object_1" title="bounding_box(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-pad-float-tupleobject-object_1" title="bounding_box(v: array, pad: float) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array, pad: float) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxargs-kwargs_2" title="bounding_box(*args, **kwargs)" class="md-nav__link">
    bounding_box(*args, **kwargs)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-tupleobject-object_2" title="bounding_box(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-pad-float-tupleobject-object_2" title="bounding_box(v: array, pad: float) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array, pad: float) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_box_diagonalv-array-float_1" title="bounding_box_diagonal(v: array) -&gt; float" class="md-nav__link">
    bounding_box_diagonal(v: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_box_diagonalv-array-float_2" title="bounding_box_diagonal(v: array) -&gt; float" class="md-nav__link">
    bounding_box_diagonal(v: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centroidv-array-f-array-tupleobject_1" title="centroid(v: array, f: array) -&gt; Tuple[object]" class="md-nav__link">
    centroid(v: array, f: array) -&gt; Tuple[object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centroidv-array-f-array-tupleobject_2" title="centroid(v: array, f: array) -&gt; Tuple[object]" class="md-nav__link">
    centroid(v: array, f: array) -&gt; Tuple[object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint_1" title="circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]" class="md-nav__link">
    circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique_1" title="EMAP #F*3 list of indices into E, mapping each directed edge to unique" class="md-nav__link">
    EMAP #F*3 list of indices into E, mapping each directed edge to unique
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ej-i_1" title="e=(j-&gt;i)" class="md-nav__link">
    e=(j-&gt;i)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint_2" title="circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]" class="md-nav__link">
    circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique_2" title="EMAP #F*3 list of indices into E, mapping each directed edge to unique" class="md-nav__link">
    EMAP #F*3 list of indices into E, mapping each directed edge to unique
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ej-i_2" title="e=(j-&gt;i)" class="md-nav__link">
    e=(j-&gt;i)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circumradiusv-array-f-array-object_1" title="circumradius(v: array, f: array) -&gt; object" class="md-nav__link">
    circumradius(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circumradiusv-array-f-array-object_2" title="circumradius(v: array, f: array) -&gt; object" class="md-nav__link">
    circumradius(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#collapse_small_trianglesv-array-f-array-eps-float-object_1" title="collapse_small_triangles(v: array, f: array, eps: float) -&gt; object" class="md-nav__link">
    collapse_small_triangles(v: array, f: array, eps: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#collapse_small_trianglesv-array-f-array-eps-float-object_2" title="collapse_small_triangles(v: array, f: array, eps: float) -&gt; object" class="md-nav__link">
    collapse_small_triangles(v: array, f: array, eps: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinityf-array-object_1" title="connect_boundary_to_infinity(f: array) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinityf-array-object_2" title="connect_boundary_to_infinity(f: array) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object_1" title="connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object_2" title="connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_indexf-array-inf_index-int-object_1" title="connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_indexf-array-inf_index-int-object_2" title="connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrixv-array-f-array-object_1" title="cotmatrix(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrixv-array-f-array-object_2" title="cotmatrix(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrix_entriesv-array-f-array-object_1" title="cotmatrix_entries(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix_entries(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrix_entriesv-array-f-array-object_2" title="cotmatrix_entries(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix_entries(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object_1" title="crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object_2" title="crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object_1" title="crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object_2" title="crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object_1" title="crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge-e_1" title="edge e." class="md-nav__link">
    edge e.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object_2" title="crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge-e_2" title="edge e." class="md-nav__link">
    edge e.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object_1" title="crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object_2" title="crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_meshv-array-f-array-cuts-array-tupleobject-object_1" title="cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]" class="md-nav__link">
    cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_meshv-array-f-array-cuts-array-tupleobject-object_2" title="cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]" class="md-nav__link">
    cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object_1" title="cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object" class="md-nav__link">
    cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object_2" title="cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object" class="md-nav__link">
    cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object_1" title="cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]" class="md-nav__link">
    cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object_2" title="cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]" class="md-nav__link">
    cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object_1" title="decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object_2" title="decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_anglesv-array-t-array-tupleobject-object_1" title="dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_anglesv-array-t-array-tupleobject-object_2" title="dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_angles_intrinsicl-array-a-array-tupleobject-object_1" title="dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_angles_intrinsicl-array-a-array-tupleobject-object_2" title="dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#directed_edge_parentse-array-object_1" title="directed_edge_parents(e: array) -&gt; object" class="md-nav__link">
    directed_edge_parents(e: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#directed_edge_parentse-array-object_2" title="directed_edge_parents(e: array) -&gt; object" class="md-nav__link">
    directed_edge_parents(e: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#doubleareav-array-f-array-object_1" title="doublearea(v: array, f: array) -&gt; object" class="md-nav__link">
    doublearea(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#doubleareav-array-f-array-object_2" title="doublearea(v: array, f: array) -&gt; object" class="md-nav__link">
    doublearea(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#earsf-array-tupleobject-object_1" title="ears(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    ears(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#earsf-array-tupleobject-object_2" title="ears(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    ears(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge_topologyv-array-f-array-tupleobject-object-object_1" title="edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge_topologyv-array-f-array-tupleobject-object-object_2" title="edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edgesf-array-object_1" title="edges(f: array) -&gt; object" class="md-nav__link">
    edges(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edgesf-array-object_2" title="edges(f: array) -&gt; object" class="md-nav__link">
    edges(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristicf-array-int_1" title="euler_characteristic(f: array) -&gt; int" class="md-nav__link">
    euler_characteristic(f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristicf-array-int_2" title="euler_characteristic(f: array) -&gt; int" class="md-nav__link">
    euler_characteristic(f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristic_completev-array-f-array-int_1" title="euler_characteristic_complete(v: array, f: array) -&gt; int" class="md-nav__link">
    euler_characteristic_complete(v: array, f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristic_completev-array-f-array-int_2" title="euler_characteristic_complete(v: array, f: array) -&gt; int" class="md-nav__link">
    euler_characteristic_complete(v: array, f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object_1" title="exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object" class="md-nav__link">
    exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object_2" title="exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object" class="md-nav__link">
    exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#face_componentsf-array-object_1" title="face_components(f: array) -&gt; object" class="md-nav__link">
    face_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#face_componentsf-array-object_2" title="face_components(f: array) -&gt; object" class="md-nav__link">
    face_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fit_planev-array-tupleobject-object_1" title="fit_plane(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    fit_plane(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fit_planev-array-tupleobject-object_2" title="fit_plane(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    fit_plane(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object_1" title="flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]" class="md-nav__link">
    flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it_1" title="cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it." class="md-nav__link">
    cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object_2" title="flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]" class="md-nav__link">
    flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it_2" title="cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it." class="md-nav__link">
    cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gaussian_curvaturev-array-f-array-object_1" title="gaussian_curvature(v: array, f: array) -&gt; object" class="md-nav__link">
    gaussian_curvature(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gaussian_curvaturev-array-f-array-object_2" title="gaussian_curvature(v: array, f: array) -&gt; object" class="md-nav__link">
    gaussian_curvature(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradv-array-f-array-uniform-bool-false-object_1" title="grad(v: array, f: array, uniform: bool = False) -&gt; object" class="md-nav__link">
    grad(v: array, f: array, uniform: bool = False) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_1" title="grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A" class="md-nav__link">
    grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradv-array-f-array-uniform-bool-false-object_2" title="grad(v: array, f: array, uniform: bool = False) -&gt; object" class="md-nav__link">
    grad(v: array, f: array, uniform: bool = False) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_2" title="grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A" class="md-nav__link">
    grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradv-array-f-array-uniform-bool-false-object_3" title="grad(v: array, f: array, uniform: bool = False) -&gt; object" class="md-nav__link">
    grad(v: array, f: array, uniform: bool = False) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_3" title="grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A" class="md-nav__link">
    grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object_1" title="harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object" class="md-nav__link">
    harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object_2" title="harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object" class="md-nav__link">
    harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object_1" title="harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object_2" title="harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object_1" title="harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object_2" title="harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hausdorffva-array-fa-array-vb-array-fb-array-float_1" title="hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float" class="md-nav__link">
    hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aa-bb-bb-aa_1" title="a∈A b∈B          b∈B a∈A" class="md-nav__link">
    a∈A b∈B          b∈B a∈A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hausdorffva-array-fa-array-vb-array-fb-array-float_2" title="hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float" class="md-nav__link">
    hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aa-bb-bb-aa_2" title="a∈A b∈B          b∈B a∈A" class="md-nav__link">
    a∈A b∈B          b∈B a∈A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#internal_anglesv-array-f-array-object_1" title="internal_angles(v: array, f: array) -&gt; object" class="md-nav__link">
    internal_angles(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#internal_anglesv-array-f-array-object_2" title="internal_angles(v: array, f: array) -&gt; object" class="md-nav__link">
    internal_angles(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_edge_manifoldf-array-bool_1" title="is_edge_manifold(f: array) -&gt; bool" class="md-nav__link">
    is_edge_manifold(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_edge_manifoldf-array-bool_2" title="is_edge_manifold(f: array) -&gt; bool" class="md-nav__link">
    is_edge_manifold(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool_1" title="is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;" class="md-nav__link">
    is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool_2" title="is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;" class="md-nav__link">
    is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#isolinesv-array-f-array-z-array-n-int-tupleobject-object_1" title="isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#isolinesv-array-f-array-z-array-n-int-tupleobject-object_2" title="isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lscmv-array-f-array-b-array-bc-array-tuplebool-object_1" title="lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]" class="md-nav__link">
    lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lscmv-array-f-array-b-array-bc-array-tuplebool-object_2" title="lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]" class="md-nav__link">
    lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#massmatrixv-array-f-array-type-int-1-object_1" title="massmatrix(v: array, f: array, type: int = 1) -&gt; object" class="md-nav__link">
    massmatrix(v: array, f: array, type: int = 1) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#massmatrixv-array-f-array-type-int-1-object_2" title="massmatrix(v: array, f: array, type: int = 1) -&gt; object" class="md-nav__link">
    massmatrix(v: array, f: array, type: int = 1) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object_1" title="min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object" class="md-nav__link">
    min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object_2" title="min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object" class="md-nav__link">
    min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#orientable_patchesf-array-tupleobject-object_1" title="orientable_patches(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    orientable_patches(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#orientable_patchesf-array-tupleobject-object_2" title="orientable_patches(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    orientable_patches(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oriented_facetsf-array-object_1" title="oriented_facets(f: array) -&gt; object" class="md-nav__link">
    oriented_facets(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oriented_facetsf-array-object_2" title="oriented_facets(f: array) -&gt; object" class="md-nav__link">
    oriented_facets(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object_1" title="per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object_2" title="per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsv-array-f-array-z-array-object_1" title="per_face_normals(v: array, f: array, z: array) -&gt; object" class="md-nav__link">
    per_face_normals(v: array, f: array, z: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsvfvector3d111normalizedn_1" title="per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);" class="md-nav__link">
    per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsv-array-f-array-z-array-object_2" title="per_face_normals(v: array, f: array, z: array) -&gt; object" class="md-nav__link">
    per_face_normals(v: array, f: array, z: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsvfvector3d111normalizedn_2" title="per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);" class="md-nav__link">
    per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsv-array-f-array-z-array-object_3" title="per_face_normals(v: array, f: array, z: array) -&gt; object" class="md-nav__link">
    per_face_normals(v: array, f: array, z: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsvfvector3d111normalizedn_3" title="per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);" class="md-nav__link">
    per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_attribute_smoothingain-array-f-array-object_1" title="per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object" class="md-nav__link">
    per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_attribute_smoothingain-array-f-array-object_2" title="per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object" class="md-nav__link">
    per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_normalsv-array-f-array-weighting-int-0-object_1" title="per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object" class="md-nav__link">
    per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_normalsv-array-f-array-weighting-int-0-object_2" title="per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object" class="md-nav__link">
    per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#piecewise_constant_winding_numberf-array-bool_1" title="piecewise_constant_winding_number(f: array) -&gt; bool" class="md-nav__link">
    piecewise_constant_winding_number(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#piecewise_constant_winding_numberf-array-bool_2" title="piecewise_constant_winding_number(f: array) -&gt; bool" class="md-nav__link">
    piecewise_constant_winding_number(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object_1" title="principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object_2" title="principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#procrustesx-array-y-array-tuplebool-bool-float-object-object_1" title="procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]" class="md-nav__link">
    procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#procrustesx-array-y-array-tuplebool-bool-float-object-object_2" title="procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]" class="md-nav__link">
    procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object_1" title="qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object_2" title="qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quad_planarityv-array-f-array-object_1" title="quad_planarity(v: array, f: array) -&gt; object" class="md-nav__link">
    quad_planarity(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quad_planarityv-array-f-array-object_2" title="quad_planarity(v: array, f: array) -&gt; object" class="md-nav__link">
    quad_planarity(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#random_points_on_meshn-int-v-array-f-array-tupleobject-object_1" title="random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#random_points_on_meshn-int-v-array-f-array-tupleobject-object_2" title="random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object_1" title="read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object" class="md-nav__link">
    read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object_2" title="read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object" class="md-nav__link">
    read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object_1" title="read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]" class="md-nav__link">
    read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object_2" title="read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]" class="md-nav__link">
    read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object_1" title="read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]" class="md-nav__link">
    read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object_2" title="read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]" class="md-nav__link">
    read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object_1" title="read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object_2" title="read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object_1" title="remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object_2" title="remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object_1" title="remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]" class="md-nav__link">
    remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object_2" title="remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]" class="md-nav__link">
    remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_unreferencedv-array-f-array-tupleobject-object-object-object_1" title="remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_unreferencedv-array-f-array-tupleobject-object-object-object_2" title="remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#resolve_duplicated_facesf1-array-tupleobject-object_1" title="resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]" class="md-nav__link">
    resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_3" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_4" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_5" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of_1" title="If the number of postively oriented faces differ with the number of" class="md-nav__link">
    If the number of postively oriented faces differ with the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#resolve_duplicated_facesf1-array-tupleobject-object_2" title="resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]" class="md-nav__link">
    resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_6" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_7" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_8" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of_2" title="If the number of postively oriented faces differ with the number of" class="md-nav__link">
    If the number of postively oriented faces differ with the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object_1" title="shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object_2" title="shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sort_anglesm-array-object_1" title="sort_angles(m: array) -&gt; object" class="md-nav__link">
    sort_angles(m: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sort_anglesm-array-object_2" title="sort_angles(m: array) -&gt; object" class="md-nav__link">
    sort_angles(m: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object_1" title="tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]" class="md-nav__link">
    tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object_2" title="tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]" class="md-nav__link">
    tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangle_triangle_adjacencyf-array-tupleobject-object_1" title="triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangle_triangle_adjacencyf-array-tupleobject-object_2" title="triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object_1" title="triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object_2" title="triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object_1" title="uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object_2" title="uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object_1" title="uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object_2" title="uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unprojectwin-array-model-array-proj-array-viewport-array-object_1" title="unproject(win: array, model: array, proj: array, viewport: array) -&gt; object" class="md-nav__link">
    unproject(win: array, model: array, proj: array, viewport: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unprojectwin-array-model-array-proj-array-viewport-array-object_2" title="unproject(win: array, model: array, proj: array, viewport: array) -&gt; object" class="md-nav__link">
    unproject(win: array, model: array, proj: array, viewport: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit_1" title="unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]" class="md-nav__link">
    unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit_2" title="unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]" class="md-nav__link">
    unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object_1" title="unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]" class="md-nav__link">
    unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object_2" title="unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]" class="md-nav__link">
    unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object_1" title="unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]" class="md-nav__link">
    unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object_2" title="unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]" class="md-nav__link">
    unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object_1" title="upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]" class="md-nav__link">
    upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object_2" title="upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]" class="md-nav__link">
    upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector_area_matrixf-array-object_1" title="vector_area_matrix(f: array) -&gt; object" class="md-nav__link">
    vector_area_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector_area_matrixf-array-object_2" title="vector_area_matrix(f: array) -&gt; object" class="md-nav__link">
    vector_area_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_componentsf-array-object_1" title="vertex_components(f: array) -&gt; object" class="md-nav__link">
    vertex_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_componentsf-array-object_2" title="vertex_components(f: array) -&gt; object" class="md-nav__link">
    vertex_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object_1" title="vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object_2" title="vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_triangle_adjacencyf-array-n-int-tupleobject-object_1" title="vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_triangle_adjacencyf-array-n-int-tupleobject-object_2" title="vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_numberv-array-f-array-o-array-object_1" title="winding_number(v: array, f: array, o: array) -&gt; object" class="md-nav__link">
    winding_number(v: array, f: array, o: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_numberv-array-f-array-o-array-object_2" title="winding_number(v: array, f: array, o: array) -&gt; object" class="md-nav__link">
    winding_number(v: array, f: array, o: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_number_for_pointv-array-f-array-p-array-float_1" title="winding_number_for_point(v: array, f: array, p: array) -&gt; float" class="md-nav__link">
    winding_number_for_point(v: array, f: array, p: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_number_for_pointv-array-f-array-p-array-float_2" title="winding_number_for_point(v: array, f: array, p: array) -&gt; float" class="md-nav__link">
    winding_number_for_point(v: array, f: array, p: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_objfilename-str-v-array-f-array-bool_1" title="write_obj(filename: str, v: array, f: array) -&gt; bool" class="md-nav__link">
    write_obj(filename: str, v: array, f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_objfilename-str-v-array-f-array-bool_2" title="write_obj(filename: str, v: array, f: array) -&gt; bool" class="md-nav__link">
    write_obj(filename: str, v: array, f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_offstr-str-v-array-f-array-c-array-bool_1" title="write_off(str: str, v: array, f: array, c: array) -&gt; bool" class="md-nav__link">
    write_off(str: str, v: array, f: array, c: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_offstr-str-v-array-f-array-c-array-bool_2" title="write_off(str: str, v: array, f: array, c: array) -&gt; bool" class="md-nav__link">
    write_off(str: str, v: array, f: array, c: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool_1" title="write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool" class="md-nav__link">
    write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool_2" title="write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool" class="md-nav__link">
    write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#solve-iglpyigl_classesarap-arg0-numpyndarray-arg1-numpyndarray-object" title="solve(: igl.pyigl_classes.ARAP, arg0: numpy.ndarray, arg1: numpy.ndarray) -&gt; object" class="md-nav__link">
    solve(: igl.pyigl_classes.ARAP, arg0: numpy.ndarray, arg1: numpy.ndarray) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#solve-iglpyigl_classesbbw-arg0-numpyndarray-arg1-numpyndarray-arg2-numpyndarrayint32m-1-arg3-numpyndarray-object" title="solve(: igl.pyigl_classes.BBW, arg0: numpy.ndarray, arg1: numpy.ndarray, arg2: numpy.ndarray[int32[m, 1]], arg3: numpy.ndarray) -&gt; object" class="md-nav__link">
    solve(: igl.pyigl_classes.BBW, arg0: numpy.ndarray, arg1: numpy.ndarray, arg2: numpy.ndarray[int32[m, 1]], arg3: numpy.ndarray) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#energy-iglpyigl_classesslim-float" title="energy(: igl.pyigl_classes.SLIM) -&gt; float" class="md-nav__link">
    energy(: igl.pyigl_classes.SLIM) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#solve-iglpyigl_classesslim-arg0-int" title="solve(: igl.pyigl_classes.SLIM, arg0: int)" class="md-nav__link">
    solve(: igl.pyigl_classes.SLIM, arg0: int)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertices-iglpyigl_classesslim-object" title="vertices(: igl.pyigl_classes.SLIM) -&gt; object" class="md-nav__link">
    vertices(: igl.pyigl_classes.SLIM) -&gt; object
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#adjacency_listf-array-handle" title="adjacency_list(f: array) -&gt; handle" class="md-nav__link">
    adjacency_list(f: array) -&gt; handle
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency_matrixf-array-object" title="adjacency_matrix(f: array) -&gt; object" class="md-nav__link">
    adjacency_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object" title="ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_blockv-array-f-array-d-int-energy-int-object" title="arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_elementsv-array-f-array-d-int-object" title="arap_linear_block_elements(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_elements(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokesv-array-f-array-d-int-object" title="arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object" title="arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_rhsv-array-f-array-d-int-energy-int-object" title="arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#average_onto_verticesv-array-f-array-s-array-object" title="average_onto_vertices(v: array, f: array, s: array) -&gt; object" class="md-nav__link">
    average_onto_vertices(v: array, f: array, s: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avg_edge_lengthv-array-f-array-float" title="avg_edge_length(v: array, f: array) -&gt; float" class="md-nav__link">
    avg_edge_length(v: array, f: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycenterv-array-f-array-object" title="barycenter(v: array, f: array) -&gt; object" class="md-nav__link">
    barycenter(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object" title="barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_trip-array-a-array-b-array-c-array-object" title="barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object" title="bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfs_orientf-array-tupleobject-object" title="bfs_orient(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs_orient(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bone_parentsbe-array-object" title="bone_parents(be: array) -&gt; object" class="md-nav__link">
    bone_parents(be: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object" title="boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]" class="md-nav__link">
    boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_facetst-array-object" title="boundary_facets(t: array) -&gt; object" class="md-nav__link">
    boundary_facets(t: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_loopf-array-object" title="boundary_loop(f: array) -&gt; object" class="md-nav__link">
    boundary_loop(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxargs-kwargs" title="bounding_box(*args, **kwargs)" class="md-nav__link">
    bounding_box(*args, **kwargs)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-tupleobject-object" title="bounding_box(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-pad-float-tupleobject-object" title="bounding_box(v: array, pad: float) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array, pad: float) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_box_diagonalv-array-float" title="bounding_box_diagonal(v: array) -&gt; float" class="md-nav__link">
    bounding_box_diagonal(v: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centroidv-array-f-array-tupleobject" title="centroid(v: array, f: array) -&gt; Tuple[object]" class="md-nav__link">
    centroid(v: array, f: array) -&gt; Tuple[object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint" title="circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]" class="md-nav__link">
    circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique" title="EMAP #F*3 list of indices into E, mapping each directed edge to unique" class="md-nav__link">
    EMAP #F*3 list of indices into E, mapping each directed edge to unique
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ej-i" title="e=(j-&gt;i)" class="md-nav__link">
    e=(j-&gt;i)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circumradiusv-array-f-array-object" title="circumradius(v: array, f: array) -&gt; object" class="md-nav__link">
    circumradius(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#collapse_small_trianglesv-array-f-array-eps-float-object" title="collapse_small_triangles(v: array, f: array, eps: float) -&gt; object" class="md-nav__link">
    collapse_small_triangles(v: array, f: array, eps: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinityf-array-object" title="connect_boundary_to_infinity(f: array) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object" title="connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_indexf-array-inf_index-int-object" title="connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrixv-array-f-array-object" title="cotmatrix(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrix_entriesv-array-f-array-object" title="cotmatrix_entries(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix_entries(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object" title="crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object" title="crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object" title="crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge-e" title="edge e." class="md-nav__link">
    edge e.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object" title="crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_meshv-array-f-array-cuts-array-tupleobject-object" title="cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]" class="md-nav__link">
    cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object" title="cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object" class="md-nav__link">
    cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object" title="cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]" class="md-nav__link">
    cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object" title="decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_anglesv-array-t-array-tupleobject-object" title="dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_angles_intrinsicl-array-a-array-tupleobject-object" title="dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#directed_edge_parentse-array-object" title="directed_edge_parents(e: array) -&gt; object" class="md-nav__link">
    directed_edge_parents(e: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#doubleareav-array-f-array-object" title="doublearea(v: array, f: array) -&gt; object" class="md-nav__link">
    doublearea(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#earsf-array-tupleobject-object" title="ears(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    ears(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge_topologyv-array-f-array-tupleobject-object-object" title="edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edgesf-array-object" title="edges(f: array) -&gt; object" class="md-nav__link">
    edges(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristicf-array-int" title="euler_characteristic(f: array) -&gt; int" class="md-nav__link">
    euler_characteristic(f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristic_completev-array-f-array-int" title="euler_characteristic_complete(v: array, f: array) -&gt; int" class="md-nav__link">
    euler_characteristic_complete(v: array, f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object" title="exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object" class="md-nav__link">
    exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#face_componentsf-array-object" title="face_components(f: array) -&gt; object" class="md-nav__link">
    face_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fit_planev-array-tupleobject-object" title="fit_plane(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    fit_plane(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object" title="flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]" class="md-nav__link">
    flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it" title="cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it." class="md-nav__link">
    cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gaussian_curvaturev-array-f-array-object" title="gaussian_curvature(v: array, f: array) -&gt; object" class="md-nav__link">
    gaussian_curvature(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradv-array-f-array-uniform-bool-false-object" title="grad(v: array, f: array, uniform: bool = False) -&gt; object" class="md-nav__link">
    grad(v: array, f: array, uniform: bool = False) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a" title="grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A" class="md-nav__link">
    grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonicl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-b-array-bc-array-k-int-object" title="harmonic(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object" title="harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object" class="md-nav__link">
    harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object" title="harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object" title="harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hausdorffva-array-fa-array-vb-array-fb-array-float" title="hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float" class="md-nav__link">
    hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aa-bb-bb-aa" title="a∈A b∈B          b∈B a∈A" class="md-nav__link">
    a∈A b∈B          b∈B a∈A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#internal_anglesv-array-f-array-object" title="internal_angles(v: array, f: array) -&gt; object" class="md-nav__link">
    internal_angles(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_edge_manifoldf-array-bool" title="is_edge_manifold(f: array) -&gt; bool" class="md-nav__link">
    is_edge_manifold(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool" title="is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;" class="md-nav__link">
    is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#isolinesv-array-f-array-z-array-n-int-tupleobject-object" title="isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lscmv-array-f-array-b-array-bc-array-tuplebool-object" title="lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]" class="md-nav__link">
    lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#map_vertices_to_circlev-array-bnd-array-object" title="map_vertices_to_circle(v: array, bnd: array) -&gt; object" class="md-nav__link">
    map_vertices_to_circle(v: array, bnd: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#massmatrixv-array-f-array-type-int-1-object" title="massmatrix(v: array, f: array, type: int = 1) -&gt; object" class="md-nav__link">
    massmatrix(v: array, f: array, type: int = 1) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object" title="min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object" class="md-nav__link">
    min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#orientable_patchesf-array-tupleobject-object" title="orientable_patches(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    orientable_patches(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oriented_facetsf-array-object" title="oriented_facets(f: array) -&gt; object" class="md-nav__link">
    oriented_facets(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object" title="per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsv-array-f-array-z-array-object" title="per_face_normals(v: array, f: array, z: array) -&gt; object" class="md-nav__link">
    per_face_normals(v: array, f: array, z: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsvfvector3d111normalizedn" title="per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);" class="md-nav__link">
    per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_attribute_smoothingain-array-f-array-object" title="per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object" class="md-nav__link">
    per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_normalsv-array-f-array-weighting-int-0-object" title="per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object" class="md-nav__link">
    per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#piecewise_constant_winding_numberf-array-bool" title="piecewise_constant_winding_number(f: array) -&gt; bool" class="md-nav__link">
    piecewise_constant_winding_number(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object" title="principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#procrustesx-array-y-array-tuplebool-bool-float-object-object" title="procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]" class="md-nav__link">
    procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object" title="qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quad_planarityv-array-f-array-object" title="quad_planarity(v: array, f: array) -&gt; object" class="md-nav__link">
    quad_planarity(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#random_points_on_meshn-int-v-array-f-array-tupleobject-object" title="random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object" title="read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object" class="md-nav__link">
    read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object" title="read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]" class="md-nav__link">
    read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object" title="read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]" class="md-nav__link">
    read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object" title="read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object" title="remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object" title="remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]" class="md-nav__link">
    remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_unreferencedv-array-f-array-tupleobject-object-object-object" title="remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#resolve_duplicated_facesf1-array-tupleobject-object" title="resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]" class="md-nav__link">
    resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_1" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_2" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of" title="If the number of postively oriented faces differ with the number of" class="md-nav__link">
    If the number of postively oriented faces differ with the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object" title="shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sort_anglesm-array-object" title="sort_angles(m: array) -&gt; object" class="md-nav__link">
    sort_angles(m: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object" title="tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]" class="md-nav__link">
    tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangle_triangle_adjacencyf-array-tupleobject-object" title="triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object" title="triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object" title="uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object" title="uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unprojectwin-array-model-array-proj-array-viewport-array-object" title="unproject(win: array, model: array, proj: array, viewport: array) -&gt; object" class="md-nav__link">
    unproject(win: array, model: array, proj: array, viewport: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit" title="unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]" class="md-nav__link">
    unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object" title="unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]" class="md-nav__link">
    unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object" title="unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]" class="md-nav__link">
    unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object" title="upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]" class="md-nav__link">
    upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector_area_matrixf-array-object" title="vector_area_matrix(f: array) -&gt; object" class="md-nav__link">
    vector_area_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_componentsf-array-object" title="vertex_components(f: array) -&gt; object" class="md-nav__link">
    vertex_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object" title="vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_triangle_adjacencyf-array-n-int-tupleobject-object" title="vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_numberv-array-f-array-o-array-object" title="winding_number(v: array, f: array, o: array) -&gt; object" class="md-nav__link">
    winding_number(v: array, f: array, o: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_number_for_pointv-array-f-array-p-array-float" title="winding_number_for_point(v: array, f: array, p: array) -&gt; float" class="md-nav__link">
    winding_number_for_point(v: array, f: array, p: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_objfilename-str-v-array-f-array-bool" title="write_obj(filename: str, v: array, f: array) -&gt; bool" class="md-nav__link">
    write_obj(filename: str, v: array, f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_offstr-str-v-array-f-array-c-array-bool" title="write_off(str: str, v: array, f: array, c: array) -&gt; bool" class="md-nav__link">
    write_off(str: str, v: array, f: array, c: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool" title="write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool" class="md-nav__link">
    write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency_listf-array-handle_1" title="adjacency_list(f: array) -&gt; handle" class="md-nav__link">
    adjacency_list(f: array) -&gt; handle
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency_listf-array-handle_2" title="adjacency_list(f: array) -&gt; handle" class="md-nav__link">
    adjacency_list(f: array) -&gt; handle
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency_matrixf-array-object_1" title="adjacency_matrix(f: array) -&gt; object" class="md-nav__link">
    adjacency_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#adjacency_matrixf-array-object_2" title="adjacency_matrix(f: array) -&gt; object" class="md-nav__link">
    adjacency_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object_1" title="ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object_2" title="ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_blockv-array-f-array-d-int-energy-int-object_1" title="arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_blockv-array-f-array-d-int-energy-int-object_2" title="arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_elementsv-array-f-array-d-int-object_1" title="arap_linear_block_elements(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_elements(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_elementsv-array-f-array-d-int-object_2" title="arap_linear_block_elements(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_elements(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokesv-array-f-array-d-int-object_1" title="arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokesv-array-f-array-d-int-object_2" title="arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object_1" title="arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object_2" title="arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object" class="md-nav__link">
    arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_rhsv-array-f-array-d-int-energy-int-object_1" title="arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arap_rhsv-array-f-array-d-int-energy-int-object_2" title="arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object" class="md-nav__link">
    arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#average_onto_verticesv-array-f-array-s-array-object_1" title="average_onto_vertices(v: array, f: array, s: array) -&gt; object" class="md-nav__link">
    average_onto_vertices(v: array, f: array, s: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#average_onto_verticesv-array-f-array-s-array-object_2" title="average_onto_vertices(v: array, f: array, s: array) -&gt; object" class="md-nav__link">
    average_onto_vertices(v: array, f: array, s: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avg_edge_lengthv-array-f-array-float_1" title="avg_edge_length(v: array, f: array) -&gt; float" class="md-nav__link">
    avg_edge_length(v: array, f: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#avg_edge_lengthv-array-f-array-float_2" title="avg_edge_length(v: array, f: array) -&gt; float" class="md-nav__link">
    avg_edge_length(v: array, f: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycenterv-array-f-array-object_1" title="barycenter(v: array, f: array) -&gt; object" class="md-nav__link">
    barycenter(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycenterv-array-f-array-object_2" title="barycenter(v: array, f: array) -&gt; object" class="md-nav__link">
    barycenter(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object_1" title="barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object_2" title="barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_trip-array-a-array-b-array-c-array-object_1" title="barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#barycentric_coordinates_trip-array-a-array-b-array-c-array-object_2" title="barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object" class="md-nav__link">
    barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object_1" title="bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object_2" title="bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfs_orientf-array-tupleobject-object_1" title="bfs_orient(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs_orient(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bfs_orientf-array-tupleobject-object_2" title="bfs_orient(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bfs_orient(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bone_parentsbe-array-object_1" title="bone_parents(be: array) -&gt; object" class="md-nav__link">
    bone_parents(be: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bone_parentsbe-array-object_2" title="bone_parents(be: array) -&gt; object" class="md-nav__link">
    bone_parents(be: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object_1" title="boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]" class="md-nav__link">
    boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object_2" title="boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]" class="md-nav__link">
    boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_facetst-array-object_1" title="boundary_facets(t: array) -&gt; object" class="md-nav__link">
    boundary_facets(t: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_facetst-array-object_2" title="boundary_facets(t: array) -&gt; object" class="md-nav__link">
    boundary_facets(t: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_loopf-array-object_1" title="boundary_loop(f: array) -&gt; object" class="md-nav__link">
    boundary_loop(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary_loopf-array-object_2" title="boundary_loop(f: array) -&gt; object" class="md-nav__link">
    boundary_loop(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxargs-kwargs_1" title="bounding_box(*args, **kwargs)" class="md-nav__link">
    bounding_box(*args, **kwargs)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-tupleobject-object_1" title="bounding_box(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-pad-float-tupleobject-object_1" title="bounding_box(v: array, pad: float) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array, pad: float) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxargs-kwargs_2" title="bounding_box(*args, **kwargs)" class="md-nav__link">
    bounding_box(*args, **kwargs)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-tupleobject-object_2" title="bounding_box(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_boxv-array-pad-float-tupleobject-object_2" title="bounding_box(v: array, pad: float) -&gt; Tuple[object, object]" class="md-nav__link">
    bounding_box(v: array, pad: float) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_box_diagonalv-array-float_1" title="bounding_box_diagonal(v: array) -&gt; float" class="md-nav__link">
    bounding_box_diagonal(v: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bounding_box_diagonalv-array-float_2" title="bounding_box_diagonal(v: array) -&gt; float" class="md-nav__link">
    bounding_box_diagonal(v: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centroidv-array-f-array-tupleobject_1" title="centroid(v: array, f: array) -&gt; Tuple[object]" class="md-nav__link">
    centroid(v: array, f: array) -&gt; Tuple[object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#centroidv-array-f-array-tupleobject_2" title="centroid(v: array, f: array) -&gt; Tuple[object]" class="md-nav__link">
    centroid(v: array, f: array) -&gt; Tuple[object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint_1" title="circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]" class="md-nav__link">
    circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique_1" title="EMAP #F*3 list of indices into E, mapping each directed edge to unique" class="md-nav__link">
    EMAP #F*3 list of indices into E, mapping each directed edge to unique
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ej-i_1" title="e=(j-&gt;i)" class="md-nav__link">
    e=(j-&gt;i)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint_2" title="circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]" class="md-nav__link">
    circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique_2" title="EMAP #F*3 list of indices into E, mapping each directed edge to unique" class="md-nav__link">
    EMAP #F*3 list of indices into E, mapping each directed edge to unique
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ej-i_2" title="e=(j-&gt;i)" class="md-nav__link">
    e=(j-&gt;i)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circumradiusv-array-f-array-object_1" title="circumradius(v: array, f: array) -&gt; object" class="md-nav__link">
    circumradius(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#circumradiusv-array-f-array-object_2" title="circumradius(v: array, f: array) -&gt; object" class="md-nav__link">
    circumradius(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#collapse_small_trianglesv-array-f-array-eps-float-object_1" title="collapse_small_triangles(v: array, f: array, eps: float) -&gt; object" class="md-nav__link">
    collapse_small_triangles(v: array, f: array, eps: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#collapse_small_trianglesv-array-f-array-eps-float-object_2" title="collapse_small_triangles(v: array, f: array, eps: float) -&gt; object" class="md-nav__link">
    collapse_small_triangles(v: array, f: array, eps: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinityf-array-object_1" title="connect_boundary_to_infinity(f: array) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinityf-array-object_2" title="connect_boundary_to_infinity(f: array) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object_1" title="connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object_2" title="connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_indexf-array-inf_index-int-object_1" title="connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#connect_boundary_to_infinity_indexf-array-inf_index-int-object_2" title="connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object" class="md-nav__link">
    connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrixv-array-f-array-object_1" title="cotmatrix(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrixv-array-f-array-object_2" title="cotmatrix(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrix_entriesv-array-f-array-object_1" title="cotmatrix_entries(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix_entries(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cotmatrix_entriesv-array-f-array-object_2" title="cotmatrix_entries(v: array, f: array) -&gt; object" class="md-nav__link">
    cotmatrix_entries(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object_1" title="crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object_2" title="crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object_1" title="crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object_2" title="crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object_1" title="crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge-e_1" title="edge e." class="md-nav__link">
    edge e.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object_2" title="crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge-e_2" title="edge e." class="md-nav__link">
    edge e.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object_1" title="crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object_2" title="crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object" class="md-nav__link">
    crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_meshv-array-f-array-cuts-array-tupleobject-object_1" title="cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]" class="md-nav__link">
    cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_meshv-array-f-array-cuts-array-tupleobject-object_2" title="cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]" class="md-nav__link">
    cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object_1" title="cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object" class="md-nav__link">
    cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object_2" title="cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object" class="md-nav__link">
    cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object_1" title="cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]" class="md-nav__link">
    cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object_2" title="cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]" class="md-nav__link">
    cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object_1" title="decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object_2" title="decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_anglesv-array-t-array-tupleobject-object_1" title="dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_anglesv-array-t-array-tupleobject-object_2" title="dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_angles_intrinsicl-array-a-array-tupleobject-object_1" title="dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dihedral_angles_intrinsicl-array-a-array-tupleobject-object_2" title="dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]" class="md-nav__link">
    dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#directed_edge_parentse-array-object_1" title="directed_edge_parents(e: array) -&gt; object" class="md-nav__link">
    directed_edge_parents(e: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#directed_edge_parentse-array-object_2" title="directed_edge_parents(e: array) -&gt; object" class="md-nav__link">
    directed_edge_parents(e: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#doubleareav-array-f-array-object_1" title="doublearea(v: array, f: array) -&gt; object" class="md-nav__link">
    doublearea(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#doubleareav-array-f-array-object_2" title="doublearea(v: array, f: array) -&gt; object" class="md-nav__link">
    doublearea(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#earsf-array-tupleobject-object_1" title="ears(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    ears(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#earsf-array-tupleobject-object_2" title="ears(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    ears(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge_topologyv-array-f-array-tupleobject-object-object_1" title="edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edge_topologyv-array-f-array-tupleobject-object-object_2" title="edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edgesf-array-object_1" title="edges(f: array) -&gt; object" class="md-nav__link">
    edges(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#edgesf-array-object_2" title="edges(f: array) -&gt; object" class="md-nav__link">
    edges(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristicf-array-int_1" title="euler_characteristic(f: array) -&gt; int" class="md-nav__link">
    euler_characteristic(f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristicf-array-int_2" title="euler_characteristic(f: array) -&gt; int" class="md-nav__link">
    euler_characteristic(f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristic_completev-array-f-array-int_1" title="euler_characteristic_complete(v: array, f: array) -&gt; int" class="md-nav__link">
    euler_characteristic_complete(v: array, f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#euler_characteristic_completev-array-f-array-int_2" title="euler_characteristic_complete(v: array, f: array) -&gt; int" class="md-nav__link">
    euler_characteristic_complete(v: array, f: array) -&gt; int
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object_1" title="exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object" class="md-nav__link">
    exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object_2" title="exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object" class="md-nav__link">
    exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#face_componentsf-array-object_1" title="face_components(f: array) -&gt; object" class="md-nav__link">
    face_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#face_componentsf-array-object_2" title="face_components(f: array) -&gt; object" class="md-nav__link">
    face_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fit_planev-array-tupleobject-object_1" title="fit_plane(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    fit_plane(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#fit_planev-array-tupleobject-object_2" title="fit_plane(v: array) -&gt; Tuple[object, object]" class="md-nav__link">
    fit_plane(v: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object_1" title="flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]" class="md-nav__link">
    flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it_1" title="cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it." class="md-nav__link">
    cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object_2" title="flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]" class="md-nav__link">
    flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it_2" title="cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it." class="md-nav__link">
    cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it.
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gaussian_curvaturev-array-f-array-object_1" title="gaussian_curvature(v: array, f: array) -&gt; object" class="md-nav__link">
    gaussian_curvature(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gaussian_curvaturev-array-f-array-object_2" title="gaussian_curvature(v: array, f: array) -&gt; object" class="md-nav__link">
    gaussian_curvature(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradv-array-f-array-uniform-bool-false-object_1" title="grad(v: array, f: array, uniform: bool = False) -&gt; object" class="md-nav__link">
    grad(v: array, f: array, uniform: bool = False) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_1" title="grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A" class="md-nav__link">
    grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradv-array-f-array-uniform-bool-false-object_2" title="grad(v: array, f: array, uniform: bool = False) -&gt; object" class="md-nav__link">
    grad(v: array, f: array, uniform: bool = False) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_2" title="grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A" class="md-nav__link">
    grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradv-array-f-array-uniform-bool-false-object_3" title="grad(v: array, f: array, uniform: bool = False) -&gt; object" class="md-nav__link">
    grad(v: array, f: array, uniform: bool = False) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_3" title="grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A" class="md-nav__link">
    grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object_1" title="harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object" class="md-nav__link">
    harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object_2" title="harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object" class="md-nav__link">
    harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object_1" title="harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object_2" title="harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object_1" title="harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object_2" title="harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object" class="md-nav__link">
    harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hausdorffva-array-fa-array-vb-array-fb-array-float_1" title="hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float" class="md-nav__link">
    hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aa-bb-bb-aa_1" title="a∈A b∈B          b∈B a∈A" class="md-nav__link">
    a∈A b∈B          b∈B a∈A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hausdorffva-array-fa-array-vb-array-fb-array-float_2" title="hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float" class="md-nav__link">
    hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aa-bb-bb-aa_2" title="a∈A b∈B          b∈B a∈A" class="md-nav__link">
    a∈A b∈B          b∈B a∈A
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#internal_anglesv-array-f-array-object_1" title="internal_angles(v: array, f: array) -&gt; object" class="md-nav__link">
    internal_angles(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#internal_anglesv-array-f-array-object_2" title="internal_angles(v: array, f: array) -&gt; object" class="md-nav__link">
    internal_angles(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_edge_manifoldf-array-bool_1" title="is_edge_manifold(f: array) -&gt; bool" class="md-nav__link">
    is_edge_manifold(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_edge_manifoldf-array-bool_2" title="is_edge_manifold(f: array) -&gt; bool" class="md-nav__link">
    is_edge_manifold(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool_1" title="is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;" class="md-nav__link">
    is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool_2" title="is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;" class="md-nav__link">
    is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#isolinesv-array-f-array-z-array-n-int-tupleobject-object_1" title="isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#isolinesv-array-f-array-z-array-n-int-tupleobject-object_2" title="isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lscmv-array-f-array-b-array-bc-array-tuplebool-object_1" title="lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]" class="md-nav__link">
    lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lscmv-array-f-array-b-array-bc-array-tuplebool-object_2" title="lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]" class="md-nav__link">
    lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#massmatrixv-array-f-array-type-int-1-object_1" title="massmatrix(v: array, f: array, type: int = 1) -&gt; object" class="md-nav__link">
    massmatrix(v: array, f: array, type: int = 1) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#massmatrixv-array-f-array-type-int-1-object_2" title="massmatrix(v: array, f: array, type: int = 1) -&gt; object" class="md-nav__link">
    massmatrix(v: array, f: array, type: int = 1) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object_1" title="min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object" class="md-nav__link">
    min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object_2" title="min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object" class="md-nav__link">
    min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#orientable_patchesf-array-tupleobject-object_1" title="orientable_patches(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    orientable_patches(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#orientable_patchesf-array-tupleobject-object_2" title="orientable_patches(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    orientable_patches(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oriented_facetsf-array-object_1" title="oriented_facets(f: array) -&gt; object" class="md-nav__link">
    oriented_facets(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oriented_facetsf-array-object_2" title="oriented_facets(f: array) -&gt; object" class="md-nav__link">
    oriented_facets(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object_1" title="per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object_2" title="per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]" class="md-nav__link">
    per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsv-array-f-array-z-array-object_1" title="per_face_normals(v: array, f: array, z: array) -&gt; object" class="md-nav__link">
    per_face_normals(v: array, f: array, z: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsvfvector3d111normalizedn_1" title="per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);" class="md-nav__link">
    per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsv-array-f-array-z-array-object_2" title="per_face_normals(v: array, f: array, z: array) -&gt; object" class="md-nav__link">
    per_face_normals(v: array, f: array, z: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsvfvector3d111normalizedn_2" title="per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);" class="md-nav__link">
    per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsv-array-f-array-z-array-object_3" title="per_face_normals(v: array, f: array, z: array) -&gt; object" class="md-nav__link">
    per_face_normals(v: array, f: array, z: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_face_normalsvfvector3d111normalizedn_3" title="per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);" class="md-nav__link">
    per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_attribute_smoothingain-array-f-array-object_1" title="per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object" class="md-nav__link">
    per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_attribute_smoothingain-array-f-array-object_2" title="per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object" class="md-nav__link">
    per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_normalsv-array-f-array-weighting-int-0-object_1" title="per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object" class="md-nav__link">
    per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#per_vertex_normalsv-array-f-array-weighting-int-0-object_2" title="per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object" class="md-nav__link">
    per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#piecewise_constant_winding_numberf-array-bool_1" title="piecewise_constant_winding_number(f: array) -&gt; bool" class="md-nav__link">
    piecewise_constant_winding_number(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#piecewise_constant_winding_numberf-array-bool_2" title="piecewise_constant_winding_number(f: array) -&gt; bool" class="md-nav__link">
    piecewise_constant_winding_number(f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object_1" title="principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object_2" title="principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#procrustesx-array-y-array-tuplebool-bool-float-object-object_1" title="procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]" class="md-nav__link">
    procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#procrustesx-array-y-array-tuplebool-bool-float-object-object_2" title="procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]" class="md-nav__link">
    procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object_1" title="qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object_2" title="qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]" class="md-nav__link">
    qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quad_planarityv-array-f-array-object_1" title="quad_planarity(v: array, f: array) -&gt; object" class="md-nav__link">
    quad_planarity(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quad_planarityv-array-f-array-object_2" title="quad_planarity(v: array, f: array) -&gt; object" class="md-nav__link">
    quad_planarity(v: array, f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#random_points_on_meshn-int-v-array-f-array-tupleobject-object_1" title="random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#random_points_on_meshn-int-v-array-f-array-tupleobject-object_2" title="random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object_1" title="read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object" class="md-nav__link">
    read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object_2" title="read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object" class="md-nav__link">
    read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object_1" title="read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]" class="md-nav__link">
    read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object_2" title="read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]" class="md-nav__link">
    read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object_1" title="read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]" class="md-nav__link">
    read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object_2" title="read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]" class="md-nav__link">
    read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object_1" title="read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object_2" title="read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object_1" title="remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object_2" title="remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object_1" title="remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]" class="md-nav__link">
    remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object_2" title="remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]" class="md-nav__link">
    remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_unreferencedv-array-f-array-tupleobject-object-object-object_1" title="remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove_unreferencedv-array-f-array-tupleobject-object-object-object_2" title="remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]" class="md-nav__link">
    remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#resolve_duplicated_facesf1-array-tupleobject-object_1" title="resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]" class="md-nav__link">
    resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_3" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_4" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_5" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of_1" title="If the number of postively oriented faces differ with the number of" class="md-nav__link">
    If the number of postively oriented faces differ with the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#resolve_duplicated_facesf1-array-tupleobject-object_2" title="resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]" class="md-nav__link">
    resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_6" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_7" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_8" title="If the number of positively oriented faces equals the number of" class="md-nav__link">
    If the number of positively oriented faces equals the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of_2" title="If the number of postively oriented faces differ with the number of" class="md-nav__link">
    If the number of postively oriented faces differ with the number of
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object_1" title="shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object_2" title="shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object" class="md-nav__link">
    shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sort_anglesm-array-object_1" title="sort_angles(m: array) -&gt; object" class="md-nav__link">
    sort_angles(m: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sort_anglesm-array-object_2" title="sort_angles(m: array) -&gt; object" class="md-nav__link">
    sort_angles(m: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object_1" title="tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]" class="md-nav__link">
    tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object_2" title="tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]" class="md-nav__link">
    tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangle_triangle_adjacencyf-array-tupleobject-object_1" title="triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangle_triangle_adjacencyf-array-tupleobject-object_2" title="triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]" class="md-nav__link">
    triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object_1" title="triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object_2" title="triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]" class="md-nav__link">
    triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object_1" title="uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object_2" title="uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object_1" title="uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object_2" title="uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object" class="md-nav__link">
    uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unprojectwin-array-model-array-proj-array-viewport-array-object_1" title="unproject(win: array, model: array, proj: array, viewport: array) -&gt; object" class="md-nav__link">
    unproject(win: array, model: array, proj: array, viewport: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unprojectwin-array-model-array-proj-array-viewport-array-object_2" title="unproject(win: array, model: array, proj: array, viewport: array) -&gt; object" class="md-nav__link">
    unproject(win: array, model: array, proj: array, viewport: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit_1" title="unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]" class="md-nav__link">
    unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit_2" title="unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]" class="md-nav__link">
    unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object_1" title="unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]" class="md-nav__link">
    unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object_2" title="unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]" class="md-nav__link">
    unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object_1" title="unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]" class="md-nav__link">
    unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object_2" title="unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]" class="md-nav__link">
    unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object_1" title="upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]" class="md-nav__link">
    upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object_2" title="upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]" class="md-nav__link">
    upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector_area_matrixf-array-object_1" title="vector_area_matrix(f: array) -&gt; object" class="md-nav__link">
    vector_area_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector_area_matrixf-array-object_2" title="vector_area_matrix(f: array) -&gt; object" class="md-nav__link">
    vector_area_matrix(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_componentsf-array-object_1" title="vertex_components(f: array) -&gt; object" class="md-nav__link">
    vertex_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_componentsf-array-object_2" title="vertex_components(f: array) -&gt; object" class="md-nav__link">
    vertex_components(f: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object_1" title="vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object_2" title="vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_triangle_adjacencyf-array-n-int-tupleobject-object_1" title="vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertex_triangle_adjacencyf-array-n-int-tupleobject-object_2" title="vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]" class="md-nav__link">
    vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_numberv-array-f-array-o-array-object_1" title="winding_number(v: array, f: array, o: array) -&gt; object" class="md-nav__link">
    winding_number(v: array, f: array, o: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_numberv-array-f-array-o-array-object_2" title="winding_number(v: array, f: array, o: array) -&gt; object" class="md-nav__link">
    winding_number(v: array, f: array, o: array) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_number_for_pointv-array-f-array-p-array-float_1" title="winding_number_for_point(v: array, f: array, p: array) -&gt; float" class="md-nav__link">
    winding_number_for_point(v: array, f: array, p: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#winding_number_for_pointv-array-f-array-p-array-float_2" title="winding_number_for_point(v: array, f: array, p: array) -&gt; float" class="md-nav__link">
    winding_number_for_point(v: array, f: array, p: array) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_objfilename-str-v-array-f-array-bool_1" title="write_obj(filename: str, v: array, f: array) -&gt; bool" class="md-nav__link">
    write_obj(filename: str, v: array, f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_objfilename-str-v-array-f-array-bool_2" title="write_obj(filename: str, v: array, f: array) -&gt; bool" class="md-nav__link">
    write_obj(filename: str, v: array, f: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_offstr-str-v-array-f-array-c-array-bool_1" title="write_off(str: str, v: array, f: array, c: array) -&gt; bool" class="md-nav__link">
    write_off(str: str, v: array, f: array, c: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_offstr-str-v-array-f-array-c-array-bool_2" title="write_off(str: str, v: array, f: array, c: array) -&gt; bool" class="md-nav__link">
    write_off(str: str, v: array, f: array, c: array) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool_1" title="write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool" class="md-nav__link">
    write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool_2" title="write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool" class="md-nav__link">
    write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#solve-iglpyigl_classesarap-arg0-numpyndarray-arg1-numpyndarray-object" title="solve(: igl.pyigl_classes.ARAP, arg0: numpy.ndarray, arg1: numpy.ndarray) -&gt; object" class="md-nav__link">
    solve(: igl.pyigl_classes.ARAP, arg0: numpy.ndarray, arg1: numpy.ndarray) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#solve-iglpyigl_classesbbw-arg0-numpyndarray-arg1-numpyndarray-arg2-numpyndarrayint32m-1-arg3-numpyndarray-object" title="solve(: igl.pyigl_classes.BBW, arg0: numpy.ndarray, arg1: numpy.ndarray, arg2: numpy.ndarray[int32[m, 1]], arg3: numpy.ndarray) -&gt; object" class="md-nav__link">
    solve(: igl.pyigl_classes.BBW, arg0: numpy.ndarray, arg1: numpy.ndarray, arg2: numpy.ndarray[int32[m, 1]], arg3: numpy.ndarray) -&gt; object
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#energy-iglpyigl_classesslim-float" title="energy(: igl.pyigl_classes.SLIM) -&gt; float" class="md-nav__link">
    energy(: igl.pyigl_classes.SLIM) -&gt; float
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#solve-iglpyigl_classesslim-arg0-int" title="solve(: igl.pyigl_classes.SLIM, arg0: int)" class="md-nav__link">
    solve(: igl.pyigl_classes.SLIM, arg0: int)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertices-iglpyigl_classesslim-object" title="vertices(: igl.pyigl_classes.SLIM) -&gt; object" class="md-nav__link">
    vertices(: igl.pyigl_classes.SLIM) -&gt; object
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/geometryprocessing/libigl-python-bindings/edit/master/docs/igl_docs.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                  <h1>Docs</h1>
                
                <h3 id="adjacency_listf-array-handle"><strong><code class="codehilite">adjacency_list(f: array) -&gt; handle</code></strong><a class="headerlink" href="#adjacency_listf-array-handle" title="Permanent link">&para;</a></h3>
<p>Constructs the graph adjacency list of a given mesh (v, f)</p>
<p><strong>Parameters</strong></p>
<p>f : #f by dim array of fixed dimensional (e.g. triangle (#f by 3),</p>
<p>tet (#f by 4), quad (#f by 4), etc&hellip;) mesh faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>list of lists containing at index i the adjacent vertices of vertex i</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>a = mesh_adjacency_list(f)</p>
<hr />
<h3 id="adjacency_matrixf-array-object"><strong><code class="codehilite">adjacency_matrix(f: array) -&gt; object</code></strong><a class="headerlink" href="#adjacency_matrixf-array-object" title="Permanent link">&para;</a></h3>
<p>Constructs the graph adjacency matrix of a given mesh (v, f).</p>
<p><strong>Parameters</strong></p>
<p>f : #f by dim list of mesh simplices</p>
<hr />
<p><strong>Returns</strong></p>
<p>a : max(f) by max(f) cotangent matrix, each row i corresponding to v(i, :)</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_list, edges, cotmatrix, diag</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>a = adjacency_matrix(f)</p>
<p>Sum each row</p>
<p>a_sum = np.sum(a, axis=1)</p>
<p>Convert row sums into diagonal of sparse matrix</p>
<p>a_diag = diag(a_sum)</p>
<p>Build uniform laplacian</p>
<p>u = a - a_diag</p>
<hr />
<h3 id="ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object"><strong><code class="codehilite">ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object</code></strong><a class="headerlink" href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh face indices into V</p>
<p>P  #P by 3 list of origin points</p>
<p>N  #P by 3 list of origin normals</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  #P list of ambient occusion values between 1 (fully occluded) and 0 (not occluded)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="arap_linear_blockv-array-f-array-d-int-energy-int-object"><strong><code class="codehilite">arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_blockv-array-f-array-d-int-energy-int-object" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>#v by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="arap_linear_block_elementsv-array-f-array-d-int-object"><strong><code class="codehilite">arap_linear_block_elements(v: array, f: array, d: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_block_elementsv-array-f-array-d-int-object" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>#v by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="arap_linear_block_spokesv-array-f-array-d-int-object"><strong><code class="codehilite">arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_block_spokesv-array-f-array-d-int-object" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>#v by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object"><strong><code class="codehilite">arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>#v by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="arap_rhsv-array-f-array-d-int-energy-int-object"><strong><code class="codehilite">arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object</code></strong><a class="headerlink" href="#arap_rhsv-array-f-array-d-int-energy-int-object" title="Permanent link">&para;</a></h3>
<p>Guild right-hand side constructor of global poisson solve for various ARAP energies</p>
<p>Inputs:</p>
<p>Outputs:</p>
<p>K  #V*dim by #(FV)*dim*dim matrix such that:</p>
<p>b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1);</p>
<p><strong>Parameters</strong></p>
<p>v : #v by Vdim list of initial domain positions</p>
<p>f : #f by 3 list of triangle indices into v</p>
<p>d : dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2</p>
<p>energy : ARAPEnergyType enum value defining which energy is being used. See igl.ARAPEnergyType for valid options and explanations.</p>
<hr />
<p><strong>Returns</strong></p>
<p>#v*d by #(fv)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1);</p>
<hr />
<p><strong>See also</strong></p>
<p>arap_linear_block, arap</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="average_onto_verticesv-array-f-array-s-array-object"><strong><code class="codehilite">average_onto_vertices(v: array, f: array, s: array) -&gt; object</code></strong><a class="headerlink" href="#average_onto_verticesv-array-f-array-s-array-object" title="Permanent link">&para;</a></h3>
<p>Move a scalar field defined on faces to vertices by averaging</p>
<p><strong>Parameters</strong></p>
<p>v : #v by vdim array of mesh vertices</p>
<p>f : #f by simplex_count array of simplex indices</p>
<p>s : #f by dim scalar field defined on simplices</p>
<hr />
<p><strong>Returns</strong></p>
<p>#v by dim scalar field defined on vertices</p>
<hr />
<p><strong>See also</strong></p>
<p>average_onto_faces</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="avg_edge_lengthv-array-f-array-float"><strong><code class="codehilite">avg_edge_length(v: array, f: array) -&gt; float</code></strong><a class="headerlink" href="#avg_edge_lengthv-array-f-array-float" title="Permanent link">&para;</a></h3>
<p>Compute the average edge length for the given triangle mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : array_like #v by 3 vertex array</p>
<p>f : f #f by simplex-size list of mesh faces (must be simplex)</p>
<hr />
<p><strong>Returns</strong></p>
<p>l : average edge length</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>length = avg_edge_length(v, f)</p>
<hr />
<h3 id="barycenterv-array-f-array-object"><strong><code class="codehilite">barycenter(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#barycenterv-array-f-array-object" title="Permanent link">&para;</a></h3>
<p>Compute the barycenter of every simplex</p>
<p><strong>Parameters</strong></p>
<p>v : #v x dim matrix of vertex coordinates</p>
<p>f : #f x simplex_size  matrix of indices of simplex corners into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>A #f x dim matrix where each row is the barycenter of each simplex</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object"><strong><code class="codehilite">barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object</code></strong><a class="headerlink" href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object" title="Permanent link">&para;</a></h3>
<p>Compute barycentric coordinates in a tet corresponding to the Euclidean coordinates in <code class="codehilite">p</code>.</p>
<p>The input arrays <code class="codehilite">a</code>, <code class="codehilite">b</code>, <code class="codehilite">c</code> and <code class="codehilite">d</code> are the vertices of each tet. I.e. one tet is</p>
<p><code class="codehilite">a[i, :], b[i, :], c[i, :], d[:, i]</code>.</p>
<p><strong>Parameters</strong></p>
<p>p : #P by 3 Query points in 3d</p>
<p>a : #P by 3 Tet corners in 3d</p>
<p>b : #P by 3 Tet corners in 3d</p>
<p>c : #P by 3 Tet corners in 3d</p>
<p>d : #P by 3 Tet corners in 3d</p>
<hr />
<p><strong>Returns</strong></p>
<p>#P by 4 list of barycentric coordinates</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="barycentric_coordinates_trip-array-a-array-b-array-c-array-object"><strong><code class="codehilite">barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object</code></strong><a class="headerlink" href="#barycentric_coordinates_trip-array-a-array-b-array-c-array-object" title="Permanent link">&para;</a></h3>
<p>Compute barycentric coordinates in a triangle corresponding to the Euclidean coordinates in <code class="codehilite">p</code>.</p>
<p>The input arrays <code class="codehilite">a</code>, <code class="codehilite">b</code>, and <code class="codehilite">c</code> are the vertices of each triangle. I.e. one triangle is</p>
<p><code class="codehilite">a[i, :], b[i, :], c[i, :]</code>.</p>
<p><strong>Parameters</strong></p>
<p>p : #P by 3 Query points in 3d</p>
<p>a : #P by 3 Tri corners in 3d</p>
<p>b : #P by 3 Tri corners in 3d</p>
<p>c : #P by 3 Tri corners in 3d</p>
<hr />
<p><strong>Returns</strong></p>
<p>#P by 3 list of barycentric coordinates</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object"><strong><code class="codehilite">bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Construct an array indexing into a <strong>directed</strong> graph represented by an adjacency list using</p>
<p>breadth first search. I.e. the output is an array of vertices in breadth-first order.</p>
<p><strong>Parameters</strong></p>
<p>A : #V list of adjacency lists  or #V by #V adjacency matrix</p>
<p>s : starting node (index into A)</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple, (d, p) where:</p>
<ul>
<li>
<p>d is a #V list of indices into rows of A in the order in which graph nodes are discovered</p>
</li>
<li>
<p>p is a #V list of indices of A of predecsors where -1 indicates root/not discovered. I.e.</p>
</li>
</ul>
<p>p[i] is the index of the vertex v which preceded d[i] in the breadth first traversal.</p>
<p>Note that together, (d, p) form a spanning tree of the input graph</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>V, F, _ = igl.readOFF(&ldquo;test.off)</p>
<p>A = igl.adjacency_matrix(V, F)</p>
<p>d, p = igl.bfs(A, V[0])</p>
<hr />
<h3 id="bfs_orientf-array-tupleobject-object"><strong><code class="codehilite">bfs_orient(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bfs_orientf-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Consistently orient faces in orientable patches using BFS.</p>
<p><strong>Parameters</strong></p>
<p>f : #F by 3 list of faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple, (ff, c) where:</p>
<ul>
<li>
<p>ff is a #F by 3 list of faces which are consistently oriented with</p>
</li>
<li>
<p>c is a #F array of connected component ids</p>
</li>
</ul>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>v, f, _ = igl.readOFF(&ldquo;test.off)</p>
<p>ff, c = igl.bfs_orient(f)</p>
<hr />
<h3 id="bone_parentsbe-array-object"><strong><code class="codehilite">bone_parents(be: array) -&gt; object</code></strong><a class="headerlink" href="#bone_parentsbe-array-object" title="Permanent link">&para;</a></h3>
<p>BONE_PARENTS Recover &ldquo;parent&rdquo; bones from directed graph representation.</p>
<p><strong>Parameters</strong></p>
<p>BE  #BE by 2 list of directed bone edges</p>
<hr />
<p><strong>Returns</strong></p>
<p>P  #BE by 1 list of parent indices into BE, -1 means root.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object"><strong><code class="codehilite">boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]</code></strong><a class="headerlink" href="#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object" title="Permanent link">&para;</a></h3>
<p>Compute boundary conditions for automatic weights computation. This</p>
<p>function expects that the given mesh (V,Ele) has sufficient samples</p>
<p>(vertices) exactly at point handle locations and exactly along bone and</p>
<p>cage edges.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of domain vertices</p>
<p>Ele  #Ele by simplex-size list of simplex indices</p>
<p>C  #C by dim list of handle positions</p>
<p>P  #P by 1 list of point handle indices into C</p>
<p>BE  #BE by 2 list of bone edge indices into C</p>
<p>CE  #CE by 2 list of cage edge indices into <em>P</em></p>
<hr />
<p><strong>Returns</strong></p>
<p>b  #b list of boundary indices (indices into V of vertices which have</p>
<p>known, fixed values)</p>
<p>bc #b by #weights list of known/fixed values for boundary vertices</p>
<p>(notice the #b != #weights in general because #b will include all the</p>
<p>intermediary samples along each bone, etc.. The ordering of the</p>
<p>weights corresponds to [P;BE]</p>
<p><strong>Returns false if boundary conditions are suspicious:</strong></p>
<p>P and BE are empty</p>
<p>bc is empty</p>
<p>some column of bc doesn&rsquo;t have a 0 (assuming bc has &gt;1 columns)</p>
<p>some column of bc doesn&rsquo;t have a 1 (assuming bc has &gt;1 columns)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="boundary_facetst-array-object"><strong><code class="codehilite">boundary_facets(t: array) -&gt; object</code></strong><a class="headerlink" href="#boundary_facetst-array-object" title="Permanent link">&para;</a></h3>
<p>Determine boundary faces (edges) of tetrahedra (triangles).</p>
<p><strong>Parameters</strong></p>
<p>t : tetrahedron or triangle index list, m by 4/3, where m is the number of tetrahedra/triangles</p>
<hr />
<p><strong>Returns</strong></p>
<p>f : list of boundary faces, n by 3/2, where n is the number of boundary faces/edges</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>b = boundary_facets(f)</p>
<hr />
<h3 id="boundary_loopf-array-object"><strong><code class="codehilite">boundary_loop(f: array) -&gt; object</code></strong><a class="headerlink" href="#boundary_loopf-array-object" title="Permanent link">&para;</a></h3>
<p>Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices.</p>
<p><strong>Parameters</strong></p>
<p>f : #v by dim array of mesh faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>l : ordered list of boundary vertices of longest boundary loop</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>l = boundary_loop(f)</p>
<hr />
<h3 id="bounding_boxargs-kwargs"><strong><code class="codehilite">bounding_box(*args, **kwargs)</code></strong><a class="headerlink" href="#bounding_boxargs-kwargs" title="Permanent link">&para;</a></h3>
<hr />
<h3 id="bounding_boxv-array-tupleobject-object"><strong><code class="codehilite">bounding_box(v: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bounding_boxv-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Build a triangle mesh of the bounding box of a given list of vertices</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of rest domain positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>BV  2^dim by dim list of bounding box corners positions</p>
<p>BF  #BF by dim list of simplex facets</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="bounding_boxv-array-pad-float-tupleobject-object"><strong><code class="codehilite">bounding_box(v: array, pad: float) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bounding_boxv-array-pad-float-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Build a triangle mesh of the bounding box of a given list of vertices</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of rest domain positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>BV  2^dim by dim list of bounding box corners positions</p>
<p>BF  #BF by dim list of simplex facets</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="bounding_box_diagonalv-array-float"><strong><code class="codehilite">bounding_box_diagonal(v: array) -&gt; float</code></strong><a class="headerlink" href="#bounding_box_diagonalv-array-float" title="Permanent link">&para;</a></h3>
<p>Compute the length of the diagonal of a given meshes axis-aligned bounding</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns length of bounding box diagonal</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="centroidv-array-f-array-tupleobject"><strong><code class="codehilite">centroid(v: array, f: array) -&gt; Tuple[object]</code></strong><a class="headerlink" href="#centroidv-array-f-array-tupleobject" title="Permanent link">&para;</a></h3>
<p>Computes the centroid of a closed mesh using a surface integral.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of rest domain positions</p>
<p>f : #f by 3 array of triangle indices into v</p>
<hr />
<p><strong>Returns</strong></p>
<p>c : dim array of centroid coordinates</p>
<p>vol : total volume of solid</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>c, vol = centroid(v, f)</p>
<hr />
<h3 id="circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint"><strong><code class="codehilite">circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]</code></strong><a class="headerlink" href="#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint" title="Permanent link">&para;</a></h3>
<p>Return list of faces around the end point of an edge. Assumes</p>
<p>data-structures are built from an edge-manifold <strong>closed</strong> mesh.</p>
<p><strong>Parameters</strong></p>
<p>e  index into E of edge to circulate</p>
<p>ccw  whether to <em>continue</em> in ccw direction of edge (circulate around</p>
<hr />
<h3 id="emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique"><strong><code class="codehilite">EMAP #F*3 list of indices into E, mapping each directed edge to unique</code></strong><a class="headerlink" href="#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique" title="Permanent link">&para;</a></h3>
<p>unique edge in E</p>
<p>EF  #E by 2 list of edge flaps, EF(e,0)=f means e=(i&rarr;j) is the edge of</p>
<hr />
<h3 id="ej-i"><strong><code class="codehilite">e=(j-&gt;i)</code></strong><a class="headerlink" href="#ej-i" title="Permanent link">&para;</a></h3>
<p>EI  #E by 2 list of edge flap corners (see above).</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns list of faces touched by circulation (in cyclically order).</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="circumradiusv-array-f-array-object"><strong><code class="codehilite">circumradius(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#circumradiusv-array-f-array-object" title="Permanent link">&para;</a></h3>
<p>Compute the circumradius of each triangle in a mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>R  #F list of circumradii</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>R = circumradius(V, F)</p>
<hr />
<h3 id="collapse_small_trianglesv-array-f-array-eps-float-object"><strong><code class="codehilite">collapse_small_triangles(v: array, f: array, eps: float) -&gt; object</code></strong><a class="headerlink" href="#collapse_small_trianglesv-array-f-array-eps-float-object" title="Permanent link">&para;</a></h3>
<p>Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the</p>
<p>original faces and vertices of (V,F) except any small triangles have been</p>
<p>removed via collapse.</p>
<p>We are <em>not</em> following the rules in &ldquo;Mesh Optimization&rdquo; [Hoppe et al]</p>
<p>Section 4.2. But for our purposes we don&rsquo;t care about this criteria.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<p>eps  epsilon for smallest allowed area treated as fraction of squared bounding box</p>
<p>diagonal</p>
<hr />
<p><strong>Returns</strong></p>
<p>FF  #FF by 3 list of triangle indices into V</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="connect_boundary_to_infinityf-array-object"><strong><code class="codehilite">connect_boundary_to_infinity(f: array) -&gt; object</code></strong><a class="headerlink" href="#connect_boundary_to_infinityf-array-object" title="Permanent link">&para;</a></h3>
<p>Connect all boundary edges to a fictitious point at infinity.</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of face indices into some V</p>
<hr />
<p><strong>Returns</strong></p>
<p>FO  #F+#O by 3 list of face indices into [V;inf inf inf], original F are</p>
<p>guaranteed to come first. If (V,F) was a manifold mesh, now it is</p>
<p>closed with a possibly non-manifold vertex at infinity (but it will be</p>
<p>edge-manifold).</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="connect_boundary_to_infinity_facev-array-f-array-tupleobject-object"><strong><code class="codehilite">connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of face indices into some V</p>
<hr />
<p><strong>Returns</strong></p>
<p>FO  #F+#O by 3 list of face indices into VO</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="connect_boundary_to_infinity_indexf-array-inf_index-int-object"><strong><code class="codehilite">connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object</code></strong><a class="headerlink" href="#connect_boundary_to_infinity_indexf-array-inf_index-int-object" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>inf_index  index of point at infinity (usually V.rows() or F.maxCoeff())</p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="cotmatrixv-array-f-array-object"><strong><code class="codehilite">cotmatrix(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#cotmatrixv-array-f-array-object" title="Permanent link">&para;</a></h3>
<p>Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh</p>
<p>(v, f).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of mesh vertex positions</p>
<p>f : #f by simplex_size list of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p>l : #v by #v cotangent matrix, each row i corresponding to v(i, :)</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>This Laplacian uses the convention that diagonal entries are</p>
<p><strong>minus</strong> the sum of off-diagonal entries. The diagonal entries are</p>
<p>therefore in general negative and the matrix is <strong>negative</strong> semi-definite</p>
<p>(immediately, -L is <strong>positive</strong> semi-definite)</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>l = cotmatrix(v, f)</p>
<hr />
<h3 id="cotmatrix_entriesv-array-f-array-object"><strong><code class="codehilite">cotmatrix_entries(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#cotmatrix_entriesv-array-f-array-object" title="Permanent link">&para;</a></h3>
<p>COTMATRIX_ENTRIES compute the cotangents of each angle in mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of rest domain positions</p>
<p>F  #F by {34} list of {triangletetrahedra} indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>C  #F by 3 list of &frac12;*cotangents corresponding angles</p>
<p>for triangles, columns correspond to edges [1,2],[2,0],[0,1]</p>
<p>OR</p>
<p>C  #F by 6 list of &#8537;*cotangents of dihedral angles*edge lengths</p>
<p>for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2]</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object"><strong><code class="codehilite">crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object" title="Permanent link">&para;</a></h3>
<p>CROUZEIX_RAVIART_COTMATRIX Compute the Crouzeix-Raviart cotangent</p>
<p>stiffness matrix.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>F  #F by &frac34; list of triangle/tetrahedron indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>L  #E by #E edge/face-based diagonal cotangent matrix</p>
<p>E  #E by &#8532; list of edges/faces</p>
<p>EMAP  #F*&frac34; list of indices mapping allE to E</p>
<hr />
<p><strong>See also</strong></p>
<p><strong>See also: crouzeix_raviart_massmatrix</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>See for example &ldquo;Discrete Quadratic Curvature Energies&rdquo; [Wardetzky, Bergou,</p>
<p>Harmon, Zorin, Grinspun 2007]</p>
<hr />
<h3 id="crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object"><strong><code class="codehilite">crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object</code></strong><a class="headerlink" href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object" title="Permanent link">&para;</a></h3>
<p>wrapper if E and EMAP are already computed (better match!)</p>
<p><strong>Parameters</strong></p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object"><strong><code class="codehilite">crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object" title="Permanent link">&para;</a></h3>
<p>CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where</p>
<hr />
<h3 id="edge-e"><strong><code class="codehilite">edge e.</code></strong><a class="headerlink" href="#edge-e" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>F  #F by &frac34; list of triangle/tetrahedron indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>M  #E by #E edge/face-based diagonal mass matrix</p>
<p>E  #E by &#8532; list of edges/faces</p>
<p>EMAP  #F*&frac34; list of indices mapping allE to E</p>
<hr />
<p><strong>See also</strong></p>
<p>crouzeix_raviart_cotmatrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>See for example &ldquo;Discrete Quadratic Curvature Energies&rdquo; [Wardetzky, Bergou,</p>
<p>Harmon, Zorin, Grinspun 2007]</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object"><strong><code class="codehilite">crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object</code></strong><a class="headerlink" href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object" title="Permanent link">&para;</a></h3>
<p>wrapper if E and EMAP are already computed (better match!)</p>
<p><strong>Parameters</strong></p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="cut_meshv-array-f-array-cuts-array-tupleobject-object"><strong><code class="codehilite">cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#cut_meshv-array-f-array-cuts-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Compute the barycenter of every simplex</p>
<p><strong>Parameters</strong></p>
<p>v : #v x dim matrix of vertex coordinates</p>
<p>f : #f x simplex_size  matrix of indices of simplex corners into V</p>
<p>cuts : #F by 3 list of boolean flags, indicating the edges that need to</p>
<p>be cut (has 1 at the face edges that are to be cut, 0 otherwise)</p>
<hr />
<p><strong>Returns</strong></p>
<p>A pair (vcut, fcut) where:</p>
<ul>
<li>vcut is a #v by 3 list of the vertex positions</li>
</ul>
<p>of the cut mesh. This matrix will be similar to the original vertices except</p>
<p>some rows will be duplicated.</p>
<ul>
<li>fcut is a #f by 3 list of the faces of the cut mesh (must be triangles). This</li>
</ul>
<p>matrix will be similar to the original face matrix except some indices</p>
<p>will be redirected to point to the newly duplicated vertices.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object"><strong><code class="codehilite">cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object</code></strong><a class="headerlink" href="#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object" title="Permanent link">&para;</a></h3>
<p>Given a mesh (v,f) and the integer mismatch of a cross field per edge</p>
<p>(mismatch), finds and <strong>returns the cut_graph connecting the singularities</strong></p>
<p>(seams)</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of triangle vertices (each row is a vertex)</p>
<p>f : #f by 3 array of triangle indices into v</p>
<p>mismatch : #f by 3 array of per-corner integer mismatches</p>
<hr />
<p><strong>Returns</strong></p>
<p>seams : #f by 3 array of per corner booleans that de**notes if an edge is a**</p>
<p>seam or not</p>
<hr />
<p><strong>See also</strong></p>
<p>cut_mesh</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="cylinderaxis_devisions-int-height_devisions-int-tupleobject-object"><strong><code class="codehilite">cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Construct a triangle mesh of a cylinder (without caps)</p>
<p><strong>Parameters</strong></p>
<p>axis_devisions  number of vertices <em>around the cylinder</em></p>
<p>height_devisions  number of vertices <em>up the cylinder</em></p>
<hr />
<p><strong>Returns</strong></p>
<p>V  #V by 3 list of mesh vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object"><strong><code class="codehilite">decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]</code></strong><a class="headerlink" href="#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object" title="Permanent link">&para;</a></h3>
<p>Assumes (V,F) is a manifold mesh (possibly with boundary) Collapses edges</p>
<p>until desired number of faces is achieved. This uses default edge cost and</p>
<p>merged vertex placement functions {edge length, edge midpoint}.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>F  #F by 3 list of face indices into V.</p>
<p>max_m  desired number of output faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>U  #U by dim list of output vertex posistions (can be same ref as V)</p>
<p>G  #G by 3 list of output face indices into U (can be same ref as G)</p>
<p>J  #G list of indices into F of birth face</p>
<p>I  #U list of indices into V of birth vertices</p>
<p><strong>Returns true if m was reached (otherwise #G &gt; m)</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="dihedral_anglesv-array-t-array-tupleobject-object"><strong><code class="codehilite">dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#dihedral_anglesv-array-t-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Compute dihedral angles for all tets of a given tet mesh (v, t).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of vertex positions</p>
<p>t : #v by 4 list of tet indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>theta : #t by 6 list of dihedral angles (in radians)</p>
<p>cos_theta : #t by 6 list of cosine of dihedral angles (in radians)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>TetMesh in (v, t)</p>
<p>theta, cos_theta = dihedral_angles(v, t)</p>
<hr />
<h3 id="dihedral_angles_intrinsicl-array-a-array-tupleobject-object"><strong><code class="codehilite">dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#dihedral_angles_intrinsicl-array-a-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>See dihedral_angles for the documentation.</p>
<hr />
<h3 id="directed_edge_parentse-array-object"><strong><code class="codehilite">directed_edge_parents(e: array) -&gt; object</code></strong><a class="headerlink" href="#directed_edge_parentse-array-object" title="Permanent link">&para;</a></h3>
<p>Recover &ldquo;parents&rdquo; (preceding edges) in a tree given just directed edges.</p>
<p><strong>Parameters</strong></p>
<p>e : #e by 2 list of directed edges</p>
<hr />
<p><strong>Returns</strong></p>
<p>p : #e list of parent indices into e. (-1) means root</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>p = edges(e)</p>
<hr />
<h3 id="doubleareav-array-f-array-object"><strong><code class="codehilite">doublearea(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#doubleareav-array-f-array-object" title="Permanent link">&para;</a></h3>
<p>Computes twice the area for each input triangle[quad]</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of mesh vertex positions</p>
<p>f : #f by simplex_size array of mesh faces (must be triangles or quads)</p>
<hr />
<p><strong>Returns</strong></p>
<p>d_area : #f list of triangle[quad] double areas (SIGNED only for 2D input)</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal if you have 1million unreferenced vertices and 1 face</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>dbl_area = doublearea(v, f)</p>
<hr />
<h3 id="earsf-array-tupleobject-object"><strong><code class="codehilite">ears(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#earsf-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>FIND_EARS  Find all ears (faces with two boundary edges) in a given mesh</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of triangle mesh indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>ears  #ears list of indices into F of ears</p>
<p>ear_opp  #ears list of indices indicating which edge is non-boundary</p>
<p>(connecting to flops)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>ears,ear_opp = find_ears(F)</p>
<hr />
<h3 id="edge_topologyv-array-f-array-tupleobject-object-object"><strong><code class="codehilite">edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#edge_topologyv-array-f-array-tupleobject-object-object" title="Permanent link">&para;</a></h3>
<p>Initialize Edges and their topological relations (assumes an edge-manifold mesh)</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim, list of mesh vertex positions (unused)</p>
<p>f : #f by 3, list of triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>ev : #e by 2, list of edges described as pair of vertices.</p>
<p>fe : #f by 3, list storing triangle-edge relation.</p>
<p>ef : #e by w, list storing edge-triangle relation, uses -1 to indicate boundaries.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>ev, fe, ef = edge_topology(v, f)</p>
<hr />
<h3 id="edgesf-array-object"><strong><code class="codehilite">edges(f: array) -&gt; object</code></strong><a class="headerlink" href="#edgesf-array-object" title="Permanent link">&para;</a></h3>
<p>Constructs a list of unique edges represented in a given mesh (v, f)</p>
<p><strong>Parameters</strong></p>
<p>f : #F by dim list of mesh faces (must be triangles or tets)</p>
<hr />
<p><strong>Returns</strong></p>
<p>#e by 2 list of edges in no particular order</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>V, F, _ = igl.readOFF(&ldquo;test.off)</p>
<p>E = igl.edges(F)</p>
<hr />
<h3 id="euler_characteristicf-array-int"><strong><code class="codehilite">euler_characteristic(f: array) -&gt; int</code></strong><a class="headerlink" href="#euler_characteristicf-array-int" title="Permanent link">&para;</a></h3>
<p>Computes the Euler characteristic of a given mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>F #F by dim list of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns An int containing the Euler characteristic</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="euler_characteristic_completev-array-f-array-int"><strong><code class="codehilite">euler_characteristic_complete(v: array, f: array) -&gt; int</code></strong><a class="headerlink" href="#euler_characteristic_completev-array-f-array-int" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>V       #V by dim list of mesh vertex positions</p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object"><strong><code class="codehilite">exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object</code></strong><a class="headerlink" href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object" title="Permanent link">&para;</a></h3>
<p>Exact geodesic algorithm for the calculation of geodesics on a triangular mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of 3D vertex positions</p>
<p>f : #f by 3 array of mesh faces</p>
<p>vs : #vs by 1 array specifying indices of source vertices</p>
<p>fs : #fs by 1 array specifying indices of source faces</p>
<p>vt : #vt by 1 array specifying indices of target vertices</p>
<p>ft : #ft by 1 array specifying indices of target faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>d : #vt+#ft by 1 array of geodesic distances of each target w.r.t. the nearest one in the source set</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>Specifying a face as target/source means its center.</p>
<p>Implementation from https:code.google.com/archive/p/geodesic/ with the algorithm first described by Mitchell, Mount and Papadimitriou in 1987.</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="face_componentsf-array-object"><strong><code class="codehilite">face_components(f: array) -&gt; object</code></strong><a class="headerlink" href="#face_componentsf-array-object" title="Permanent link">&para;</a></h3>
<p>Compute connected components of facets based on edge-edge adjacency,</p>
<p><strong>Parameters</strong></p>
<p>f : #f x 3 array of triangle indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>An array, c, with shape (#f,), of component ids</p>
<hr />
<p><strong>See also</strong></p>
<p>vertex_components</p>
<p>vertex_components_from_adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="fit_planev-array-tupleobject-object"><strong><code class="codehilite">fit_plane(v: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#fit_planev-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>This function fits a plane to a point cloud.</p>
<p><strong>Parameters</strong></p>
<p>V #Vx3 matrix. The 3D point cloud, one row for each vertex.</p>
<hr />
<p><strong>Returns</strong></p>
<p>N 1x3 Vector. The normal of the fitted plane.</p>
<p>C 1x3 Vector. A point that lies in the fitted plane.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>From http:missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object"><strong><code class="codehilite">flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]</code></strong><a class="headerlink" href="#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object" title="Permanent link">&para;</a></h3>
<p>A bisection line search for a mesh based energy that avoids triangle flips as suggested in</p>
<p>&ldquo;Bijective Parameterization with Free Boundaries&rdquo; (Smith J. and Schaefer S., 2015).</p>
<p>The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles).</p>
<p>This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see igl::line_search).</p>
<p>Supports both triangle and tet meshes.</p>
<p><strong>Parameters</strong></p>
<p>F         #F by &frac34; list of mesh faces or tets</p>
<p>cur_v     #V by dim list of variables</p>
<p>dst_v     #V by dim list of target vertices. This mesh may have flipped triangles</p>
<p>energy    A function to compute the mesh-based energy (return an energy that is bigger than 0)</p>
<hr />
<h3 id="cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it"><strong><code class="codehilite">cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it.</code></strong><a class="headerlink" href="#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it" title="Permanent link">&para;</a></h3>
<hr />
<p><strong>Returns</strong></p>
<p>cur_v     #V by dim list of variables at the new location</p>
<p><strong>Returns the energy at the new point</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="gaussian_curvaturev-array-f-array-object"><strong><code class="codehilite">gaussian_curvature(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#gaussian_curvaturev-array-f-array-object" title="Permanent link">&para;</a></h3>
<p>Compute discrete local integral gaussian curvature (angle deficit, without</p>
<p>averaging by local area).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex 3D positions</p>
<p>f : #f by 3 array of face (triangle) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>k : #v by 1 array of discrete gaussian curvature values</p>
<hr />
<p><strong>See also</strong></p>
<p>principal_curvature</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>k = gaussian_curvature(v, f)</p>
<hr />
<h3 id="gradv-array-f-array-uniform-bool-false-object"><strong><code class="codehilite">grad(v: array, f: array, uniform: bool = False) -&gt; object</code></strong><a class="headerlink" href="#gradv-array-f-array-uniform-bool-false-object" title="Permanent link">&para;</a></h3>
<p>Compute the numerical gradient operator.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 list of mesh vertex positions</p>
<p>f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices]</p>
<p>uniform : boolean (default false). Use a uniform mesh instead of the vertices v</p>
<hr />
<p><strong>Returns</strong></p>
<p>g : #faces * dim by #v gradient operator</p>
<hr />
<p><strong>See also</strong></p>
<p>cotmatrix, massmatrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>Gradient of a scalar function defined on piecewise linear elements (mesh)</p>
<p>is constant on each triangle [tetrahedron] i,j,k:</p>
<hr />
<h3 id="gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a"><strong><code class="codehilite">grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A</code></strong><a class="headerlink" href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a" title="Permanent link">&para;</a></h3>
<p>where Xi is the scalar value at vertex i, Vi is the 3D position of vertex</p>
<p>i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of</p>
<p>90 degrees.</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>g = grad(v, f)</p>
<hr />
<h3 id="harmonicl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-b-array-bc-array-k-int-object"><strong><code class="codehilite">harmonic(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, b: array, bc: array, k: int) -&gt; object</code></strong><a class="headerlink" href="#harmonicl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-b-array-bc-array-k-int-object" title="Permanent link">&para;</a></h3>
<p>Compute a harmonic map using a given Laplacian and mass matrix</p>
<p><strong>Parameters</strong></p>
<p>L  #V by #V discrete (integrated) Laplacian</p>
<p>M  #V by #V mass matrix</p>
<p>b  #b boundary indices into V</p>
<p>bc  #b by #W list of boundary values</p>
<p>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</p>
<hr />
<p><strong>Returns</strong></p>
<p>W  #V by #V list of weights</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object"><strong><code class="codehilite">harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object</code></strong><a class="headerlink" href="#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object" title="Permanent link">&para;</a></h3>
<p>Build the discrete k-harmonic operator (computing integrated quantities).</p>
<p>That is, if the k-harmonic PDE is Q x = 0, then this minimizes x&rsquo; Q x</p>
<p><strong>Parameters</strong></p>
<p>L  #V by #V discrete (integrated) Laplacian</p>
<p>M  #V by #V mass matrix</p>
<p>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</p>
<hr />
<p><strong>Returns</strong></p>
<p>Q  #V by #V discrete (integrated) k-Laplacian</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object"><strong><code class="codehilite">harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object</code></strong><a class="headerlink" href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object" title="Permanent link">&para;</a></h3>
<p>Compute harmonic map using uniform laplacian operator</p>
<p><strong>Parameters</strong></p>
<p>F  #F by simplex-size list of element indices</p>
<p>b  #b boundary indices into V</p>
<p>bc #b by #W list of boundary values</p>
<p>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</p>
<hr />
<p><strong>Returns</strong></p>
<p>W  #V by #W list of weights</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object"><strong><code class="codehilite">harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object</code></strong><a class="headerlink" href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object" title="Permanent link">&para;</a></h3>
<p>Compute k-harmonic weight functions &ldquo;coordinates&rdquo;.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim vertex positions</p>
<p>F  #F by simplex-size list of element indices</p>
<p>b  #b boundary indices into V</p>
<p>bc #b by #W list of boundary values</p>
<p>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</p>
<hr />
<p><strong>Returns</strong></p>
<p>W  #V by #W list of weights</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="hausdorffva-array-fa-array-vb-array-fb-array-float"><strong><code class="codehilite">hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float</code></strong><a class="headerlink" href="#hausdorffva-array-fa-array-vb-array-fb-array-float" title="Permanent link">&para;</a></h3>
<p>HAUSDORFF compute the Hausdorff distance between mesh (VA,FA) and mesh</p>
<p>(VB,FB). This is the</p>
<hr />
<h3 id="aa-bb-bb-aa"><strong><code class="codehilite">a∈A b∈B          b∈B a∈A</code></strong><a class="headerlink" href="#aa-bb-bb-aa" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>VA  #VA by 3 list of vertex positions</p>
<p>FA  #FA by 3 list of face indices into VA</p>
<p>VB  #VB by 3 list of vertex positions</p>
<p>FB  #FB by 3 list of face indices into VB</p>
<hr />
<p><strong>Returns</strong></p>
<p>d  hausdorff distance</p>
<p>pair  2 by 3 list of &ldquo;determiner points&rdquo; so that pair(1,:) is from A</p>
<p>and pair(2,:) is from B</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>Known issue: This is only computing max(min(va,B),min(vb,A)). This is</p>
<p>better than max(min(va,Vb),min(vb,Va)). This (at least) is missing</p>
<p>&ldquo;edge-edge&rdquo; cases like the distance between the two different</p>
<p>triangulations of a non-planar quad in 3D. Even simpler, consider the</p>
<p>Hausdorff distance between the non-convex, block letter V polygon (with 7</p>
<p>vertices) in 2D and its convex hull. The Hausdorff distance is defined by</p>
<p>the midpoint in the middle of the segment across the concavity and some</p>
<p>non-vertex point <em>on the edge</em> of the V.</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="internal_anglesv-array-f-array-object"><strong><code class="codehilite">internal_angles(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#internal_anglesv-array-f-array-object" title="Permanent link">&para;</a></h3>
<p>Computes internal angles for a triangle mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of mesh vertex nD positions</p>
<p>f : #f by poly-size array of face (triangle) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>k : #f by poly-size array of internal angles. For triangles, columns correspond to edges [1,2],[2,0],[0,1].</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>If poly-size ≠ 3 then dim must equal 3.</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="is_edge_manifoldf-array-bool"><strong><code class="codehilite">is_edge_manifold(f: array) -&gt; bool</code></strong><a class="headerlink" href="#is_edge_manifoldf-array-bool" title="Permanent link">&para;</a></h3>
<p>See is_edge_manifold for the documentation.</p>
<hr />
<h3 id="is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool"><strong><code class="codehilite">is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;</code></strong><a class="headerlink" href="#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool" title="Permanent link">&para;</a></h3>
<p>Determine if a vertex is irregular, i.e. it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of vertex positions</p>
<p>f : #f by 3[4] array of triangle[quads] indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>s : #v list of bools revealing whether vertices are singular</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="isolinesv-array-f-array-z-array-n-int-tupleobject-object"><strong><code class="codehilite">isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#isolinesv-array-f-array-z-array-n-int-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Constructs isolines for a function z given on a mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh faces (must be triangles)</p>
<p>z  #V by 1 list of function values evaluated at vertices</p>
<p>n  the number of desired isolines</p>
<hr />
<p><strong>Returns</strong></p>
<p>isoV  #isoV by dim list of isoline vertex positions</p>
<p>isoE  #isoE by 2 list of isoline edge positions</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="lscmv-array-f-array-b-array-bc-array-tuplebool-object"><strong><code class="codehilite">lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]</code></strong><a class="headerlink" href="#lscmv-array-f-array-b-array-bc-array-tuplebool-object" title="Permanent link">&para;</a></h3>
<p>Compute a Least-squares conformal map parametrization.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex positions</p>
<p>f : #f by 3 array of mesh faces (must be triangles)</p>
<p>b : #b boundary indices into v</p>
<p>bc : #b by 3 list of boundary values</p>
<hr />
<p><strong>Returns</strong></p>
<p>uv #v by 2 list of 2D mesh vertex positions in UV space</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>Derived in &ldquo;Intrinsic Parameterizations of Surface Meshes&rdquo; [Desbrun et al.</p>
<p>2002] and &ldquo;Least Squares Conformal Maps for Automatic Texture Atlas</p>
<p>Generation&rdquo; [Lévy et al. 2002]), though this implementation follows the</p>
<p>derivation in: &ldquo;Spectral Conformal Parameterization&rdquo; [Mullen et al. 2008]</p>
<p>(note, this does <strong>not</strong> implement the Eigen-decomposition based method in</p>
<p>[Mullen et al. 2008], which is not equivalent. Input should be a manifold</p>
<p>mesh (also no unreferenced vertices) and &ldquo;boundary&rdquo; (fixed vertices) <code class="codehilite">b</code></p>
<p>should contain at least two vertices per connected component.</p>
<p><strong>Returns true only on solver success.</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="map_vertices_to_circlev-array-bnd-array-object"><strong><code class="codehilite">map_vertices_to_circle(v: array, bnd: array) -&gt; object</code></strong><a class="headerlink" href="#map_vertices_to_circlev-array-bnd-array-object" title="Permanent link">&para;</a></h3>
<p>Map the vertices whose indices are in a given boundary loop (bnd) on the unit circle with spacing proportional to the original boundary edge lengths.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of mesh vertex positions</p>
<p>b : #w list of vertex ids</p>
<hr />
<p><strong>Returns</strong></p>
<p>uv : #w by 2 list of 2D positions on the unit circle for the vertices in b</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="massmatrixv-array-f-array-type-int-1-object"><strong><code class="codehilite">massmatrix(v: array, f: array, type: int = 1) -&gt; object</code></strong><a class="headerlink" href="#massmatrixv-array-f-array-type-int-1-object" title="Permanent link">&para;</a></h3>
<p>Constructs the mass (area) matrix for a given mesh (V,F).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of mesh vertex positions</p>
<p>f : #f by simplex_size list of mesh faces (must be triangles)</p>
<p>type : one of the following types:</p>
<p>-igl.MASSMATRIX_TYPE_BARYCENTRIC  barycentric</p>
<p>-igl.MASSMATRIX_TYPE_VORONOI voronoi-hybrid (default)</p>
<p>-igl.MASSMATRIX_TYPE_FULL full (not implemented)</p>
<hr />
<p><strong>Returns</strong></p>
<p>m : #v by #v mass matrix</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix, cotmatrix, grad</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object"><strong><code class="codehilite">min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object</code></strong><a class="headerlink" href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object" title="Permanent link">&para;</a></h3>
<p>MIN_QUAD_WITH_FIXED Minimize quadratic energy Z&rsquo;*A*Z + Z&rsquo;*B + C</p>
<p>subject to linear constraints Aeq*Z = Beq</p>
<p><strong>Parameters</strong></p>
<p>A  n by n matrix of quadratic coefficients</p>
<p>B  n by 1 column of linear coefficients</p>
<p>Aeq  m by n list of linear equality constraint coefficients</p>
<p>Beq  m by 1 list of linear equality constraint constant values</p>
<p>use_lu_decomposition  use lu rather than SVD</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  n by (n + m) &ldquo;solve&rdquo; matrix, such that S*[B&rsquo;, Beq&rsquo;] is a solution</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="orientable_patchesf-array-tupleobject-object"><strong><code class="codehilite">orientable_patches(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#orientable_patchesf-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Compute connected components of facets connected by manifold edges.</p>
<p><strong>Parameters</strong></p>
<p>f : n by dim array of face ids</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple (c, A) where c is an array of component ids (starting with 0)</p>
<p>and A is a #f x #f adjacency matri</p>
<hr />
<p><strong>See also</strong></p>
<p>components</p>
<hr />
<p><strong>Notes</strong></p>
<p>Known bugs: This will detect a moebius strip as a single patch (manifold, non-orientable) and also non-manfiold, yet orientable patches.</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="oriented_facetsf-array-object"><strong><code class="codehilite">oriented_facets(f: array) -&gt; object</code></strong><a class="headerlink" href="#oriented_facetsf-array-object" title="Permanent link">&para;</a></h3>
<p>Determines all &lsquo;directed <a href="https:en.wikipedia.org/wiki/Simplex#Elements">facets</a>&lsquo; of a given set</p>
<p>of simplicial elements. For a manifold triangle mesh, this computes all half-edges.</p>
<p>For a manifold tetrahedral mesh, this computes all half-faces.</p>
<p><strong>Parameters</strong></p>
<p>f : #F by simplex_size list of simplices</p>
<hr />
<p><strong>Returns</strong></p>
<p>#E : by simplex_size-1 list of half-edges/facets</p>
<hr />
<p><strong>See also</strong></p>
<p>edges</p>
<hr />
<p><strong>Notes</strong></p>
<p>This is not the same as igl::edges because this includes every</p>
<p>directed edge including repeats (meaning interior edges on a surface will</p>
<p>show up once for each direction and non-manifold edges may appear more than</p>
<p>once for each direction).</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object"><strong><code class="codehilite">per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object" title="Permanent link">&para;</a></h3>
<p>Compute face normals via vertex position list, face list</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 eigen Matrix of mesh vertex 3D positions</p>
<p>F  #F by 3 eigen Matrix of face (triangle) indices</p>
<p>weight  weighting type</p>
<p>FN  #F by 3 matrix of 3D face normals per face</p>
<hr />
<p><strong>Returns</strong></p>
<p>N  <a class="magiclink magiclink-github magiclink-issue" href="https://github.com/libigl-python-bindings/libigl-python-bindings/issues/2" title="GitHub Issue: libigl-python-bindings/libigl-python-bindings#2">#2</a> by 3 matrix of mesh edge 3D normals per row</p>
<p>E  #E by 2 matrix of edge indices per row</p>
<p>EMAP  #E by 1 matrix of indices from all edges to E</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="per_face_normalsv-array-f-array-z-array-object"><strong><code class="codehilite">per_face_normals(v: array, f: array, z: array) -&gt; object</code></strong><a class="headerlink" href="#per_face_normalsv-array-f-array-z-array-object" title="Permanent link">&para;</a></h3>
<p>Compute face normals via vertex position list, face list</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 eigen Matrix of mesh vertex 3D positions</p>
<p>F  #F by 3 eigen Matrix of face (triangle) indices</p>
<p>Z  3 vector normal given to faces with degenerate normal.</p>
<hr />
<p><strong>Returns</strong></p>
<p>N  #F by 3 eigen Matrix of mesh face (triangle) 3D normals</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Give degenerate faces (&#8531;,&#8531;,&#8531;)^0.5</p>
<hr />
<h3 id="per_face_normalsvfvector3d111normalizedn"><strong><code class="codehilite">per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);</code></strong><a class="headerlink" href="#per_face_normalsvfvector3d111normalizedn" title="Permanent link">&para;</a></h3>
<hr />
<h3 id="per_vertex_attribute_smoothingain-array-f-array-object"><strong><code class="codehilite">per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#per_vertex_attribute_smoothingain-array-f-array-object" title="Permanent link">&para;</a></h3>
<p>Smooth vertex attributes using uniform Laplacian</p>
<p><strong>Parameters</strong></p>
<p>Ain  #V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes)</p>
<p>F    #F by 3 eigne Matrix of face (triangle) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>Aout #V by #A eigen Matrix of mesh vertex attributes</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="per_vertex_normalsv-array-f-array-weighting-int-0-object"><strong><code class="codehilite">per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object</code></strong><a class="headerlink" href="#per_vertex_normalsv-array-f-array-weighting-int-0-object" title="Permanent link">&para;</a></h3>
<p>Compute vertex normals via vertex position list, face list.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex 3D positions</p>
<p>f : #f by 3 array of face (triangle) indices</p>
<p>weighting : Weighting type, one of the following</p>
<p>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM uniform influence</p>
<p>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA area weighted</p>
<p>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE angle weighted</p>
<hr />
<p><strong>Returns</strong></p>
<p>n  #v by 3 array of mesh vertex 3D normals</p>
<hr />
<p><strong>See also</strong></p>
<p>per_face_normals, per_edge_normals</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>n = per_vertex_normals(v, f)</p>
<hr />
<h3 id="piecewise_constant_winding_numberf-array-bool"><strong><code class="codehilite">piecewise_constant_winding_number(f: array) -&gt; bool</code></strong><a class="headerlink" href="#piecewise_constant_winding_numberf-array-bool" title="Permanent link">&para;</a></h3>
<p>PIECEWISE_CONSTANT_WINDING_NUMBER Determine if a given mesh induces a</p>
<p>piecewise constant winding number field: Is this mesh valid input to solid</p>
<p>set operations.  <strong>Assumes</strong> that <code class="codehilite">(V,F)</code> contains no -intersections</p>
<p>(including degeneracies and co-incidences).  If there are co-planar and</p>
<p>co-incident vertex placements, a mesh could <em>fail</em> this combinatorial test</p>
<p>but still induce a piecewise-constant winding number <em>geometrically</em>. For</p>
<p>example, consider a hemisphere with boundary and then pinch the boundary</p>
<p>&ldquo;shut&rdquo; along a line segment. The <strong><em>bullet-proof</em></strong> check is to first</p>
<p>resolve all -intersections in <code class="codehilite">(V,F) -&gt; (SV,SF)</code> (i.e. what the</p>
<p><code class="codehilite">igl::copyleft::cgal::piecewise_constant_winding_number</code> overload does).</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of triangle indices into some (abstract) list of</p>
<p>vertices V</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns true if the mesh <em>combinatorially</em> induces a piecewise constant</strong></p>
<p>winding number field.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object"><strong><code class="codehilite">principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]</code></strong><a class="headerlink" href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object" title="Permanent link">&para;</a></h3>
<p>Compute the principal curvature directions and magnitude of the given triangle mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : vertex array of size #V by 3</p>
<p>f : face index array #F by 3 list of mesh faces (must be triangles)</p>
<p>radius : controls the size of the neighbourhood used, 1 = average edge length (default: 5)</p>
<p>use_k_ring : (default: True)</p>
<hr />
<p><strong>Returns</strong></p>
<p>pd1 : #v by 3 maximal curvature direction for each vertex</p>
<p>pd2 : #v by 3 minimal curvature direction for each vertex</p>
<p>pv1 : #v by 1 maximal curvature value for each vertex</p>
<p>pv2 : #v by 1 minimal curvature value for each vertex</p>
<hr />
<p><strong>See also</strong></p>
<p>average_onto_faces, average_onto_vertices</p>
<hr />
<p><strong>Notes</strong></p>
<p>This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo.</p>
<p>The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation</p>
<p>Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>pd1, pd2, pv1, pv2 = principal_curvature(v, f)</p>
<hr />
<h3 id="procrustesx-array-y-array-tuplebool-bool-float-object-object"><strong><code class="codehilite">procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]</code></strong><a class="headerlink" href="#procrustesx-array-y-array-tuplebool-bool-float-object-object" title="Permanent link">&para;</a></h3>
<p>Solve Procrustes problem in d dimensions.  Given two point sets X,Y in R^d</p>
<p>find best scale s, orthogonal R  and translation t s.t. s*X*R + t - Y^2</p>
<p>is minimized.</p>
<p><strong>Parameters</strong></p>
<p>X  #V by DIM first list of points</p>
<p>Y  #V by DIM second list of points</p>
<p>includeScaling  if scaling should be allowed</p>
<p>includeReflections  if R is allowed to be a reflection</p>
<hr />
<p><strong>Returns</strong></p>
<p>scale  scaling</p>
<p>R      orthogonal matrix</p>
<p>t      translation</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>MatrixXd X, Y; (containing 3d points as rows)</p>
<p>double scale;</p>
<p>MatrixXd R;</p>
<p>VectorXd t;</p>
<p>igl::procrustes(X,Y,true,false,scale,R,t);</p>
<p>R *= scale;</p>
<p>MatrixXd Xprime = (X * R).rowwise() + t.transpose();</p>
<hr />
<h3 id="qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object"><strong><code class="codehilite">qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]</code></strong><a class="headerlink" href="#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object" title="Permanent link">&para;</a></h3>
<p>Decimate (simplify) a triangle mesh in nD according to the paper</p>
<p>&ldquo;Simplifying Surfaces with Color and Texture using Quadric Error Metrics&rdquo;</p>
<p>by [Garland and Heckbert, 1987] (technically a followup to qslim). The</p>
<p>mesh can have open boundaries but should be edge-manifold.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions. Assumes that vertices w</p>
<p>F  #F by 3 list of triangle indices into V</p>
<p>max_m  desired number of output faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>U  #U by dim list of output vertex posistions (can be same ref as V)</p>
<p>G  #G by 3 list of output face indices into U (can be same ref as G)</p>
<p>J  #G list of indices into F of birth face</p>
<p>I  #U list of indices into V of birth vertices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="quad_planarityv-array-f-array-object"><strong><code class="codehilite">quad_planarity(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#quad_planarityv-array-f-array-object" title="Permanent link">&para;</a></h3>
<p>Compute planarity of the faces of a quad mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex 3D positions</p>
<p>f : #f by 4 array of face (quad) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>p : #f by 1 array of mesh face (quad) planarities</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="random_points_on_meshn-int-v-array-f-array-tupleobject-object"><strong><code class="codehilite">random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#random_points_on_meshn-int-v-array-f-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>RANDOM_POINTS_ON_MESH Randomly sample a mesh (V,F) n times.</p>
<p><strong>Parameters</strong></p>
<p>n  number of samples</p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh triangle indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>B  n by 3 list of barycentric coordinates, ith row are coordinates of</p>
<p>ith sampled point in face FI(i)</p>
<p>FI  n list of indices into F</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="read_dmatfilename-str-dtype-numpydtype-str-type-float64-object"><strong><code class="codehilite">read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object</code></strong><a class="headerlink" href="#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object" title="Permanent link">&para;</a></h3>
<p>Read a matrix from an ascii dmat file, a simple ascii matrix file type, defined as follows. The first line is always:</p>
<p>&lt;#columns&gt; &lt;#rows&gt;</p>
<p>Then the coefficients of the matrix are given separated by whitespace with columns running fastest.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to .dmat file</p>
<p>dtype : data-type of the returned matrix. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>w : array containing read-in coefficients</p>
<hr />
<p><strong>See also</strong></p>
<p>read_triangle_mesh, read_off</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>w = read_dmat(&ldquo;my_model.dmat&rdquo;)</p>
<hr />
<h3 id="read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object"><strong><code class="codehilite">read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]</code></strong><a class="headerlink" href="#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object" title="Permanent link">&para;</a></h3>
<p>Read a mesh from an ascii obj file, filling in vertex positions, normals</p>
<p>and texture coordinates. Mesh may have faces of any number of degree.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to .obj file</p>
<p>dtype : data-type of the returned faces, texture coordinates and normals, optional. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v : array of vertex positions #v by 3</p>
<p>tc : array of texture coordinats #tc by 2</p>
<p>n : array of corner normals #n by 3</p>
<p>f : #f array of face indices into vertex positions</p>
<p>ftc : #f array of face indices into vertex texture coordinates</p>
<p>fn : #f array of face indices into vertex normals</p>
<hr />
<p><strong>See also</strong></p>
<p>read_triangle_mesh, read_off</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>v, _, n, f, _, _ = read_obj(&ldquo;my_model.obj&rdquo;)</p>
<hr />
<h3 id="read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object"><strong><code class="codehilite">read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object" title="Permanent link">&para;</a></h3>
<p>Read a mesh from an ascii off file, filling in vertex positions, normals</p>
<p>and texture coordinates. Mesh may have faces of any number of degree.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to .off file</p>
<p>read_normals : bool, determines whether normals are read. If false, <strong>returns []</strong></p>
<p>dtype : data-type of the returned vertices, faces, and normals, optional. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v : array of vertex positions #v by 3</p>
<p>f : #f list of face indices into vertex positions</p>
<p>n : list of vertex normals #v by 3</p>
<hr />
<p><strong>See also</strong></p>
<p>read_triangle_mesh, read_obj</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>v, f, n, c = read_off(&ldquo;my_model.off&rdquo;)</p>
<hr />
<h3 id="read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object"><strong><code class="codehilite">read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Read mesh from an ascii file with automatic detection of file format.</p>
<p>Supported: obj, off, stl, wrl, ply, mesh.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to mesh file</p>
<p>dtype : data-type of the returned vertices, optional. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v : array of vertex positions #v by 3</p>
<p>f : #f list of face indices into vertex positions</p>
<hr />
<p><strong>See also</strong></p>
<p>read_obj, read_off, read_stl</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>v, f = read_triangle_mesh(&ldquo;my_model.obj&rdquo;)</p>
<hr />
<h3 id="remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object"><strong><code class="codehilite">remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]</code></strong><a class="headerlink" href="#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object" title="Permanent link">&para;</a></h3>
<p>REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness</p>
<p>tolerance (epsilon)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>epsilon  uniqueness tolerance (significant digit), can probably think of</p>
<p>this as a tolerance on L1 distance</p>
<hr />
<p><strong>Returns</strong></p>
<p>SV  #SV by dim new list of vertex positions</p>
<p>SVI #V by 1 list of indices so SV = V(SVI,:)</p>
<p>SVJ #SV by 1 list of indices so V = SV(SVJ,:)</p>
<p>Wrapper that also remaps given faces (F) &rarr; (SF) so that SF index SV</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>% Mesh in (V,F)</p>
<p>[SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7);</p>
<p>% remap faces</p>
<p>SF = SVJ(F);</p>
<hr />
<h3 id="remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object"><strong><code class="codehilite">remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object" title="Permanent link">&para;</a></h3>
<p>Merge the duplicate vertices from V, fixing the topology accordingly</p>
<p><strong>Parameters</strong></p>
<p>V,F       mesh description</p>
<p>epsilon   minimal distance to consider two vertices identical</p>
<hr />
<p><strong>Returns</strong></p>
<p>NV, NF    new mesh without duplicate vertices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="remove_unreferencedv-array-f-array-tupleobject-object-object-object"><strong><code class="codehilite">remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]</code></strong><a class="headerlink" href="#remove_unreferencedv-array-f-array-tupleobject-object-object-object" title="Permanent link">&para;</a></h3>
<p>Remove unreferenced vertices from V, updating F accordingly</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by ss list of simplices (Values of -1 are quitely skipped)</p>
<hr />
<p><strong>Returns</strong></p>
<p>NV  #NV by dim list of mesh vertex positions</p>
<p>NF  #NF by ss list of simplices</p>
<p>IM  #V by 1 list of indices such that: NF = IM(F) and NT = IM(T)</p>
<p>and V(find(IM&lt;=size(NV,1)),:) = NV</p>
<p>J  #RV by 1 list, such that RV = V(J,:)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="resolve_duplicated_facesf1-array-tupleobject-object"><strong><code class="codehilite">resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#resolve_duplicated_facesf1-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Resolve duplicated faces according to the following rules per unique face:</p>
<hr />
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of"><strong><code class="codehilite">If the number of positively oriented faces equals the number of</code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces, remove all duplicated faces at this triangle.</p>
<hr />
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of_1"><strong><code class="codehilite">If the number of positively oriented faces equals the number of</code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_1" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces plus 1, keeps one of the positively oriented</p>
<p>face.</p>
<hr />
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of_2"><strong><code class="codehilite">If the number of positively oriented faces equals the number of</code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_2" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces minus 1, keeps one of the negatively oriented</p>
<p>face.</p>
<hr />
<h3 id="if-the-number-of-postively-oriented-faces-differ-with-the-number-of"><strong><code class="codehilite">If the number of postively oriented faces differ with the number of</code></strong><a class="headerlink" href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of" title="Permanent link">&para;</a></h3>
<p>negativley oriented faces by more than 1, the mesh is not orientable.</p>
<p>An exception will be thrown.</p>
<p><strong>Parameters</strong></p>
<p>F1  #F1 by 3 array of input faces.</p>
<hr />
<p><strong>Returns</strong></p>
<p>F2  #F2 by 3 array of output faces without duplicated faces.</p>
<p>J   #F2 list of indices into F1.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object"><strong><code class="codehilite">shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object</code></strong><a class="headerlink" href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object" title="Permanent link">&para;</a></h3>
<p>Compute shape diamater function per given point. In the parlence of the</p>
<p>paper &ldquo;Consistent Mesh Partitioning and Skeletonisation using the Shape</p>
<p>Diameter Function&rdquo; [Shapiro et al. 2008], this implementation uses a 180°</p>
<p>cone and a <em>uniform</em> average (<em>not</em> a average weighted by inverse angles).</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh face indices into V</p>
<p>P  #P by 3 list of origin points</p>
<p>N  #P by 3 list of origin normals</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  #P list of shape diamater function values between bounding box</p>
<p>diagonal (perfect sphere) and 0 (perfect needle hook)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="sort_anglesm-array-object"><strong><code class="codehilite">sort_angles(m: array) -&gt; object</code></strong><a class="headerlink" href="#sort_anglesm-array-object" title="Permanent link">&para;</a></h3>
<p>Sort angles in ascending order in a numerically robust way.</p>
<p>Instead of computing angles using atan2(y, x), sort directly on (y, x).</p>
<p><strong>Parameters</strong></p>
<p>-</p>
<p>M: m by n matrix of scalars. (n &gt;= 2).  Assuming the first column of M</p>
<p>contains values for y, and the second column is x.  Using the rest</p>
<p>of the columns as tie-breaker.</p>
<hr />
<p><strong>Returns</strong></p>
<p>R: an array of m indices.  M.row(R[i]) contains the i-th smallest</p>
<p>angle.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None.</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object"><strong><code class="codehilite">tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]</code></strong><a class="headerlink" href="#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object" title="Permanent link">&para;</a></h3>
<p>Mesh the interior of a surface mesh (V,F) using tetgen.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 vertex position array</p>
<p>f : #v array of polygon face indices into V (0-indexed)</p>
<p>switches : string of tetgen options (See tetgen documentation) e.g.</p>
<p>&ldquo;pq1.414a0.01&rdquo; tries to mesh the interior of a given surface with quality and area constraints. Will mesh the convex hull constrained to pass through V (ignores F)</p>
<hr />
<p><strong>Returns</strong></p>
<p>tv  #v by 3 vertex position array</p>
<p>tt  #t by 4 array of tet face indices</p>
<p>tf  #f by 3 array of triangle face indices</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Returns status:</strong></p>
<p>0 success</p>
<p>1 tetgen threw exception</p>
<p>2 tetgen did not crash but could not create any tets (probably there are</p>
<p>holes, duplicate faces etc.)</p>
<p>-1 other error</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="triangle_triangle_adjacencyf-array-tupleobject-object"><strong><code class="codehilite">triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#triangle_triangle_adjacencyf-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Constructs the triangle-triangle adjacency matrix for a given</p>
<p>mesh (V,F).</p>
<p><strong>Parameters</strong></p>
<p>F  #F by simplex_size list of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p>TT   #F by <a class="magiclink magiclink-github magiclink-issue" href="https://github.com/libigl-python-bindings/libigl-python-bindings/issues/3" title="GitHub Issue: libigl-python-bindings/libigl-python-bindings#3">#3</a> adjacent matrix, the element i,j is the id of the triangle</p>
<p>adjacent to the j edge of triangle i</p>
<p>TTi  #F by <a class="magiclink magiclink-github magiclink-issue" href="https://github.com/libigl-python-bindings/libigl-python-bindings/issues/3" title="GitHub Issue: libigl-python-bindings/libigl-python-bindings#3">#3</a> adjacent matrix, the element i,j is the id of edge of the</p>
<p>triangle TT(i,j) that is adjacent with triangle i</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third</p>
<p>[2,3].  this convention is DIFFERENT from cotmatrix_entries.h</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object"><strong><code class="codehilite">triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Triangulate the interior of a polygon using the triangle library.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 2 array of 2D vertex positions</p>
<p>e : #e by 2 array of vertex ids forming unoriented edges of the boundary of the polygon</p>
<p>h : #h by 2 coordinates of points contained inside holes of the polygon</p>
<p>m : optional #v list of markers for input vertices</p>
<p>flags : string of options pass to triangle (see triangle documentation) (default &lsquo;a0.005q&rsquo;)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v2 : #v2 by 2 coordinates of the vertives of the generated triangulation</p>
<p>f2 : #f2 by 3 array of indices forming the faces of the generated triangulation</p>
<p>m2 : (only if you passed in m) #v2 list of markers for output vertices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>v2, f2 = triangulate(v, e, h)</p>
<hr />
<h3 id="uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object"><strong><code class="codehilite">uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object</code></strong><a class="headerlink" href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object" title="Permanent link">&para;</a></h3>
<p>Find uniform sampling up to placing samples on mesh vertices</p>
<p><strong>Parameters</strong></p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object"><strong><code class="codehilite">uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object</code></strong><a class="headerlink" href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object" title="Permanent link">&para;</a></h3>
<p>UNIFORMLY_SAMPLE_TWO_MANIFOLD Attempt to sample a mesh uniformly by</p>
<p>furthest point relaxation as described in &ldquo;Fast Automatic Skinning</p>
<p>Transformations&rdquo;</p>
<p>[Jacobson et al. 12] Section 3.3.</p>
<p><strong>Parameters</strong></p>
<p>W  #W by dim positions of mesh in weight space</p>
<p>F  #F by 3 indices of triangles</p>
<p>k  number of samplse</p>
<p>push  factor by which corners should be pushed away</p>
<hr />
<p><strong>Returns</strong></p>
<p>WS  k by dim locations in weights space</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="unprojectwin-array-model-array-proj-array-viewport-array-object"><strong><code class="codehilite">unproject(win: array, model: array, proj: array, viewport: array) -&gt; object</code></strong><a class="headerlink" href="#unprojectwin-array-model-array-proj-array-viewport-array-object" title="Permanent link">&para;</a></h3>
<p>Reimplementation of gluUnproject</p>
<p><strong>Parameters</strong></p>
<p>win  #P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates</p>
<p>model  4x4 model-view matrix</p>
<p>proj  4x4 projection matrix</p>
<p>viewport  4-long viewport vector</p>
<hr />
<p><strong>Returns</strong></p>
<p>scene  #P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit"><strong><code class="codehilite">unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]</code></strong><a class="headerlink" href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit" title="Permanent link">&para;</a></h3>
<p>Unproject a screen location (using current opengl viewport, projection, and</p>
<p>model view) to a 3D position <em>inside</em> a given mesh. If the ray through the</p>
<p>given screen location (x,y) <em>hits</em> the mesh more than twice then the 3D</p>
<p>midpoint between the first two hits is return. If it hits once, then that</p>
<p>point is return. If it does not hit the mesh then obj is not set.</p>
<p><strong>Parameters</strong></p>
<p>pos        screen space coordinates</p>
<p>model      model matrix</p>
<p>proj       projection matrix</p>
<p>viewport   vieweport vector</p>
<p>V   #V by 3 list of mesh vertex positions</p>
<p>F   #F by 3 list of mesh triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>obj        3d unprojected mouse point in mesh</p>
<p>hits       vector of hits</p>
<p><strong>Returns number of hits</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object"><strong><code class="codehilite">unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]</code></strong><a class="headerlink" href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object" title="Permanent link">&para;</a></h3>
<p>Unproject a screen location (using current opengl viewport, projection, and</p>
<p>model view) to a 3D position <em>onto</em> a given mesh, if the ray through the</p>
<p>given screen location (x,y) <em>hits</em> the mesh.</p>
<p><strong>Parameters</strong></p>
<p>pos        screen space coordinates</p>
<p>model      model matrix</p>
<p>proj       projection matrix</p>
<p>viewport   vieweport vector</p>
<p>V   #V by 3 list of mesh vertex positions</p>
<p>F   #F by 3 list of mesh triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>fid  id of the first face hit</p>
<p>bc  barycentric coordinates of hit</p>
<p><strong>Returns true if there&rsquo;s a hit</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object"><strong><code class="codehilite">unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Construct a ray (source point + direction vector) given a screen space</p>
<p>positions (e.g. mouse) and a model-view projection constellation.</p>
<p><strong>Parameters</strong></p>
<p>pos  2d screen-space position (x,y)</p>
<p>model  4x4 model-view matrix</p>
<p>proj  4x4 projection matrix</p>
<p>viewport  4-long viewport vector</p>
<hr />
<p><strong>Returns</strong></p>
<p>s  source of ray (pos unprojected with z=0)</p>
<p>dir  direction of ray (d - s) where d is pos unprojected with z=1</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object"><strong><code class="codehilite">upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Subdivide a mesh without moving vertices: loop subdivision but odd</p>
<p>vertices stay put and even vertices are just edge midpoints</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim  mesh vertices</p>
<p>F  #F by 3  mesh triangles</p>
<hr />
<p><strong>Returns</strong></p>
<p>NV new vertex positions, V is guaranteed to be at top</p>
<p>NF new list of face indices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<ul>
<li>assumes (V,F) is edge-manifold.</li>
</ul>
<p><strong>Examples</strong></p>
<hr />
<h3 id="vector_area_matrixf-array-object"><strong><code class="codehilite">vector_area_matrix(f: array) -&gt; object</code></strong><a class="headerlink" href="#vector_area_matrixf-array-object" title="Permanent link">&para;</a></h3>
<p>Constructs the symmetric area matrix A, s.t. [V.col(0)&rsquo; V.col(1)&rsquo;] * A *</p>
<p>[V.col(0); V.col(1)] is the <strong>vector area</strong> of the mesh (V,F).</p>
<p><strong>Parameters</strong></p>
<p>f : #f by 3 array of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p>a : #vx2 by #vx2 area matrix</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="vertex_componentsf-array-object"><strong><code class="codehilite">vertex_components(f: array) -&gt; object</code></strong><a class="headerlink" href="#vertex_componentsf-array-object" title="Permanent link">&para;</a></h3>
<p>Compute connected components of the vertices of a mesh given the mesh&rsquo; face indices.</p>
<p><strong>Parameters</strong></p>
<p>f : #f x dim array of face indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>An array of component ids (starting with 0)</p>
<hr />
<p><strong>See also</strong></p>
<p>vertex_components_from_adjacency_matrix</p>
<p>face_components_from_faces</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object"><strong><code class="codehilite">vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>Compute connected components of a graph represented by a sparse adjacency</p>
<p>matrix.</p>
<p><strong>Parameters</strong></p>
<p>a : n by n sparse adjacency matrix</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple (c, counts) where c is an array of component ids (starting with 0)</p>
<p>and counts is a #components array of counts for each component</p>
<hr />
<p><strong>See also</strong></p>
<p>vertex_components</p>
<p>face_components</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="vertex_triangle_adjacencyf-array-n-int-tupleobject-object"><strong><code class="codehilite">vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#vertex_triangle_adjacencyf-array-n-int-tupleobject-object" title="Permanent link">&para;</a></h3>
<p>vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of triangle indices into some vertex list V</p>
<p>n  number of vertices, #V (e.g., F.maxCoeff()+1)</p>
<hr />
<p><strong>Returns</strong></p>
<p>VF  3*#F list  List of faces indice on each vertex, so that VF(NI(i)+j) =</p>
<p>f, means that face f is the jth face (in no particular order) incident</p>
<p>on vertex i.</p>
<p>NI  #V+1 list  cumulative sum of vertex-triangle degrees with a</p>
<p>preceeding zero. &ldquo;How many faces&rdquo; have been seen before visiting this</p>
<p>vertex and its incident faces.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="winding_numberv-array-f-array-o-array-object"><strong><code class="codehilite">winding_number(v: array, f: array, o: array) -&gt; object</code></strong><a class="headerlink" href="#winding_numberv-array-f-array-o-array-object" title="Permanent link">&para;</a></h3>
<p>WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron</p>
<p>described by points (vectors) V</p>
<p><strong>Parameters</strong></p>
<p>V  n by 3 list of vertex positions</p>
<p>F  #F by 3 list of triangle indices, minimum index is 0</p>
<p>O  no by 3 list of origin positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  no by 1 list of winding numbers</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="winding_number_for_pointv-array-f-array-p-array-float"><strong><code class="codehilite">winding_number_for_point(v: array, f: array, p: array) -&gt; float</code></strong><a class="headerlink" href="#winding_number_for_pointv-array-f-array-p-array-float" title="Permanent link">&para;</a></h3>
<p>Compute winding number of a single point</p>
<p><strong>Parameters</strong></p>
<p>V  n by dim list of vertex positions</p>
<p>F  #F by dim list of triangle indices, minimum index is 0</p>
<p>p  single origin position</p>
<hr />
<p><strong>Returns</strong></p>
<p>w  winding number of this point</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="write_objfilename-str-v-array-f-array-bool"><strong><code class="codehilite">write_obj(filename: str, v: array, f: array) -&gt; bool</code></strong><a class="headerlink" href="#write_objfilename-str-v-array-f-array-bool" title="Permanent link">&para;</a></h3>
<p>Write a mesh in an ascii obj file.</p>
<p><strong>Parameters</strong></p>
<p>filename : path to outputfile</p>
<p>v : array of vertex positions #v by 3</p>
<p>f : #f list of face indices into vertex positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>ret : bool if output was successful</p>
<hr />
<p><strong>See also</strong></p>
<p>read_obj</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>success = write_obj(v, f)</p>
<hr />
<h3 id="write_offstr-str-v-array-f-array-c-array-bool"><strong><code class="codehilite">write_off(str: str, v: array, f: array, c: array) -&gt; bool</code></strong><a class="headerlink" href="#write_offstr-str-v-array-f-array-c-array-bool" title="Permanent link">&para;</a></h3>
<p>Export geometry and colors-by-vertex</p>
<p>Export a mesh from an ascii OFF file, filling in vertex positions.</p>
<p>Only triangle meshes are supported</p>
<p><strong>Parameters</strong></p>
<p>str  path to .off output file</p>
<p>V  #V by 3 mesh vertex positions</p>
<p>F  #F by 3 mesh indices into V</p>
<p>C  double matrix of rgb values per vertex #V by 3</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns true on success, false on errors</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool"><strong><code class="codehilite">write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool</code></strong><a class="headerlink" href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool" title="Permanent link">&para;</a></h3>
<p>write mesh to a file with automatic detection of file format.  supported: obj, off, stl, wrl, ply, mesh).</p>
<p><strong>Parameters</strong></p>
<p>str  path to file</p>
<p>V  eigen double matrix #V by 3</p>
<p>F  eigen int matrix #F by 3</p>
<p>force_ascii=True  force ascii format even if binary is available</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns true iff success</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>VERSION</p>
<p>dev</p>
<p>FILE</p>
<p>/Users/teseo/data/igl/python/igl/pyigl.cpython-36m-darwin.so</p>
<p>igl.adjacency_list = adjacency_list(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="adjacency_listf-array-handle_1"><strong><code class="codehilite">adjacency_list(f: array) -&gt; handle</code></strong><a class="headerlink" href="#adjacency_listf-array-handle_1" title="Permanent link">&para;</a></h3>
<p>Constructs the graph adjacency list of a given mesh (v, f)</p>
<p><strong>Parameters</strong></p>
<p>f : #f by dim array of fixed dimensional (e.g. triangle (#f by 3),</p>
<p>tet (#f by 4), quad (#f by 4), etc&hellip;) mesh faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>list of lists containing at index i the adjacent vertices of vertex i</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>a = mesh_adjacency_list(f)</p>
<p>igl.adjacency_list = adjacency_list(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="adjacency_listf-array-handle_2"><strong><code class="codehilite">adjacency_list(f: array) -&gt; handle</code></strong><a class="headerlink" href="#adjacency_listf-array-handle_2" title="Permanent link">&para;</a></h3>
<p>Constructs the graph adjacency list of a given mesh (v, f)</p>
<p><strong>Parameters</strong></p>
<p>f : #f by dim array of fixed dimensional (e.g. triangle (#f by 3),</p>
<p>tet (#f by 4), quad (#f by 4), etc&hellip;) mesh faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>list of lists containing at index i the adjacent vertices of vertex i</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>a = mesh_adjacency_list(f)</p>
<p>igl.adjacency_matrix = adjacency_matrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="adjacency_matrixf-array-object_1"><strong><code class="codehilite">adjacency_matrix(f: array) -&gt; object</code></strong><a class="headerlink" href="#adjacency_matrixf-array-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs the graph adjacency matrix of a given mesh (v, f).</p>
<p><strong>Parameters</strong></p>
<p>f : #f by dim list of mesh simplices</p>
<hr />
<p><strong>Returns</strong></p>
<p>a : max(f) by max(f) cotangent matrix, each row i corresponding to v(i, :)</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_list, edges, cotmatrix, diag</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>a = adjacency_matrix(f)</p>
<p>Sum each row</p>
<p>a_sum = np.sum(a, axis=1)</p>
<p>Convert row sums into diagonal of sparse matrix</p>
<p>a_diag = diag(a_sum)</p>
<p>Build uniform laplacian</p>
<p>u = a - a_diag</p>
<p>igl.adjacency_matrix = adjacency_matrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="adjacency_matrixf-array-object_2"><strong><code class="codehilite">adjacency_matrix(f: array) -&gt; object</code></strong><a class="headerlink" href="#adjacency_matrixf-array-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs the graph adjacency matrix of a given mesh (v, f).</p>
<p><strong>Parameters</strong></p>
<p>f : #f by dim list of mesh simplices</p>
<hr />
<p><strong>Returns</strong></p>
<p>a : max(f) by max(f) cotangent matrix, each row i corresponding to v(i, :)</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_list, edges, cotmatrix, diag</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>a = adjacency_matrix(f)</p>
<p>Sum each row</p>
<p>a_sum = np.sum(a, axis=1)</p>
<p>Convert row sums into diagonal of sparse matrix</p>
<p>a_diag = diag(a_sum)</p>
<p>Build uniform laplacian</p>
<p>u = a - a_diag</p>
<p>igl.ambient_occlusion = ambient_occlusion(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object_1"><strong><code class="codehilite">ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object</code></strong><a class="headerlink" href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object_1" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh face indices into V</p>
<p>P  #P by 3 list of origin points</p>
<p>N  #P by 3 list of origin normals</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  #P list of ambient occusion values between 1 (fully occluded) and 0 (not occluded)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.ambient_occlusion = ambient_occlusion(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object_2"><strong><code class="codehilite">ambient_occlusion(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object</code></strong><a class="headerlink" href="#ambient_occlusionv-array-f-array-p-array-n-array-num_samples-int-object_2" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh face indices into V</p>
<p>P  #P by 3 list of origin points</p>
<p>N  #P by 3 list of origin normals</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  #P list of ambient occusion values between 1 (fully occluded) and 0 (not occluded)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.arap_linear_block = arap_linear_block(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="arap_linear_blockv-array-f-array-d-int-energy-int-object_1"><strong><code class="codehilite">arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_blockv-array-f-array-d-int-energy-int-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.arap_linear_block = arap_linear_block(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="arap_linear_blockv-array-f-array-d-int-energy-int-object_2"><strong><code class="codehilite">arap_linear_block(v: array, f: array, d: int, energy: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_blockv-array-f-array-d-int-energy-int-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.arap_linear_block_elements = arap_linear_block_elements(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="arap_linear_block_elementsv-array-f-array-d-int-object_1"><strong><code class="codehilite">arap_linear_block_elements(v: array, f: array, d: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_block_elementsv-array-f-array-d-int-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.arap_linear_block_elements = arap_linear_block_elements(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="arap_linear_block_elementsv-array-f-array-d-int-object_2"><strong><code class="codehilite">arap_linear_block_elements(v: array, f: array, d: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_block_elementsv-array-f-array-d-int-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.arap_linear_block_spokes = arap_linear_block_spokes(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="arap_linear_block_spokesv-array-f-array-d-int-object_1"><strong><code class="codehilite">arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_block_spokesv-array-f-array-d-int-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.arap_linear_block_spokes = arap_linear_block_spokes(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="arap_linear_block_spokesv-array-f-array-d-int-object_2"><strong><code class="codehilite">arap_linear_block_spokes(v: array, f: array, d: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_block_spokesv-array-f-array-d-int-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.arap_linear_block_spokes_and_rims = arap_linear_block_spokes_and_rims(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object_1"><strong><code class="codehilite">arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.arap_linear_block_spokes_and_rims = arap_linear_block_spokes_and_rims(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object_2"><strong><code class="codehilite">arap_linear_block_spokes_and_rims(v: array, f: array, d: int) -&gt; object</code></strong><a class="headerlink" href="#arap_linear_block_spokes_and_rimsv-array-f-array-d-int-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs a block of the matrix which constructs the</p>
<p>linear terms of a given arap energy. When treating rotations as knowns</p>
<p>(arranged in a column), then this constructs Kd of K such that the linear</p>
<p>portion of the energy is as a column:</p>
<p>K * R = [Kx Z  &hellip; Ky Z  &hellip;</p>
<p>Z  Kx &hellip; Z  Ky &hellip;</p>
<p>&hellip; ]</p>
<p>These blocks are also used to build the &ldquo;covariance scatter matrices&rdquo;.</p>
<p>Here we want to build a scatter matrix that multiplies against positions</p>
<p>(treated as known) producing covariance matrices to fit each rotation.</p>
<p>Notice that in the case of the RHS of the poisson solve the rotations are</p>
<p>known and the positions unknown, and vice versa for rotation fitting.</p>
<p>These linear block just relate the rotations to the positions, linearly in</p>
<p>each.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of initial domain positions</p>
<p>f : #f by #simplex size list of triangle indices into V</p>
<p>d : coordinate of linear constructor to build</p>
<hr />
<p><strong>Returns</strong></p>
<p>by #v/#f block of the linear constructor matrix corresponding to coordinate d</p>
<hr />
<p><strong>See also</strong></p>
<p>arap, arap_dof</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.arap_rhs = arap_rhs(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="arap_rhsv-array-f-array-d-int-energy-int-object_1"><strong><code class="codehilite">arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object</code></strong><a class="headerlink" href="#arap_rhsv-array-f-array-d-int-energy-int-object_1" title="Permanent link">&para;</a></h3>
<p>Guild right-hand side constructor of global poisson solve for various ARAP energies</p>
<p>Inputs:</p>
<p>Outputs:</p>
<p>K  #V*dim by #(FV)*dim*dim matrix such that:</p>
<p>b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1);</p>
<p><strong>Parameters</strong></p>
<p>v : #v by Vdim list of initial domain positions</p>
<p>f : #f by 3 list of triangle indices into v</p>
<p>d : dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2</p>
<p>energy : ARAPEnergyType enum value defining which energy is being used. See igl.ARAPEnergyType for valid options and explanations.</p>
<hr />
<p><strong>Returns</strong></p>
<p>*d by #(fv)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1);</p>
<hr />
<p><strong>See also</strong></p>
<p>arap_linear_block, arap</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.arap_rhs = arap_rhs(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="arap_rhsv-array-f-array-d-int-energy-int-object_2"><strong><code class="codehilite">arap_rhs(v: array, f: array, d: int, energy: int) -&gt; object</code></strong><a class="headerlink" href="#arap_rhsv-array-f-array-d-int-energy-int-object_2" title="Permanent link">&para;</a></h3>
<p>Guild right-hand side constructor of global poisson solve for various ARAP energies</p>
<p>Inputs:</p>
<p>Outputs:</p>
<p>K  #V*dim by #(FV)*dim*dim matrix such that:</p>
<p>b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1);</p>
<p><strong>Parameters</strong></p>
<p>v : #v by Vdim list of initial domain positions</p>
<p>f : #f by 3 list of triangle indices into v</p>
<p>d : dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2</p>
<p>energy : ARAPEnergyType enum value defining which energy is being used. See igl.ARAPEnergyType for valid options and explanations.</p>
<hr />
<p><strong>Returns</strong></p>
<p>*d by #(fv)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(VF,1)*size(V,2)*size(V,2),1);</p>
<hr />
<p><strong>See also</strong></p>
<p>arap_linear_block, arap</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.average_onto_vertices = average_onto_vertices(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="average_onto_verticesv-array-f-array-s-array-object_1"><strong><code class="codehilite">average_onto_vertices(v: array, f: array, s: array) -&gt; object</code></strong><a class="headerlink" href="#average_onto_verticesv-array-f-array-s-array-object_1" title="Permanent link">&para;</a></h3>
<p>Move a scalar field defined on faces to vertices by averaging</p>
<p><strong>Parameters</strong></p>
<p>v : #v by vdim array of mesh vertices</p>
<p>f : #f by simplex_count array of simplex indices</p>
<p>s : #f by dim scalar field defined on simplices</p>
<hr />
<p><strong>Returns</strong></p>
<p>by dim scalar field defined on vertices</p>
<hr />
<p><strong>See also</strong></p>
<p>average_onto_faces</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.average_onto_vertices = average_onto_vertices(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="average_onto_verticesv-array-f-array-s-array-object_2"><strong><code class="codehilite">average_onto_vertices(v: array, f: array, s: array) -&gt; object</code></strong><a class="headerlink" href="#average_onto_verticesv-array-f-array-s-array-object_2" title="Permanent link">&para;</a></h3>
<p>Move a scalar field defined on faces to vertices by averaging</p>
<p><strong>Parameters</strong></p>
<p>v : #v by vdim array of mesh vertices</p>
<p>f : #f by simplex_count array of simplex indices</p>
<p>s : #f by dim scalar field defined on simplices</p>
<hr />
<p><strong>Returns</strong></p>
<p>by dim scalar field defined on vertices</p>
<hr />
<p><strong>See also</strong></p>
<p>average_onto_faces</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.avg_edge_length = avg_edge_length(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="avg_edge_lengthv-array-f-array-float_1"><strong><code class="codehilite">avg_edge_length(v: array, f: array) -&gt; float</code></strong><a class="headerlink" href="#avg_edge_lengthv-array-f-array-float_1" title="Permanent link">&para;</a></h3>
<p>Compute the average edge length for the given triangle mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : array_like #v by 3 vertex array</p>
<p>f : f #f by simplex-size list of mesh faces (must be simplex)</p>
<hr />
<p><strong>Returns</strong></p>
<p>l : average edge length</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>length = avg_edge_length(v, f)</p>
<p>igl.avg_edge_length = avg_edge_length(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="avg_edge_lengthv-array-f-array-float_2"><strong><code class="codehilite">avg_edge_length(v: array, f: array) -&gt; float</code></strong><a class="headerlink" href="#avg_edge_lengthv-array-f-array-float_2" title="Permanent link">&para;</a></h3>
<p>Compute the average edge length for the given triangle mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : array_like #v by 3 vertex array</p>
<p>f : f #f by simplex-size list of mesh faces (must be simplex)</p>
<hr />
<p><strong>Returns</strong></p>
<p>l : average edge length</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>length = avg_edge_length(v, f)</p>
<p>igl.barycenter = barycenter(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="barycenterv-array-f-array-object_1"><strong><code class="codehilite">barycenter(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#barycenterv-array-f-array-object_1" title="Permanent link">&para;</a></h3>
<p>Compute the barycenter of every simplex</p>
<p><strong>Parameters</strong></p>
<p>v : #v x dim matrix of vertex coordinates</p>
<p>f : #f x simplex_size  matrix of indices of simplex corners into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>A #f x dim matrix where each row is the barycenter of each simplex</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.barycenter = barycenter(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="barycenterv-array-f-array-object_2"><strong><code class="codehilite">barycenter(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#barycenterv-array-f-array-object_2" title="Permanent link">&para;</a></h3>
<p>Compute the barycenter of every simplex</p>
<p><strong>Parameters</strong></p>
<p>v : #v x dim matrix of vertex coordinates</p>
<p>f : #f x simplex_size  matrix of indices of simplex corners into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>A #f x dim matrix where each row is the barycenter of each simplex</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.barycentric_coordinates_tet = barycentric_coordinates_tet(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object_1"><strong><code class="codehilite">barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object</code></strong><a class="headerlink" href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object_1" title="Permanent link">&para;</a></h3>
<p>Compute barycentric coordinates in a tet corresponding to the Euclidean coordinates in <code class="codehilite">p</code>.</p>
<p>The input arrays <code class="codehilite">a</code>, <code class="codehilite">b</code>, <code class="codehilite">c</code> and <code class="codehilite">d</code> are the vertices of each tet. I.e. one tet is</p>
<p><code class="codehilite">a[i, :], b[i, :], c[i, :], d[:, i]</code>.</p>
<p><strong>Parameters</strong></p>
<p>p : #P by 3 Query points in 3d</p>
<p>a : #P by 3 Tet corners in 3d</p>
<p>b : #P by 3 Tet corners in 3d</p>
<p>c : #P by 3 Tet corners in 3d</p>
<p>d : #P by 3 Tet corners in 3d</p>
<hr />
<p><strong>Returns</strong></p>
<p>by 4 list of barycentric coordinates</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.barycentric_coordinates_tet = barycentric_coordinates_tet(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object_2"><strong><code class="codehilite">barycentric_coordinates_tet(p: array, a: array, b: array, c: array, d: array) -&gt; object</code></strong><a class="headerlink" href="#barycentric_coordinates_tetp-array-a-array-b-array-c-array-d-array-object_2" title="Permanent link">&para;</a></h3>
<p>Compute barycentric coordinates in a tet corresponding to the Euclidean coordinates in <code class="codehilite">p</code>.</p>
<p>The input arrays <code class="codehilite">a</code>, <code class="codehilite">b</code>, <code class="codehilite">c</code> and <code class="codehilite">d</code> are the vertices of each tet. I.e. one tet is</p>
<p><code class="codehilite">a[i, :], b[i, :], c[i, :], d[:, i]</code>.</p>
<p><strong>Parameters</strong></p>
<p>p : #P by 3 Query points in 3d</p>
<p>a : #P by 3 Tet corners in 3d</p>
<p>b : #P by 3 Tet corners in 3d</p>
<p>c : #P by 3 Tet corners in 3d</p>
<p>d : #P by 3 Tet corners in 3d</p>
<hr />
<p><strong>Returns</strong></p>
<p>by 4 list of barycentric coordinates</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.barycentric_coordinates_tri = barycentric_coordinates_tri(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="barycentric_coordinates_trip-array-a-array-b-array-c-array-object_1"><strong><code class="codehilite">barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object</code></strong><a class="headerlink" href="#barycentric_coordinates_trip-array-a-array-b-array-c-array-object_1" title="Permanent link">&para;</a></h3>
<p>Compute barycentric coordinates in a triangle corresponding to the Euclidean coordinates in <code class="codehilite">p</code>.</p>
<p>The input arrays <code class="codehilite">a</code>, <code class="codehilite">b</code>, and <code class="codehilite">c</code> are the vertices of each triangle. I.e. one triangle is</p>
<p><code class="codehilite">a[i, :], b[i, :], c[i, :]</code>.</p>
<p><strong>Parameters</strong></p>
<p>p : #P by 3 Query points in 3d</p>
<p>a : #P by 3 Tri corners in 3d</p>
<p>b : #P by 3 Tri corners in 3d</p>
<p>c : #P by 3 Tri corners in 3d</p>
<hr />
<p><strong>Returns</strong></p>
<p>by 3 list of barycentric coordinates</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.barycentric_coordinates_tri = barycentric_coordinates_tri(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="barycentric_coordinates_trip-array-a-array-b-array-c-array-object_2"><strong><code class="codehilite">barycentric_coordinates_tri(p: array, a: array, b: array, c: array) -&gt; object</code></strong><a class="headerlink" href="#barycentric_coordinates_trip-array-a-array-b-array-c-array-object_2" title="Permanent link">&para;</a></h3>
<p>Compute barycentric coordinates in a triangle corresponding to the Euclidean coordinates in <code class="codehilite">p</code>.</p>
<p>The input arrays <code class="codehilite">a</code>, <code class="codehilite">b</code>, and <code class="codehilite">c</code> are the vertices of each triangle. I.e. one triangle is</p>
<p><code class="codehilite">a[i, :], b[i, :], c[i, :]</code>.</p>
<p><strong>Parameters</strong></p>
<p>p : #P by 3 Query points in 3d</p>
<p>a : #P by 3 Tri corners in 3d</p>
<p>b : #P by 3 Tri corners in 3d</p>
<p>c : #P by 3 Tri corners in 3d</p>
<hr />
<p><strong>Returns</strong></p>
<p>by 3 list of barycentric coordinates</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.bfs = bfs(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object_1"><strong><code class="codehilite">bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Construct an array indexing into a <strong>directed</strong> graph represented by an adjacency list using</p>
<p>breadth first search. I.e. the output is an array of vertices in breadth-first order.</p>
<p><strong>Parameters</strong></p>
<p>A : #V list of adjacency lists  or #V by #V adjacency matrix</p>
<p>s : starting node (index into A)</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple, (d, p) where:</p>
<ul>
<li>
<p>d is a #V list of indices into rows of A in the order in which graph nodes are discovered</p>
</li>
<li>
<p>p is a #V list of indices of A of predecsors where -1 indicates root/not discovered. I.e.</p>
</li>
</ul>
<p>p[i] is the index of the vertex v which preceded d[i] in the breadth first traversal.</p>
<p>Note that together, (d, p) form a spanning tree of the input graph</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>V, F, _ = igl.readOFF(&ldquo;test.off)</p>
<p>A = igl.adjacency_matrix(V, F)</p>
<p>d, p = igl.bfs(A, V[0])</p>
<p>igl.bfs = bfs(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object_2"><strong><code class="codehilite">bfs(A: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, s: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bfsa-scipysparsecsr_matrix-scipysparsecsc_matrix-s-int-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Construct an array indexing into a <strong>directed</strong> graph represented by an adjacency list using</p>
<p>breadth first search. I.e. the output is an array of vertices in breadth-first order.</p>
<p><strong>Parameters</strong></p>
<p>A : #V list of adjacency lists  or #V by #V adjacency matrix</p>
<p>s : starting node (index into A)</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple, (d, p) where:</p>
<ul>
<li>
<p>d is a #V list of indices into rows of A in the order in which graph nodes are discovered</p>
</li>
<li>
<p>p is a #V list of indices of A of predecsors where -1 indicates root/not discovered. I.e.</p>
</li>
</ul>
<p>p[i] is the index of the vertex v which preceded d[i] in the breadth first traversal.</p>
<p>Note that together, (d, p) form a spanning tree of the input graph</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>V, F, _ = igl.readOFF(&ldquo;test.off)</p>
<p>A = igl.adjacency_matrix(V, F)</p>
<p>d, p = igl.bfs(A, V[0])</p>
<p>igl.bfs_orient = bfs_orient(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="bfs_orientf-array-tupleobject-object_1"><strong><code class="codehilite">bfs_orient(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bfs_orientf-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Consistently orient faces in orientable patches using BFS.</p>
<p><strong>Parameters</strong></p>
<p>f : #F by 3 list of faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple, (ff, c) where:</p>
<ul>
<li>
<p>ff is a #F by 3 list of faces which are consistently oriented with</p>
</li>
<li>
<p>c is a #F array of connected component ids</p>
</li>
</ul>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>v, f, _ = igl.readOFF(&ldquo;test.off)</p>
<p>ff, c = igl.bfs_orient(f)</p>
<p>igl.bfs_orient = bfs_orient(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="bfs_orientf-array-tupleobject-object_2"><strong><code class="codehilite">bfs_orient(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bfs_orientf-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Consistently orient faces in orientable patches using BFS.</p>
<p><strong>Parameters</strong></p>
<p>f : #F by 3 list of faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple, (ff, c) where:</p>
<ul>
<li>
<p>ff is a #F by 3 list of faces which are consistently oriented with</p>
</li>
<li>
<p>c is a #F array of connected component ids</p>
</li>
</ul>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>v, f, _ = igl.readOFF(&ldquo;test.off)</p>
<p>ff, c = igl.bfs_orient(f)</p>
<p>igl.bone_parents = bone_parents(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="bone_parentsbe-array-object_1"><strong><code class="codehilite">bone_parents(be: array) -&gt; object</code></strong><a class="headerlink" href="#bone_parentsbe-array-object_1" title="Permanent link">&para;</a></h3>
<p>BONE_PARENTS Recover &ldquo;parent&rdquo; bones from directed graph representation.</p>
<p><strong>Parameters</strong></p>
<p>BE  #BE by 2 list of directed bone edges</p>
<hr />
<p><strong>Returns</strong></p>
<p>P  #BE by 1 list of parent indices into BE, -1 means root.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.bone_parents = bone_parents(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="bone_parentsbe-array-object_2"><strong><code class="codehilite">bone_parents(be: array) -&gt; object</code></strong><a class="headerlink" href="#bone_parentsbe-array-object_2" title="Permanent link">&para;</a></h3>
<p>BONE_PARENTS Recover &ldquo;parent&rdquo; bones from directed graph representation.</p>
<p><strong>Parameters</strong></p>
<p>BE  #BE by 2 list of directed bone edges</p>
<hr />
<p><strong>Returns</strong></p>
<p>P  #BE by 1 list of parent indices into BE, -1 means root.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.boundary_conditions = boundary_conditions(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object_1"><strong><code class="codehilite">boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]</code></strong><a class="headerlink" href="#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object_1" title="Permanent link">&para;</a></h3>
<p>Compute boundary conditions for automatic weights computation. This</p>
<p>function expects that the given mesh (V,Ele) has sufficient samples</p>
<p>(vertices) exactly at point handle locations and exactly along bone and</p>
<p>cage edges.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of domain vertices</p>
<p>Ele  #Ele by simplex-size list of simplex indices</p>
<p>C  #C by dim list of handle positions</p>
<p>P  #P by 1 list of point handle indices into C</p>
<p>BE  #BE by 2 list of bone edge indices into C</p>
<p>CE  #CE by 2 list of cage edge indices into <em>P</em></p>
<hr />
<p><strong>Returns</strong></p>
<p>b  #b list of boundary indices (indices into V of vertices which have</p>
<p>known, fixed values)</p>
<p>bc #b by #weights list of known/fixed values for boundary vertices</p>
<p>(notice the #b != #weights in general because #b will include all the</p>
<p>intermediary samples along each bone, etc.. The ordering of the</p>
<p>weights corresponds to [P;BE]</p>
<p><strong>Returns false if boundary conditions are suspicious:</strong></p>
<p>P and BE are empty</p>
<p>bc is empty</p>
<p>some column of bc doesn&rsquo;t have a 0 (assuming bc has &gt;1 columns)</p>
<p>some column of bc doesn&rsquo;t have a 1 (assuming bc has &gt;1 columns)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.boundary_conditions = boundary_conditions(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object_2"><strong><code class="codehilite">boundary_conditions(v: array, ele: array, c: array, p: array, be: array, ce: array) -&gt; Tuple[bool, object, object]</code></strong><a class="headerlink" href="#boundary_conditionsv-array-ele-array-c-array-p-array-be-array-ce-array-tuplebool-object-object_2" title="Permanent link">&para;</a></h3>
<p>Compute boundary conditions for automatic weights computation. This</p>
<p>function expects that the given mesh (V,Ele) has sufficient samples</p>
<p>(vertices) exactly at point handle locations and exactly along bone and</p>
<p>cage edges.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of domain vertices</p>
<p>Ele  #Ele by simplex-size list of simplex indices</p>
<p>C  #C by dim list of handle positions</p>
<p>P  #P by 1 list of point handle indices into C</p>
<p>BE  #BE by 2 list of bone edge indices into C</p>
<p>CE  #CE by 2 list of cage edge indices into <em>P</em></p>
<hr />
<p><strong>Returns</strong></p>
<p>b  #b list of boundary indices (indices into V of vertices which have</p>
<p>known, fixed values)</p>
<p>bc #b by #weights list of known/fixed values for boundary vertices</p>
<p>(notice the #b != #weights in general because #b will include all the</p>
<p>intermediary samples along each bone, etc.. The ordering of the</p>
<p>weights corresponds to [P;BE]</p>
<p><strong>Returns false if boundary conditions are suspicious:</strong></p>
<p>P and BE are empty</p>
<p>bc is empty</p>
<p>some column of bc doesn&rsquo;t have a 0 (assuming bc has &gt;1 columns)</p>
<p>some column of bc doesn&rsquo;t have a 1 (assuming bc has &gt;1 columns)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.boundary_facets = boundary_facets(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="boundary_facetst-array-object_1"><strong><code class="codehilite">boundary_facets(t: array) -&gt; object</code></strong><a class="headerlink" href="#boundary_facetst-array-object_1" title="Permanent link">&para;</a></h3>
<p>Determine boundary faces (edges) of tetrahedra (triangles).</p>
<p><strong>Parameters</strong></p>
<p>t : tetrahedron or triangle index list, m by 4/3, where m is the number of tetrahedra/triangles</p>
<hr />
<p><strong>Returns</strong></p>
<p>f : list of boundary faces, n by 3/2, where n is the number of boundary faces/edges</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>b = boundary_facets(f)</p>
<p>igl.boundary_facets = boundary_facets(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="boundary_facetst-array-object_2"><strong><code class="codehilite">boundary_facets(t: array) -&gt; object</code></strong><a class="headerlink" href="#boundary_facetst-array-object_2" title="Permanent link">&para;</a></h3>
<p>Determine boundary faces (edges) of tetrahedra (triangles).</p>
<p><strong>Parameters</strong></p>
<p>t : tetrahedron or triangle index list, m by 4/3, where m is the number of tetrahedra/triangles</p>
<hr />
<p><strong>Returns</strong></p>
<p>f : list of boundary faces, n by 3/2, where n is the number of boundary faces/edges</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>b = boundary_facets(f)</p>
<p>igl.boundary_loop = boundary_loop(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="boundary_loopf-array-object_1"><strong><code class="codehilite">boundary_loop(f: array) -&gt; object</code></strong><a class="headerlink" href="#boundary_loopf-array-object_1" title="Permanent link">&para;</a></h3>
<p>Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices.</p>
<p><strong>Parameters</strong></p>
<p>f : #v by dim array of mesh faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>l : ordered list of boundary vertices of longest boundary loop</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>l = boundary_loop(f)</p>
<p>igl.boundary_loop = boundary_loop(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="boundary_loopf-array-object_2"><strong><code class="codehilite">boundary_loop(f: array) -&gt; object</code></strong><a class="headerlink" href="#boundary_loopf-array-object_2" title="Permanent link">&para;</a></h3>
<p>Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices.</p>
<p><strong>Parameters</strong></p>
<p>f : #v by dim array of mesh faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>l : ordered list of boundary vertices of longest boundary loop</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>l = boundary_loop(f)</p>
<p>igl.bounding_box = bounding_box(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="bounding_boxargs-kwargs_1"><strong><code class="codehilite">bounding_box(*args, **kwargs)</code></strong><a class="headerlink" href="#bounding_boxargs-kwargs_1" title="Permanent link">&para;</a></h3>
<hr />
<h3 id="bounding_boxv-array-tupleobject-object_1"><strong><code class="codehilite">bounding_box(v: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bounding_boxv-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Build a triangle mesh of the bounding box of a given list of vertices</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of rest domain positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>BV  2^dim by dim list of bounding box corners positions</p>
<p>BF  #BF by dim list of simplex facets</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="bounding_boxv-array-pad-float-tupleobject-object_1"><strong><code class="codehilite">bounding_box(v: array, pad: float) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bounding_boxv-array-pad-float-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Build a triangle mesh of the bounding box of a given list of vertices</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of rest domain positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>BV  2^dim by dim list of bounding box corners positions</p>
<p>BF  #BF by dim list of simplex facets</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.bounding_box = bounding_box(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="bounding_boxargs-kwargs_2"><strong><code class="codehilite">bounding_box(*args, **kwargs)</code></strong><a class="headerlink" href="#bounding_boxargs-kwargs_2" title="Permanent link">&para;</a></h3>
<hr />
<h3 id="bounding_boxv-array-tupleobject-object_2"><strong><code class="codehilite">bounding_box(v: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bounding_boxv-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Build a triangle mesh of the bounding box of a given list of vertices</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of rest domain positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>BV  2^dim by dim list of bounding box corners positions</p>
<p>BF  #BF by dim list of simplex facets</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<hr />
<h3 id="bounding_boxv-array-pad-float-tupleobject-object_2"><strong><code class="codehilite">bounding_box(v: array, pad: float) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#bounding_boxv-array-pad-float-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Build a triangle mesh of the bounding box of a given list of vertices</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of rest domain positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>BV  2^dim by dim list of bounding box corners positions</p>
<p>BF  #BF by dim list of simplex facets</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.bounding_box_diagonal = bounding_box_diagonal(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="bounding_box_diagonalv-array-float_1"><strong><code class="codehilite">bounding_box_diagonal(v: array) -&gt; float</code></strong><a class="headerlink" href="#bounding_box_diagonalv-array-float_1" title="Permanent link">&para;</a></h3>
<p>Compute the length of the diagonal of a given meshes axis-aligned bounding</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns length of bounding box diagonal</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.bounding_box_diagonal = bounding_box_diagonal(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="bounding_box_diagonalv-array-float_2"><strong><code class="codehilite">bounding_box_diagonal(v: array) -&gt; float</code></strong><a class="headerlink" href="#bounding_box_diagonalv-array-float_2" title="Permanent link">&para;</a></h3>
<p>Compute the length of the diagonal of a given meshes axis-aligned bounding</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns length of bounding box diagonal</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.centroid = centroid(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="centroidv-array-f-array-tupleobject_1"><strong><code class="codehilite">centroid(v: array, f: array) -&gt; Tuple[object]</code></strong><a class="headerlink" href="#centroidv-array-f-array-tupleobject_1" title="Permanent link">&para;</a></h3>
<p>Computes the centroid of a closed mesh using a surface integral.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of rest domain positions</p>
<p>f : #f by 3 array of triangle indices into v</p>
<hr />
<p><strong>Returns</strong></p>
<p>c : dim array of centroid coordinates</p>
<p>vol : total volume of solid</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>c, vol = centroid(v, f)</p>
<p>igl.centroid = centroid(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="centroidv-array-f-array-tupleobject_2"><strong><code class="codehilite">centroid(v: array, f: array) -&gt; Tuple[object]</code></strong><a class="headerlink" href="#centroidv-array-f-array-tupleobject_2" title="Permanent link">&para;</a></h3>
<p>Computes the centroid of a closed mesh using a surface integral.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of rest domain positions</p>
<p>f : #f by 3 array of triangle indices into v</p>
<hr />
<p><strong>Returns</strong></p>
<p>c : dim array of centroid coordinates</p>
<p>vol : total volume of solid</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>c, vol = centroid(v, f)</p>
<p>igl.circulation = circulation(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint_1"><strong><code class="codehilite">circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]</code></strong><a class="headerlink" href="#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint_1" title="Permanent link">&para;</a></h3>
<p>Return list of faces around the end point of an edge. Assumes</p>
<p>data-structures are built from an edge-manifold <strong>closed</strong> mesh.</p>
<p><strong>Parameters</strong></p>
<p>e  index into E of edge to circulate</p>
<p>ccw  whether to <em>continue</em> in ccw direction of edge (circulate around</p>
<hr />
<h3 id="emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique_1"><strong><code class="codehilite">EMAP #F*3 list of indices into E, mapping each directed edge to unique</code></strong><a class="headerlink" href="#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique_1" title="Permanent link">&para;</a></h3>
<p>unique edge in E</p>
<p>EF  #E by 2 list of edge flaps, EF(e,0)=f means e=(i&rarr;j) is the edge of</p>
<hr />
<h3 id="ej-i_1"><strong><code class="codehilite">e=(j-&gt;i)</code></strong><a class="headerlink" href="#ej-i_1" title="Permanent link">&para;</a></h3>
<p>EI  #E by 2 list of edge flap corners (see above).</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns list of faces touched by circulation (in cyclically order).</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.circulation = circulation(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint_2"><strong><code class="codehilite">circulation(e: int, ccw: bool, emap: array, ef: array, ei: array) -&gt; List[int]</code></strong><a class="headerlink" href="#circulatione-int-ccw-bool-emap-array-ef-array-ei-array-listint_2" title="Permanent link">&para;</a></h3>
<p>Return list of faces around the end point of an edge. Assumes</p>
<p>data-structures are built from an edge-manifold <strong>closed</strong> mesh.</p>
<p><strong>Parameters</strong></p>
<p>e  index into E of edge to circulate</p>
<p>ccw  whether to <em>continue</em> in ccw direction of edge (circulate around</p>
<hr />
<h3 id="emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique_2"><strong><code class="codehilite">EMAP #F*3 list of indices into E, mapping each directed edge to unique</code></strong><a class="headerlink" href="#emap-f3-list-of-indices-into-e-mapping-each-directed-edge-to-unique_2" title="Permanent link">&para;</a></h3>
<p>unique edge in E</p>
<p>EF  #E by 2 list of edge flaps, EF(e,0)=f means e=(i&rarr;j) is the edge of</p>
<hr />
<h3 id="ej-i_2"><strong><code class="codehilite">e=(j-&gt;i)</code></strong><a class="headerlink" href="#ej-i_2" title="Permanent link">&para;</a></h3>
<p>EI  #E by 2 list of edge flap corners (see above).</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns list of faces touched by circulation (in cyclically order).</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.circumradius = circumradius(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="circumradiusv-array-f-array-object_1"><strong><code class="codehilite">circumradius(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#circumradiusv-array-f-array-object_1" title="Permanent link">&para;</a></h3>
<p>Compute the circumradius of each triangle in a mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>R  #F list of circumradii</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>R = circumradius(V, F)</p>
<p>igl.circumradius = circumradius(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="circumradiusv-array-f-array-object_2"><strong><code class="codehilite">circumradius(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#circumradiusv-array-f-array-object_2" title="Permanent link">&para;</a></h3>
<p>Compute the circumradius of each triangle in a mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>R  #F list of circumradii</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>R = circumradius(V, F)</p>
<p>igl.collapse_small_triangles = collapse_small_triangles(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="collapse_small_trianglesv-array-f-array-eps-float-object_1"><strong><code class="codehilite">collapse_small_triangles(v: array, f: array, eps: float) -&gt; object</code></strong><a class="headerlink" href="#collapse_small_trianglesv-array-f-array-eps-float-object_1" title="Permanent link">&para;</a></h3>
<p>Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the</p>
<p>original faces and vertices of (V,F) except any small triangles have been</p>
<p>removed via collapse.</p>
<p>We are <em>not</em> following the rules in &ldquo;Mesh Optimization&rdquo; [Hoppe et al]</p>
<p>Section 4.2. But for our purposes we don&rsquo;t care about this criteria.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<p>eps  epsilon for smallest allowed area treated as fraction of squared bounding box</p>
<p>diagonal</p>
<hr />
<p><strong>Returns</strong></p>
<p>FF  #FF by 3 list of triangle indices into V</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.collapse_small_triangles = collapse_small_triangles(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="collapse_small_trianglesv-array-f-array-eps-float-object_2"><strong><code class="codehilite">collapse_small_triangles(v: array, f: array, eps: float) -&gt; object</code></strong><a class="headerlink" href="#collapse_small_trianglesv-array-f-array-eps-float-object_2" title="Permanent link">&para;</a></h3>
<p>Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the</p>
<p>original faces and vertices of (V,F) except any small triangles have been</p>
<p>removed via collapse.</p>
<p>We are <em>not</em> following the rules in &ldquo;Mesh Optimization&rdquo; [Hoppe et al]</p>
<p>Section 4.2. But for our purposes we don&rsquo;t care about this criteria.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<p>eps  epsilon for smallest allowed area treated as fraction of squared bounding box</p>
<p>diagonal</p>
<hr />
<p><strong>Returns</strong></p>
<p>FF  #FF by 3 list of triangle indices into V</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.connect_boundary_to_infinity = connect_boundary_to_infinity(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="connect_boundary_to_infinityf-array-object_1"><strong><code class="codehilite">connect_boundary_to_infinity(f: array) -&gt; object</code></strong><a class="headerlink" href="#connect_boundary_to_infinityf-array-object_1" title="Permanent link">&para;</a></h3>
<p>Connect all boundary edges to a fictitious point at infinity.</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of face indices into some V</p>
<hr />
<p><strong>Returns</strong></p>
<p>FO  #F+#O by 3 list of face indices into [V;inf inf inf], original F are</p>
<p>guaranteed to come first. If (V,F) was a manifold mesh, now it is</p>
<p>closed with a possibly non-manifold vertex at infinity (but it will be</p>
<p>edge-manifold).</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.connect_boundary_to_infinity = connect_boundary_to_infinity(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="connect_boundary_to_infinityf-array-object_2"><strong><code class="codehilite">connect_boundary_to_infinity(f: array) -&gt; object</code></strong><a class="headerlink" href="#connect_boundary_to_infinityf-array-object_2" title="Permanent link">&para;</a></h3>
<p>Connect all boundary edges to a fictitious point at infinity.</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of face indices into some V</p>
<hr />
<p><strong>Returns</strong></p>
<p>FO  #F+#O by 3 list of face indices into [V;inf inf inf], original F are</p>
<p>guaranteed to come first. If (V,F) was a manifold mesh, now it is</p>
<p>closed with a possibly non-manifold vertex at infinity (but it will be</p>
<p>edge-manifold).</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.connect_boundary_to_infinity_face = connect_boundary_to_infinity_face(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="connect_boundary_to_infinity_facev-array-f-array-tupleobject-object_1"><strong><code class="codehilite">connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of face indices into some V</p>
<hr />
<p><strong>Returns</strong></p>
<p>FO  #F+#O by 3 list of face indices into VO</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.connect_boundary_to_infinity_face = connect_boundary_to_infinity_face(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="connect_boundary_to_infinity_facev-array-f-array-tupleobject-object_2"><strong><code class="codehilite">connect_boundary_to_infinity_face(v: array, f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#connect_boundary_to_infinity_facev-array-f-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of face indices into some V</p>
<hr />
<p><strong>Returns</strong></p>
<p>FO  #F+#O by 3 list of face indices into VO</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.connect_boundary_to_infinity_index = connect_boundary_to_infinity_index(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="connect_boundary_to_infinity_indexf-array-inf_index-int-object_1"><strong><code class="codehilite">connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object</code></strong><a class="headerlink" href="#connect_boundary_to_infinity_indexf-array-inf_index-int-object_1" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>inf_index  index of point at infinity (usually V.rows() or F.maxCoeff())</p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.connect_boundary_to_infinity_index = connect_boundary_to_infinity_index(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="connect_boundary_to_infinity_indexf-array-inf_index-int-object_2"><strong><code class="codehilite">connect_boundary_to_infinity_index(f: array, inf_index: int) -&gt; object</code></strong><a class="headerlink" href="#connect_boundary_to_infinity_indexf-array-inf_index-int-object_2" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>inf_index  index of point at infinity (usually V.rows() or F.maxCoeff())</p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.cotmatrix = cotmatrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="cotmatrixv-array-f-array-object_1"><strong><code class="codehilite">cotmatrix(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#cotmatrixv-array-f-array-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh</p>
<p>(v, f).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of mesh vertex positions</p>
<p>f : #f by simplex_size list of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p>l : #v by #v cotangent matrix, each row i corresponding to v(i, :)</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>This Laplacian uses the convention that diagonal entries are</p>
<p><strong>minus</strong> the sum of off-diagonal entries. The diagonal entries are</p>
<p>therefore in general negative and the matrix is <strong>negative</strong> semi-definite</p>
<p>(immediately, -L is <strong>positive</strong> semi-definite)</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>l = cotmatrix(v, f)</p>
<p>igl.cotmatrix = cotmatrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="cotmatrixv-array-f-array-object_2"><strong><code class="codehilite">cotmatrix(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#cotmatrixv-array-f-array-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh</p>
<p>(v, f).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of mesh vertex positions</p>
<p>f : #f by simplex_size list of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p>l : #v by #v cotangent matrix, each row i corresponding to v(i, :)</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>This Laplacian uses the convention that diagonal entries are</p>
<p><strong>minus</strong> the sum of off-diagonal entries. The diagonal entries are</p>
<p>therefore in general negative and the matrix is <strong>negative</strong> semi-definite</p>
<p>(immediately, -L is <strong>positive</strong> semi-definite)</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>l = cotmatrix(v, f)</p>
<p>igl.cotmatrix_entries = cotmatrix_entries(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="cotmatrix_entriesv-array-f-array-object_1"><strong><code class="codehilite">cotmatrix_entries(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#cotmatrix_entriesv-array-f-array-object_1" title="Permanent link">&para;</a></h3>
<p>COTMATRIX_ENTRIES compute the cotangents of each angle in mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of rest domain positions</p>
<p>F  #F by {34} list of {triangletetrahedra} indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>C  #F by 3 list of &frac12;*cotangents corresponding angles</p>
<p>for triangles, columns correspond to edges [1,2],[2,0],[0,1]</p>
<p>OR</p>
<p>C  #F by 6 list of &#8537;*cotangents of dihedral angles*edge lengths</p>
<p>for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2]</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.cotmatrix_entries = cotmatrix_entries(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="cotmatrix_entriesv-array-f-array-object_2"><strong><code class="codehilite">cotmatrix_entries(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#cotmatrix_entriesv-array-f-array-object_2" title="Permanent link">&para;</a></h3>
<p>COTMATRIX_ENTRIES compute the cotangents of each angle in mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of rest domain positions</p>
<p>F  #F by {34} list of {triangletetrahedra} indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>C  #F by 3 list of &frac12;*cotangents corresponding angles</p>
<p>for triangles, columns correspond to edges [1,2],[2,0],[0,1]</p>
<p>OR</p>
<p>C  #F by 6 list of &#8537;*cotangents of dihedral angles*edge lengths</p>
<p>for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2]</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.crouzeix_raviart_cotmatrix = crouzeix_raviart_cotmatrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object_1"><strong><code class="codehilite">crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object_1" title="Permanent link">&para;</a></h3>
<p>CROUZEIX_RAVIART_COTMATRIX Compute the Crouzeix-Raviart cotangent</p>
<p>stiffness matrix.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>F  #F by &frac34; list of triangle/tetrahedron indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>L  #E by #E edge/face-based diagonal cotangent matrix</p>
<p>E  #E by &#8532; list of edges/faces</p>
<p>EMAP  #F*&frac34; list of indices mapping allE to E</p>
<hr />
<p><strong>See also</strong></p>
<p><strong>See also: crouzeix_raviart_massmatrix</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>See for example &ldquo;Discrete Quadratic Curvature Energies&rdquo; [Wardetzky, Bergou,</p>
<p>Harmon, Zorin, Grinspun 2007]</p>
<p>igl.crouzeix_raviart_cotmatrix = crouzeix_raviart_cotmatrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object_2"><strong><code class="codehilite">crouzeix_raviart_cotmatrix(v: array, f: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#crouzeix_raviart_cotmatrixv-array-f-array-tupleobject-object-object_2" title="Permanent link">&para;</a></h3>
<p>CROUZEIX_RAVIART_COTMATRIX Compute the Crouzeix-Raviart cotangent</p>
<p>stiffness matrix.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>F  #F by &frac34; list of triangle/tetrahedron indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>L  #E by #E edge/face-based diagonal cotangent matrix</p>
<p>E  #E by &#8532; list of edges/faces</p>
<p>EMAP  #F*&frac34; list of indices mapping allE to E</p>
<hr />
<p><strong>See also</strong></p>
<p><strong>See also: crouzeix_raviart_massmatrix</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>See for example &ldquo;Discrete Quadratic Curvature Energies&rdquo; [Wardetzky, Bergou,</p>
<p>Harmon, Zorin, Grinspun 2007]</p>
<p>igl.crouzeix_raviart_cotmatrix_known_e = crouzeix_raviart_cotmatrix_known_e(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object_1"><strong><code class="codehilite">crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object</code></strong><a class="headerlink" href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object_1" title="Permanent link">&para;</a></h3>
<p>wrapper if E and EMAP are already computed (better match!)</p>
<p><strong>Parameters</strong></p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.crouzeix_raviart_cotmatrix_known_e = crouzeix_raviart_cotmatrix_known_e(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object_2"><strong><code class="codehilite">crouzeix_raviart_cotmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object</code></strong><a class="headerlink" href="#crouzeix_raviart_cotmatrix_known_ev-array-f-array-e-array-emap-array-object_2" title="Permanent link">&para;</a></h3>
<p>wrapper if E and EMAP are already computed (better match!)</p>
<p><strong>Parameters</strong></p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.crouzeix_raviart_massmatrix = crouzeix_raviart_massmatrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object_1"><strong><code class="codehilite">crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object_1" title="Permanent link">&para;</a></h3>
<p>CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where</p>
<hr />
<h3 id="edge-e_1"><strong><code class="codehilite">edge e.</code></strong><a class="headerlink" href="#edge-e_1" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>F  #F by &frac34; list of triangle/tetrahedron indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>M  #E by #E edge/face-based diagonal mass matrix</p>
<p>E  #E by &#8532; list of edges/faces</p>
<p>EMAP  #F*&frac34; list of indices mapping allE to E</p>
<hr />
<p><strong>See also</strong></p>
<p>crouzeix_raviart_cotmatrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>See for example &ldquo;Discrete Quadratic Curvature Energies&rdquo; [Wardetzky, Bergou,</p>
<p>Harmon, Zorin, Grinspun 2007]</p>
<p><strong>Examples</strong></p>
<p>igl.crouzeix_raviart_massmatrix = crouzeix_raviart_massmatrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object_2"><strong><code class="codehilite">crouzeix_raviart_massmatrix(v: array, f: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#crouzeix_raviart_massmatrixv-array-f-array-tupleobject-object-object_2" title="Permanent link">&para;</a></h3>
<p>CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where</p>
<hr />
<h3 id="edge-e_2"><strong><code class="codehilite">edge e.</code></strong><a class="headerlink" href="#edge-e_2" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>F  #F by &frac34; list of triangle/tetrahedron indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>M  #E by #E edge/face-based diagonal mass matrix</p>
<p>E  #E by &#8532; list of edges/faces</p>
<p>EMAP  #F*&frac34; list of indices mapping allE to E</p>
<hr />
<p><strong>See also</strong></p>
<p>crouzeix_raviart_cotmatrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>See for example &ldquo;Discrete Quadratic Curvature Energies&rdquo; [Wardetzky, Bergou,</p>
<p>Harmon, Zorin, Grinspun 2007]</p>
<p><strong>Examples</strong></p>
<p>igl.crouzeix_raviart_massmatrix_known_e = crouzeix_raviart_massmatrix_known_e(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object_1"><strong><code class="codehilite">crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object</code></strong><a class="headerlink" href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object_1" title="Permanent link">&para;</a></h3>
<p>wrapper if E and EMAP are already computed (better match!)</p>
<p><strong>Parameters</strong></p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.crouzeix_raviart_massmatrix_known_e = crouzeix_raviart_massmatrix_known_e(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object_2"><strong><code class="codehilite">crouzeix_raviart_massmatrix_known_e(v: array, f: array, e: array, emap: array) -&gt; object</code></strong><a class="headerlink" href="#crouzeix_raviart_massmatrix_known_ev-array-f-array-e-array-emap-array-object_2" title="Permanent link">&para;</a></h3>
<p>wrapper if E and EMAP are already computed (better match!)</p>
<p><strong>Parameters</strong></p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.cut_mesh = cut_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="cut_meshv-array-f-array-cuts-array-tupleobject-object_1"><strong><code class="codehilite">cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#cut_meshv-array-f-array-cuts-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Compute the barycenter of every simplex</p>
<p><strong>Parameters</strong></p>
<p>v : #v x dim matrix of vertex coordinates</p>
<p>f : #f x simplex_size  matrix of indices of simplex corners into V</p>
<p>cuts : #F by 3 list of boolean flags, indicating the edges that need to</p>
<p>be cut (has 1 at the face edges that are to be cut, 0 otherwise)</p>
<hr />
<p><strong>Returns</strong></p>
<p>A pair (vcut, fcut) where:</p>
<ul>
<li>vcut is a #v by 3 list of the vertex positions</li>
</ul>
<p>of the cut mesh. This matrix will be similar to the original vertices except</p>
<p>some rows will be duplicated.</p>
<ul>
<li>fcut is a #f by 3 list of the faces of the cut mesh (must be triangles). This</li>
</ul>
<p>matrix will be similar to the original face matrix except some indices</p>
<p>will be redirected to point to the newly duplicated vertices.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.cut_mesh = cut_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="cut_meshv-array-f-array-cuts-array-tupleobject-object_2"><strong><code class="codehilite">cut_mesh(v: array, f: array, cuts: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#cut_meshv-array-f-array-cuts-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Compute the barycenter of every simplex</p>
<p><strong>Parameters</strong></p>
<p>v : #v x dim matrix of vertex coordinates</p>
<p>f : #f x simplex_size  matrix of indices of simplex corners into V</p>
<p>cuts : #F by 3 list of boolean flags, indicating the edges that need to</p>
<p>be cut (has 1 at the face edges that are to be cut, 0 otherwise)</p>
<hr />
<p><strong>Returns</strong></p>
<p>A pair (vcut, fcut) where:</p>
<ul>
<li>vcut is a #v by 3 list of the vertex positions</li>
</ul>
<p>of the cut mesh. This matrix will be similar to the original vertices except</p>
<p>some rows will be duplicated.</p>
<ul>
<li>fcut is a #f by 3 list of the faces of the cut mesh (must be triangles). This</li>
</ul>
<p>matrix will be similar to the original face matrix except some indices</p>
<p>will be redirected to point to the newly duplicated vertices.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.cut_mesh_from_singularities = cut_mesh_from_singularities(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object_1"><strong><code class="codehilite">cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object</code></strong><a class="headerlink" href="#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object_1" title="Permanent link">&para;</a></h3>
<p>Given a mesh (v,f) and the integer mismatch of a cross field per edge</p>
<p>(mismatch), finds and <strong>returns the cut_graph connecting the singularities</strong></p>
<p>(seams)</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of triangle vertices (each row is a vertex)</p>
<p>f : #f by 3 array of triangle indices into v</p>
<p>mismatch : #f by 3 array of per-corner integer mismatches</p>
<hr />
<p><strong>Returns</strong></p>
<p>seams : #f by 3 array of per corner booleans that de**notes if an edge is a**</p>
<p>seam or not</p>
<hr />
<p><strong>See also</strong></p>
<p>cut_mesh</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.cut_mesh_from_singularities = cut_mesh_from_singularities(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object_2"><strong><code class="codehilite">cut_mesh_from_singularities(v: array, f: array, mismatch: array) -&gt; object</code></strong><a class="headerlink" href="#cut_mesh_from_singularitiesv-array-f-array-mismatch-array-object_2" title="Permanent link">&para;</a></h3>
<p>Given a mesh (v,f) and the integer mismatch of a cross field per edge</p>
<p>(mismatch), finds and <strong>returns the cut_graph connecting the singularities</strong></p>
<p>(seams)</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of triangle vertices (each row is a vertex)</p>
<p>f : #f by 3 array of triangle indices into v</p>
<p>mismatch : #f by 3 array of per-corner integer mismatches</p>
<hr />
<p><strong>Returns</strong></p>
<p>seams : #f by 3 array of per corner booleans that de**notes if an edge is a**</p>
<p>seam or not</p>
<hr />
<p><strong>See also</strong></p>
<p>cut_mesh</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.cylinder = cylinder(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="cylinderaxis_devisions-int-height_devisions-int-tupleobject-object_1"><strong><code class="codehilite">cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Construct a triangle mesh of a cylinder (without caps)</p>
<p><strong>Parameters</strong></p>
<p>axis_devisions  number of vertices <em>around the cylinder</em></p>
<p>height_devisions  number of vertices <em>up the cylinder</em></p>
<hr />
<p><strong>Returns</strong></p>
<p>V  #V by 3 list of mesh vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.cylinder = cylinder(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="cylinderaxis_devisions-int-height_devisions-int-tupleobject-object_2"><strong><code class="codehilite">cylinder(axis_devisions: int, height_devisions: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#cylinderaxis_devisions-int-height_devisions-int-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Construct a triangle mesh of a cylinder (without caps)</p>
<p><strong>Parameters</strong></p>
<p>axis_devisions  number of vertices <em>around the cylinder</em></p>
<p>height_devisions  number of vertices <em>up the cylinder</em></p>
<hr />
<p><strong>Returns</strong></p>
<p>V  #V by 3 list of mesh vertex positions</p>
<p>F  #F by 3 list of triangle indices into V</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.decimate = decimate(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object_1"><strong><code class="codehilite">decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]</code></strong><a class="headerlink" href="#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object_1" title="Permanent link">&para;</a></h3>
<p>Assumes (V,F) is a manifold mesh (possibly with boundary) Collapses edges</p>
<p>until desired number of faces is achieved. This uses default edge cost and</p>
<p>merged vertex placement functions {edge length, edge midpoint}.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>F  #F by 3 list of face indices into V.</p>
<p>max_m  desired number of output faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>U  #U by dim list of output vertex posistions (can be same ref as V)</p>
<p>G  #G by 3 list of output face indices into U (can be same ref as G)</p>
<p>J  #G list of indices into F of birth face</p>
<p>I  #U list of indices into V of birth vertices</p>
<p><strong>Returns true if m was reached (otherwise #G &gt; m)</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.decimate = decimate(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object_2"><strong><code class="codehilite">decimate(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]</code></strong><a class="headerlink" href="#decimatev-array-f-array-max_m-int-tuplebool-object-object-object-object_2" title="Permanent link">&para;</a></h3>
<p>Assumes (V,F) is a manifold mesh (possibly with boundary) Collapses edges</p>
<p>until desired number of faces is achieved. This uses default edge cost and</p>
<p>merged vertex placement functions {edge length, edge midpoint}.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>F  #F by 3 list of face indices into V.</p>
<p>max_m  desired number of output faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>U  #U by dim list of output vertex posistions (can be same ref as V)</p>
<p>G  #G by 3 list of output face indices into U (can be same ref as G)</p>
<p>J  #G list of indices into F of birth face</p>
<p>I  #U list of indices into V of birth vertices</p>
<p><strong>Returns true if m was reached (otherwise #G &gt; m)</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.dihedral_angles = dihedral_angles(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="dihedral_anglesv-array-t-array-tupleobject-object_1"><strong><code class="codehilite">dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#dihedral_anglesv-array-t-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Compute dihedral angles for all tets of a given tet mesh (v, t).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of vertex positions</p>
<p>t : #v by 4 list of tet indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>theta : #t by 6 list of dihedral angles (in radians)</p>
<p>cos_theta : #t by 6 list of cosine of dihedral angles (in radians)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>TetMesh in (v, t)</p>
<p>theta, cos_theta = dihedral_angles(v, t)</p>
<p>igl.dihedral_angles = dihedral_angles(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="dihedral_anglesv-array-t-array-tupleobject-object_2"><strong><code class="codehilite">dihedral_angles(v: array, t: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#dihedral_anglesv-array-t-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Compute dihedral angles for all tets of a given tet mesh (v, t).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of vertex positions</p>
<p>t : #v by 4 list of tet indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>theta : #t by 6 list of dihedral angles (in radians)</p>
<p>cos_theta : #t by 6 list of cosine of dihedral angles (in radians)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>TetMesh in (v, t)</p>
<p>theta, cos_theta = dihedral_angles(v, t)</p>
<p>igl.dihedral_angles_intrinsic = dihedral_angles_intrinsic(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="dihedral_angles_intrinsicl-array-a-array-tupleobject-object_1"><strong><code class="codehilite">dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#dihedral_angles_intrinsicl-array-a-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>See dihedral_angles for the documentation.</p>
<p>igl.dihedral_angles_intrinsic = dihedral_angles_intrinsic(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="dihedral_angles_intrinsicl-array-a-array-tupleobject-object_2"><strong><code class="codehilite">dihedral_angles_intrinsic(l: array, a: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#dihedral_angles_intrinsicl-array-a-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>See dihedral_angles for the documentation.</p>
<p>igl.directed_edge_parents = directed_edge_parents(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="directed_edge_parentse-array-object_1"><strong><code class="codehilite">directed_edge_parents(e: array) -&gt; object</code></strong><a class="headerlink" href="#directed_edge_parentse-array-object_1" title="Permanent link">&para;</a></h3>
<p>Recover &ldquo;parents&rdquo; (preceding edges) in a tree given just directed edges.</p>
<p><strong>Parameters</strong></p>
<p>e : #e by 2 list of directed edges</p>
<hr />
<p><strong>Returns</strong></p>
<p>p : #e list of parent indices into e. (-1) means root</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>p = edges(e)</p>
<p>igl.directed_edge_parents = directed_edge_parents(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="directed_edge_parentse-array-object_2"><strong><code class="codehilite">directed_edge_parents(e: array) -&gt; object</code></strong><a class="headerlink" href="#directed_edge_parentse-array-object_2" title="Permanent link">&para;</a></h3>
<p>Recover &ldquo;parents&rdquo; (preceding edges) in a tree given just directed edges.</p>
<p><strong>Parameters</strong></p>
<p>e : #e by 2 list of directed edges</p>
<hr />
<p><strong>Returns</strong></p>
<p>p : #e list of parent indices into e. (-1) means root</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>p = edges(e)</p>
<p>igl.doublearea = doublearea(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="doubleareav-array-f-array-object_1"><strong><code class="codehilite">doublearea(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#doubleareav-array-f-array-object_1" title="Permanent link">&para;</a></h3>
<p>Computes twice the area for each input triangle[quad]</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of mesh vertex positions</p>
<p>f : #f by simplex_size array of mesh faces (must be triangles or quads)</p>
<hr />
<p><strong>Returns</strong></p>
<p>d_area : #f list of triangle[quad] double areas (SIGNED only for 2D input)</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal if you have 1million unreferenced vertices and 1 face</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>dbl_area = doublearea(v, f)</p>
<p>igl.doublearea = doublearea(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="doubleareav-array-f-array-object_2"><strong><code class="codehilite">doublearea(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#doubleareav-array-f-array-object_2" title="Permanent link">&para;</a></h3>
<p>Computes twice the area for each input triangle[quad]</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of mesh vertex positions</p>
<p>f : #f by simplex_size array of mesh faces (must be triangles or quads)</p>
<hr />
<p><strong>Returns</strong></p>
<p>d_area : #f list of triangle[quad] double areas (SIGNED only for 2D input)</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>Known bug: For dim==3 complexity is O(#V + #F)!! Not just O(#F). This is a big deal if you have 1million unreferenced vertices and 1 face</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>dbl_area = doublearea(v, f)</p>
<p>igl.ears = ears(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="earsf-array-tupleobject-object_1"><strong><code class="codehilite">ears(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#earsf-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>FIND_EARS  Find all ears (faces with two boundary edges) in a given mesh</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of triangle mesh indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>ears  #ears list of indices into F of ears</p>
<p>ear_opp  #ears list of indices indicating which edge is non-boundary</p>
<p>(connecting to flops)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>ears,ear_opp = find_ears(F)</p>
<p>igl.ears = ears(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="earsf-array-tupleobject-object_2"><strong><code class="codehilite">ears(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#earsf-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>FIND_EARS  Find all ears (faces with two boundary edges) in a given mesh</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of triangle mesh indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>ears  #ears list of indices into F of ears</p>
<p>ear_opp  #ears list of indices indicating which edge is non-boundary</p>
<p>(connecting to flops)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>ears,ear_opp = find_ears(F)</p>
<p>igl.edge_topology = edge_topology(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="edge_topologyv-array-f-array-tupleobject-object-object_1"><strong><code class="codehilite">edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#edge_topologyv-array-f-array-tupleobject-object-object_1" title="Permanent link">&para;</a></h3>
<p>Initialize Edges and their topological relations (assumes an edge-manifold mesh)</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim, list of mesh vertex positions (unused)</p>
<p>f : #f by 3, list of triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>ev : #e by 2, list of edges described as pair of vertices.</p>
<p>fe : #f by 3, list storing triangle-edge relation.</p>
<p>ef : #e by w, list storing edge-triangle relation, uses -1 to indicate boundaries.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>ev, fe, ef = edge_topology(v, f)</p>
<p>igl.edge_topology = edge_topology(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="edge_topologyv-array-f-array-tupleobject-object-object_2"><strong><code class="codehilite">edge_topology(v: array, f: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#edge_topologyv-array-f-array-tupleobject-object-object_2" title="Permanent link">&para;</a></h3>
<p>Initialize Edges and their topological relations (assumes an edge-manifold mesh)</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim, list of mesh vertex positions (unused)</p>
<p>f : #f by 3, list of triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>ev : #e by 2, list of edges described as pair of vertices.</p>
<p>fe : #f by 3, list storing triangle-edge relation.</p>
<p>ef : #e by w, list storing edge-triangle relation, uses -1 to indicate boundaries.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>ev, fe, ef = edge_topology(v, f)</p>
<p>igl.edges = edges(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="edgesf-array-object_1"><strong><code class="codehilite">edges(f: array) -&gt; object</code></strong><a class="headerlink" href="#edgesf-array-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs a list of unique edges represented in a given mesh (v, f)</p>
<p><strong>Parameters</strong></p>
<p>f : #F by dim list of mesh faces (must be triangles or tets)</p>
<hr />
<p><strong>Returns</strong></p>
<p>by 2 list of edges in no particular order</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>V, F, _ = igl.readOFF(&ldquo;test.off)</p>
<p>E = igl.edges(F)</p>
<p>igl.edges = edges(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="edgesf-array-object_2"><strong><code class="codehilite">edges(f: array) -&gt; object</code></strong><a class="headerlink" href="#edgesf-array-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs a list of unique edges represented in a given mesh (v, f)</p>
<p><strong>Parameters</strong></p>
<p>f : #F by dim list of mesh faces (must be triangles or tets)</p>
<hr />
<p><strong>Returns</strong></p>
<p>by 2 list of edges in no particular order</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>V, F, _ = igl.readOFF(&ldquo;test.off)</p>
<p>E = igl.edges(F)</p>
<p>igl.euler_characteristic = euler_characteristic(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="euler_characteristicf-array-int_1"><strong><code class="codehilite">euler_characteristic(f: array) -&gt; int</code></strong><a class="headerlink" href="#euler_characteristicf-array-int_1" title="Permanent link">&para;</a></h3>
<p>Computes the Euler characteristic of a given mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>F #F by dim list of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns An int containing the Euler characteristic</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.euler_characteristic = euler_characteristic(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="euler_characteristicf-array-int_2"><strong><code class="codehilite">euler_characteristic(f: array) -&gt; int</code></strong><a class="headerlink" href="#euler_characteristicf-array-int_2" title="Permanent link">&para;</a></h3>
<p>Computes the Euler characteristic of a given mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>F #F by dim list of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns An int containing the Euler characteristic</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.euler_characteristic_complete = euler_characteristic_complete(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="euler_characteristic_completev-array-f-array-int_1"><strong><code class="codehilite">euler_characteristic_complete(v: array, f: array) -&gt; int</code></strong><a class="headerlink" href="#euler_characteristic_completev-array-f-array-int_1" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>V       #V by dim list of mesh vertex positions</p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.euler_characteristic_complete = euler_characteristic_complete(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="euler_characteristic_completev-array-f-array-int_2"><strong><code class="codehilite">euler_characteristic_complete(v: array, f: array) -&gt; int</code></strong><a class="headerlink" href="#euler_characteristic_completev-array-f-array-int_2" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>V       #V by dim list of mesh vertex positions</p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.exact_geodesic = exact_geodesic(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object_1"><strong><code class="codehilite">exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object</code></strong><a class="headerlink" href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object_1" title="Permanent link">&para;</a></h3>
<p>Exact geodesic algorithm for the calculation of geodesics on a triangular mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of 3D vertex positions</p>
<p>f : #f by 3 array of mesh faces</p>
<p>vs : #vs by 1 array specifying indices of source vertices</p>
<p>fs : #fs by 1 array specifying indices of source faces</p>
<p>vt : #vt by 1 array specifying indices of target vertices</p>
<p>ft : #ft by 1 array specifying indices of target faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>d : #vt+#ft by 1 array of geodesic distances of each target w.r.t. the nearest one in the source set</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>Specifying a face as target/source means its center.</p>
<p>Implementation from https:code.google.com/archive/p/geodesic/ with the algorithm first described by Mitchell, Mount and Papadimitriou in 1987.</p>
<p><strong>Examples</strong></p>
<p>igl.exact_geodesic = exact_geodesic(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object_2"><strong><code class="codehilite">exact_geodesic(v: array, f: array, vs: array, vt: array, fs: numpy.array  None = None, ft: numpy.array  None = None) -&gt; object</code></strong><a class="headerlink" href="#exact_geodesicv-array-f-array-vs-array-vt-array-fs-numpyarray-none-none-ft-numpyarray-none-none-object_2" title="Permanent link">&para;</a></h3>
<p>Exact geodesic algorithm for the calculation of geodesics on a triangular mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of 3D vertex positions</p>
<p>f : #f by 3 array of mesh faces</p>
<p>vs : #vs by 1 array specifying indices of source vertices</p>
<p>fs : #fs by 1 array specifying indices of source faces</p>
<p>vt : #vt by 1 array specifying indices of target vertices</p>
<p>ft : #ft by 1 array specifying indices of target faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>d : #vt+#ft by 1 array of geodesic distances of each target w.r.t. the nearest one in the source set</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>Specifying a face as target/source means its center.</p>
<p>Implementation from https:code.google.com/archive/p/geodesic/ with the algorithm first described by Mitchell, Mount and Papadimitriou in 1987.</p>
<p><strong>Examples</strong></p>
<p>igl.face_components = face_components(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="face_componentsf-array-object_1"><strong><code class="codehilite">face_components(f: array) -&gt; object</code></strong><a class="headerlink" href="#face_componentsf-array-object_1" title="Permanent link">&para;</a></h3>
<p>Compute connected components of facets based on edge-edge adjacency,</p>
<p><strong>Parameters</strong></p>
<p>f : #f x 3 array of triangle indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>An array, c, with shape (#f,), of component ids</p>
<hr />
<p><strong>See also</strong></p>
<p>vertex_components</p>
<p>vertex_components_from_adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.face_components = face_components(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="face_componentsf-array-object_2"><strong><code class="codehilite">face_components(f: array) -&gt; object</code></strong><a class="headerlink" href="#face_componentsf-array-object_2" title="Permanent link">&para;</a></h3>
<p>Compute connected components of facets based on edge-edge adjacency,</p>
<p><strong>Parameters</strong></p>
<p>f : #f x 3 array of triangle indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>An array, c, with shape (#f,), of component ids</p>
<hr />
<p><strong>See also</strong></p>
<p>vertex_components</p>
<p>vertex_components_from_adjacency_matrix</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.fit_plane = fit_plane(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="fit_planev-array-tupleobject-object_1"><strong><code class="codehilite">fit_plane(v: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#fit_planev-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>This function fits a plane to a point cloud.</p>
<p><strong>Parameters</strong></p>
<p>V #Vx3 matrix. The 3D point cloud, one row for each vertex.</p>
<hr />
<p><strong>Returns</strong></p>
<p>N 1x3 Vector. The normal of the fitted plane.</p>
<p>C 1x3 Vector. A point that lies in the fitted plane.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>From http:missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html</p>
<p><strong>Examples</strong></p>
<p>igl.fit_plane = fit_plane(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="fit_planev-array-tupleobject-object_2"><strong><code class="codehilite">fit_plane(v: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#fit_planev-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>This function fits a plane to a point cloud.</p>
<p><strong>Parameters</strong></p>
<p>V #Vx3 matrix. The 3D point cloud, one row for each vertex.</p>
<hr />
<p><strong>Returns</strong></p>
<p>N 1x3 Vector. The normal of the fitted plane.</p>
<p>C 1x3 Vector. A point that lies in the fitted plane.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>From http:missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html</p>
<p><strong>Examples</strong></p>
<p>igl.flip_avoiding_line_search = flip_avoiding_line_search(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object_1"><strong><code class="codehilite">flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]</code></strong><a class="headerlink" href="#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object_1" title="Permanent link">&para;</a></h3>
<p>A bisection line search for a mesh based energy that avoids triangle flips as suggested in</p>
<p>&ldquo;Bijective Parameterization with Free Boundaries&rdquo; (Smith J. and Schaefer S., 2015).</p>
<p>The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles).</p>
<p>This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see igl::line_search).</p>
<p>Supports both triangle and tet meshes.</p>
<p><strong>Parameters</strong></p>
<p>F         #F by &frac34; list of mesh faces or tets</p>
<p>cur_v     #V by dim list of variables</p>
<p>dst_v     #V by dim list of target vertices. This mesh may have flipped triangles</p>
<p>energy    A function to compute the mesh-based energy (return an energy that is bigger than 0)</p>
<hr />
<h3 id="cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it_1"><strong><code class="codehilite">cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it.</code></strong><a class="headerlink" href="#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it_1" title="Permanent link">&para;</a></h3>
<hr />
<p><strong>Returns</strong></p>
<p>cur_v     #V by dim list of variables at the new location</p>
<p><strong>Returns the energy at the new point</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.flip_avoiding_line_search = flip_avoiding_line_search(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object_2"><strong><code class="codehilite">flip_avoiding_line_search(f: array, cur_v: array, dst_v: array, energy: std::__1::function&lt;double (Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;)&gt;, cur_energy: float) -&gt; Tuple[float, object]</code></strong><a class="headerlink" href="#flip_avoiding_line_searchf-array-cur_v-array-dst_v-array-energy-std__1functiondouble-eigenmatrixdouble-1-1-0-1-1-cur_energy-float-tuplefloat-object_2" title="Permanent link">&para;</a></h3>
<p>A bisection line search for a mesh based energy that avoids triangle flips as suggested in</p>
<p>&ldquo;Bijective Parameterization with Free Boundaries&rdquo; (Smith J. and Schaefer S., 2015).</p>
<p>The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles).</p>
<p>This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see igl::line_search).</p>
<p>Supports both triangle and tet meshes.</p>
<p><strong>Parameters</strong></p>
<p>F         #F by &frac34; list of mesh faces or tets</p>
<p>cur_v     #V by dim list of variables</p>
<p>dst_v     #V by dim list of target vertices. This mesh may have flipped triangles</p>
<p>energy    A function to compute the mesh-based energy (return an energy that is bigger than 0)</p>
<hr />
<h3 id="cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it_2"><strong><code class="codehilite">cur_energy(OPTIONAL)         The energy at the given point. Helps save redundant c  omputations. This is optional. If not specified, the function will compute it.</code></strong><a class="headerlink" href="#cur_energyoptional-the-energy-at-the-given-point-helps-save-redundant-c-omputations-this-is-optional-if-not-specified-the-function-will-compute-it_2" title="Permanent link">&para;</a></h3>
<hr />
<p><strong>Returns</strong></p>
<p>cur_v     #V by dim list of variables at the new location</p>
<p><strong>Returns the energy at the new point</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.gaussian_curvature = gaussian_curvature(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="gaussian_curvaturev-array-f-array-object_1"><strong><code class="codehilite">gaussian_curvature(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#gaussian_curvaturev-array-f-array-object_1" title="Permanent link">&para;</a></h3>
<p>Compute discrete local integral gaussian curvature (angle deficit, without</p>
<p>averaging by local area).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex 3D positions</p>
<p>f : #f by 3 array of face (triangle) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>k : #v by 1 array of discrete gaussian curvature values</p>
<hr />
<p><strong>See also</strong></p>
<p>principal_curvature</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>k = gaussian_curvature(v, f)</p>
<p>igl.gaussian_curvature = gaussian_curvature(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="gaussian_curvaturev-array-f-array-object_2"><strong><code class="codehilite">gaussian_curvature(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#gaussian_curvaturev-array-f-array-object_2" title="Permanent link">&para;</a></h3>
<p>Compute discrete local integral gaussian curvature (angle deficit, without</p>
<p>averaging by local area).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex 3D positions</p>
<p>f : #f by 3 array of face (triangle) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>k : #v by 1 array of discrete gaussian curvature values</p>
<hr />
<p><strong>See also</strong></p>
<p>principal_curvature</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>k = gaussian_curvature(v, f)</p>
<p>igl.grad = grad(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="gradv-array-f-array-uniform-bool-false-object_1"><strong><code class="codehilite">grad(v: array, f: array, uniform: bool = False) -&gt; object</code></strong><a class="headerlink" href="#gradv-array-f-array-uniform-bool-false-object_1" title="Permanent link">&para;</a></h3>
<p>Compute the numerical gradient operator.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 list of mesh vertex positions</p>
<p>f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices]</p>
<p>uniform : boolean (default false). Use a uniform mesh instead of the vertices v</p>
<hr />
<p><strong>Returns</strong></p>
<p>g : #faces * dim by #v gradient operator</p>
<hr />
<p><strong>See also</strong></p>
<p>cotmatrix, massmatrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>Gradient of a scalar function defined on piecewise linear elements (mesh)</p>
<p>is constant on each triangle [tetrahedron] i,j,k:</p>
<hr />
<h3 id="gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_1"><strong><code class="codehilite">grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A</code></strong><a class="headerlink" href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_1" title="Permanent link">&para;</a></h3>
<p>where Xi is the scalar value at vertex i, Vi is the 3D position of vertex</p>
<p>i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of</p>
<p>90 degrees.</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>g = grad(v, f)</p>
<p>igl.grad = grad(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="gradv-array-f-array-uniform-bool-false-object_2"><strong><code class="codehilite">grad(v: array, f: array, uniform: bool = False) -&gt; object</code></strong><a class="headerlink" href="#gradv-array-f-array-uniform-bool-false-object_2" title="Permanent link">&para;</a></h3>
<p>Compute the numerical gradient operator.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 list of mesh vertex positions</p>
<p>f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices]</p>
<p>uniform : boolean (default false). Use a uniform mesh instead of the vertices v</p>
<hr />
<p><strong>Returns</strong></p>
<p>g : #faces * dim by #v gradient operator</p>
<hr />
<p><strong>See also</strong></p>
<p>cotmatrix, massmatrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>Gradient of a scalar function defined on piecewise linear elements (mesh)</p>
<p>is constant on each triangle [tetrahedron] i,j,k:</p>
<hr />
<h3 id="gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_2"><strong><code class="codehilite">grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A</code></strong><a class="headerlink" href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_2" title="Permanent link">&para;</a></h3>
<p>where Xi is the scalar value at vertex i, Vi is the 3D position of vertex</p>
<p>i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of</p>
<p>90 degrees.</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>g = grad(v, f)</p>
<p>igl.grad = grad(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="gradv-array-f-array-uniform-bool-false-object_3"><strong><code class="codehilite">grad(v: array, f: array, uniform: bool = False) -&gt; object</code></strong><a class="headerlink" href="#gradv-array-f-array-uniform-bool-false-object_3" title="Permanent link">&para;</a></h3>
<p>Compute the numerical gradient operator.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 list of mesh vertex positions</p>
<p>f : #f by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices]</p>
<p>uniform : boolean (default false). Use a uniform mesh instead of the vertices v</p>
<hr />
<p><strong>Returns</strong></p>
<p>g : #faces * dim by #v gradient operator</p>
<hr />
<p><strong>See also</strong></p>
<p>cotmatrix, massmatrix</p>
<hr />
<p><strong>Notes</strong></p>
<p>Gradient of a scalar function defined on piecewise linear elements (mesh)</p>
<p>is constant on each triangle [tetrahedron] i,j,k:</p>
<hr />
<h3 id="gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_3"><strong><code class="codehilite">grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A</code></strong><a class="headerlink" href="#gradxijk-xj-xi-vi-vkr90-2a-xk-xi-vj-vir90-2a_3" title="Permanent link">&para;</a></h3>
<p>where Xi is the scalar value at vertex i, Vi is the 3D position of vertex</p>
<p>i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of</p>
<p>90 degrees.</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>g = grad(v, f)</p>
<p>igl.harmonic_integrated_with_laplacian = harmonic_integrated_with_laplacian(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object_1"><strong><code class="codehilite">harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object</code></strong><a class="headerlink" href="#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object_1" title="Permanent link">&para;</a></h3>
<p>Build the discrete k-harmonic operator (computing integrated quantities).</p>
<p>That is, if the k-harmonic PDE is Q x = 0, then this minimizes x&rsquo; Q x</p>
<p><strong>Parameters</strong></p>
<p>L  #V by #V discrete (integrated) Laplacian</p>
<p>M  #V by #V mass matrix</p>
<p>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</p>
<hr />
<p><strong>Returns</strong></p>
<p>Q  #V by #V discrete (integrated) k-Laplacian</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.harmonic_integrated_with_laplacian = harmonic_integrated_with_laplacian(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object_2"><strong><code class="codehilite">harmonic_integrated_with_laplacian(l: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, m: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix, k: int) -&gt; object</code></strong><a class="headerlink" href="#harmonic_integrated_with_laplacianl-scipysparsecsr_matrix-scipysparsecsc_matrix-m-scipysparsecsr_matrix-scipysparsecsc_matrix-k-int-object_2" title="Permanent link">&para;</a></h3>
<p>Build the discrete k-harmonic operator (computing integrated quantities).</p>
<p>That is, if the k-harmonic PDE is Q x = 0, then this minimizes x&rsquo; Q x</p>
<p><strong>Parameters</strong></p>
<p>L  #V by #V discrete (integrated) Laplacian</p>
<p>M  #V by #V mass matrix</p>
<p>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</p>
<hr />
<p><strong>Returns</strong></p>
<p>Q  #V by #V discrete (integrated) k-Laplacian</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.harmonic_uniform_laplacian = harmonic_uniform_laplacian(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object_1"><strong><code class="codehilite">harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object</code></strong><a class="headerlink" href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object_1" title="Permanent link">&para;</a></h3>
<p>Compute harmonic map using uniform laplacian operator</p>
<p><strong>Parameters</strong></p>
<p>F  #F by simplex-size list of element indices</p>
<p>b  #b boundary indices into V</p>
<p>bc #b by #W list of boundary values</p>
<p>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</p>
<hr />
<p><strong>Returns</strong></p>
<p>W  #V by #W list of weights</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.harmonic_uniform_laplacian = harmonic_uniform_laplacian(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object_2"><strong><code class="codehilite">harmonic_uniform_laplacian(f: array, b: array, bc: array, k: int) -&gt; object</code></strong><a class="headerlink" href="#harmonic_uniform_laplacianf-array-b-array-bc-array-k-int-object_2" title="Permanent link">&para;</a></h3>
<p>Compute harmonic map using uniform laplacian operator</p>
<p><strong>Parameters</strong></p>
<p>F  #F by simplex-size list of element indices</p>
<p>b  #b boundary indices into V</p>
<p>bc #b by #W list of boundary values</p>
<p>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</p>
<hr />
<p><strong>Returns</strong></p>
<p>W  #V by #W list of weights</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.harmonic_weights = harmonic_weights(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object_1"><strong><code class="codehilite">harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object</code></strong><a class="headerlink" href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object_1" title="Permanent link">&para;</a></h3>
<p>Compute k-harmonic weight functions &ldquo;coordinates&rdquo;.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim vertex positions</p>
<p>F  #F by simplex-size list of element indices</p>
<p>b  #b boundary indices into V</p>
<p>bc #b by #W list of boundary values</p>
<p>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</p>
<hr />
<p><strong>Returns</strong></p>
<p>W  #V by #W list of weights</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.harmonic_weights = harmonic_weights(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object_2"><strong><code class="codehilite">harmonic_weights(v: array, f: array, b: array, bc: array, k: int) -&gt; object</code></strong><a class="headerlink" href="#harmonic_weightsv-array-f-array-b-array-bc-array-k-int-object_2" title="Permanent link">&para;</a></h3>
<p>Compute k-harmonic weight functions &ldquo;coordinates&rdquo;.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim vertex positions</p>
<p>F  #F by simplex-size list of element indices</p>
<p>b  #b boundary indices into V</p>
<p>bc #b by #W list of boundary values</p>
<p>k  power of harmonic operation (1: harmonic, 2: biharmonic, etc)</p>
<hr />
<p><strong>Returns</strong></p>
<p>W  #V by #W list of weights</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.hausdorff = hausdorff(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="hausdorffva-array-fa-array-vb-array-fb-array-float_1"><strong><code class="codehilite">hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float</code></strong><a class="headerlink" href="#hausdorffva-array-fa-array-vb-array-fb-array-float_1" title="Permanent link">&para;</a></h3>
<p>HAUSDORFF compute the Hausdorff distance between mesh (VA,FA) and mesh</p>
<p>(VB,FB). This is the</p>
<hr />
<h3 id="aa-bb-bb-aa_1"><strong><code class="codehilite">a∈A b∈B          b∈B a∈A</code></strong><a class="headerlink" href="#aa-bb-bb-aa_1" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>VA  #VA by 3 list of vertex positions</p>
<p>FA  #FA by 3 list of face indices into VA</p>
<p>VB  #VB by 3 list of vertex positions</p>
<p>FB  #FB by 3 list of face indices into VB</p>
<hr />
<p><strong>Returns</strong></p>
<p>d  hausdorff distance</p>
<p>pair  2 by 3 list of &ldquo;determiner points&rdquo; so that pair(1,:) is from A</p>
<p>and pair(2,:) is from B</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>Known issue: This is only computing max(min(va,B),min(vb,A)). This is</p>
<p>better than max(min(va,Vb),min(vb,Va)). This (at least) is missing</p>
<p>&ldquo;edge-edge&rdquo; cases like the distance between the two different</p>
<p>triangulations of a non-planar quad in 3D. Even simpler, consider the</p>
<p>Hausdorff distance between the non-convex, block letter V polygon (with 7</p>
<p>vertices) in 2D and its convex hull. The Hausdorff distance is defined by</p>
<p>the midpoint in the middle of the segment across the concavity and some</p>
<p>non-vertex point <em>on the edge</em> of the V.</p>
<p><strong>Examples</strong></p>
<p>igl.hausdorff = hausdorff(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="hausdorffva-array-fa-array-vb-array-fb-array-float_2"><strong><code class="codehilite">hausdorff(va: array, fa: array, vb: array, fb: array) -&gt; float</code></strong><a class="headerlink" href="#hausdorffva-array-fa-array-vb-array-fb-array-float_2" title="Permanent link">&para;</a></h3>
<p>HAUSDORFF compute the Hausdorff distance between mesh (VA,FA) and mesh</p>
<p>(VB,FB). This is the</p>
<hr />
<h3 id="aa-bb-bb-aa_2"><strong><code class="codehilite">a∈A b∈B          b∈B a∈A</code></strong><a class="headerlink" href="#aa-bb-bb-aa_2" title="Permanent link">&para;</a></h3>
<p><strong>Parameters</strong></p>
<p>VA  #VA by 3 list of vertex positions</p>
<p>FA  #FA by 3 list of face indices into VA</p>
<p>VB  #VB by 3 list of vertex positions</p>
<p>FB  #FB by 3 list of face indices into VB</p>
<hr />
<p><strong>Returns</strong></p>
<p>d  hausdorff distance</p>
<p>pair  2 by 3 list of &ldquo;determiner points&rdquo; so that pair(1,:) is from A</p>
<p>and pair(2,:) is from B</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>Known issue: This is only computing max(min(va,B),min(vb,A)). This is</p>
<p>better than max(min(va,Vb),min(vb,Va)). This (at least) is missing</p>
<p>&ldquo;edge-edge&rdquo; cases like the distance between the two different</p>
<p>triangulations of a non-planar quad in 3D. Even simpler, consider the</p>
<p>Hausdorff distance between the non-convex, block letter V polygon (with 7</p>
<p>vertices) in 2D and its convex hull. The Hausdorff distance is defined by</p>
<p>the midpoint in the middle of the segment across the concavity and some</p>
<p>non-vertex point <em>on the edge</em> of the V.</p>
<p><strong>Examples</strong></p>
<p>igl.internal_angles = internal_angles(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="internal_anglesv-array-f-array-object_1"><strong><code class="codehilite">internal_angles(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#internal_anglesv-array-f-array-object_1" title="Permanent link">&para;</a></h3>
<p>Computes internal angles for a triangle mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of mesh vertex nD positions</p>
<p>f : #f by poly-size array of face (triangle) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>k : #f by poly-size array of internal angles. For triangles, columns correspond to edges [1,2],[2,0],[0,1].</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>If poly-size ≠ 3 then dim must equal 3.</p>
<p><strong>Examples</strong></p>
<p>igl.internal_angles = internal_angles(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="internal_anglesv-array-f-array-object_2"><strong><code class="codehilite">internal_angles(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#internal_anglesv-array-f-array-object_2" title="Permanent link">&para;</a></h3>
<p>Computes internal angles for a triangle mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of mesh vertex nD positions</p>
<p>f : #f by poly-size array of face (triangle) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>k : #f by poly-size array of internal angles. For triangles, columns correspond to edges [1,2],[2,0],[0,1].</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>If poly-size ≠ 3 then dim must equal 3.</p>
<p><strong>Examples</strong></p>
<p>igl.is_edge_manifold = is_edge_manifold(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="is_edge_manifoldf-array-bool_1"><strong><code class="codehilite">is_edge_manifold(f: array) -&gt; bool</code></strong><a class="headerlink" href="#is_edge_manifoldf-array-bool_1" title="Permanent link">&para;</a></h3>
<p>See is_edge_manifold for the documentation.</p>
<p>igl.is_edge_manifold = is_edge_manifold(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="is_edge_manifoldf-array-bool_2"><strong><code class="codehilite">is_edge_manifold(f: array) -&gt; bool</code></strong><a class="headerlink" href="#is_edge_manifoldf-array-bool_2" title="Permanent link">&para;</a></h3>
<p>See is_edge_manifold for the documentation.</p>
<p>igl.is_irregular_vertex = is_irregular_vertex(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool_1"><strong><code class="codehilite">is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;</code></strong><a class="headerlink" href="#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool_1" title="Permanent link">&para;</a></h3>
<p>Determine if a vertex is irregular, i.e. it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of vertex positions</p>
<p>f : #f by 3[4] array of triangle[quads] indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>s : #v list of bools revealing whether vertices are singular</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.is_irregular_vertex = is_irregular_vertex(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool_2"><strong><code class="codehilite">is_irregular_vertex(v: array, f: array) -&gt; std::__1::vector&lt;bool, std::__1::allocator&lt;bool&gt; &gt;</code></strong><a class="headerlink" href="#is_irregular_vertexv-array-f-array-std__1vectorbool-std__1allocatorbool_2" title="Permanent link">&para;</a></h3>
<p>Determine if a vertex is irregular, i.e. it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim array of vertex positions</p>
<p>f : #f by 3[4] array of triangle[quads] indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>s : #v list of bools revealing whether vertices are singular</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.isolines = isolines(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="isolinesv-array-f-array-z-array-n-int-tupleobject-object_1"><strong><code class="codehilite">isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#isolinesv-array-f-array-z-array-n-int-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs isolines for a function z given on a mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh faces (must be triangles)</p>
<p>z  #V by 1 list of function values evaluated at vertices</p>
<p>n  the number of desired isolines</p>
<hr />
<p><strong>Returns</strong></p>
<p>isoV  #isoV by dim list of isoline vertex positions</p>
<p>isoE  #isoE by 2 list of isoline edge positions</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.isolines = isolines(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="isolinesv-array-f-array-z-array-n-int-tupleobject-object_2"><strong><code class="codehilite">isolines(v: array, f: array, z: array, n: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#isolinesv-array-f-array-z-array-n-int-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs isolines for a function z given on a mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh faces (must be triangles)</p>
<p>z  #V by 1 list of function values evaluated at vertices</p>
<p>n  the number of desired isolines</p>
<hr />
<p><strong>Returns</strong></p>
<p>isoV  #isoV by dim list of isoline vertex positions</p>
<p>isoE  #isoE by 2 list of isoline edge positions</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.lscm = lscm(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="lscmv-array-f-array-b-array-bc-array-tuplebool-object_1"><strong><code class="codehilite">lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]</code></strong><a class="headerlink" href="#lscmv-array-f-array-b-array-bc-array-tuplebool-object_1" title="Permanent link">&para;</a></h3>
<p>Compute a Least-squares conformal map parametrization.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex positions</p>
<p>f : #f by 3 array of mesh faces (must be triangles)</p>
<p>b : #b boundary indices into v</p>
<p>bc : #b by 3 list of boundary values</p>
<hr />
<p><strong>Returns</strong></p>
<p>uv #v by 2 list of 2D mesh vertex positions in UV space</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>Derived in &ldquo;Intrinsic Parameterizations of Surface Meshes&rdquo; [Desbrun et al.</p>
<p>2002] and &ldquo;Least Squares Conformal Maps for Automatic Texture Atlas</p>
<p>Generation&rdquo; [Lévy et al. 2002]), though this implementation follows the</p>
<p>derivation in: &ldquo;Spectral Conformal Parameterization&rdquo; [Mullen et al. 2008]</p>
<p>(note, this does <strong>not</strong> implement the Eigen-decomposition based method in</p>
<p>[Mullen et al. 2008], which is not equivalent. Input should be a manifold</p>
<p>mesh (also no unreferenced vertices) and &ldquo;boundary&rdquo; (fixed vertices) <code class="codehilite">b</code></p>
<p>should contain at least two vertices per connected component.</p>
<p><strong>Returns true only on solver success.</strong></p>
<p><strong>Examples</strong></p>
<p>igl.lscm = lscm(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="lscmv-array-f-array-b-array-bc-array-tuplebool-object_2"><strong><code class="codehilite">lscm(v: array, f: array, b: array, bc: array) -&gt; Tuple[bool, object]</code></strong><a class="headerlink" href="#lscmv-array-f-array-b-array-bc-array-tuplebool-object_2" title="Permanent link">&para;</a></h3>
<p>Compute a Least-squares conformal map parametrization.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex positions</p>
<p>f : #f by 3 array of mesh faces (must be triangles)</p>
<p>b : #b boundary indices into v</p>
<p>bc : #b by 3 list of boundary values</p>
<hr />
<p><strong>Returns</strong></p>
<p>uv #v by 2 list of 2D mesh vertex positions in UV space</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>Derived in &ldquo;Intrinsic Parameterizations of Surface Meshes&rdquo; [Desbrun et al.</p>
<p>2002] and &ldquo;Least Squares Conformal Maps for Automatic Texture Atlas</p>
<p>Generation&rdquo; [Lévy et al. 2002]), though this implementation follows the</p>
<p>derivation in: &ldquo;Spectral Conformal Parameterization&rdquo; [Mullen et al. 2008]</p>
<p>(note, this does <strong>not</strong> implement the Eigen-decomposition based method in</p>
<p>[Mullen et al. 2008], which is not equivalent. Input should be a manifold</p>
<p>mesh (also no unreferenced vertices) and &ldquo;boundary&rdquo; (fixed vertices) <code class="codehilite">b</code></p>
<p>should contain at least two vertices per connected component.</p>
<p><strong>Returns true only on solver success.</strong></p>
<p><strong>Examples</strong></p>
<p>igl.massmatrix = massmatrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="massmatrixv-array-f-array-type-int-1-object_1"><strong><code class="codehilite">massmatrix(v: array, f: array, type: int = 1) -&gt; object</code></strong><a class="headerlink" href="#massmatrixv-array-f-array-type-int-1-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs the mass (area) matrix for a given mesh (V,F).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of mesh vertex positions</p>
<p>f : #f by simplex_size list of mesh faces (must be triangles)</p>
<p>type : one of the following types:</p>
<p>-igl.MASSMATRIX_TYPE_BARYCENTRIC  barycentric</p>
<p>-igl.MASSMATRIX_TYPE_VORONOI voronoi-hybrid (default)</p>
<p>-igl.MASSMATRIX_TYPE_FULL full (not implemented)</p>
<hr />
<p><strong>Returns</strong></p>
<p>m : #v by #v mass matrix</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix, cotmatrix, grad</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.massmatrix = massmatrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="massmatrixv-array-f-array-type-int-1-object_2"><strong><code class="codehilite">massmatrix(v: array, f: array, type: int = 1) -&gt; object</code></strong><a class="headerlink" href="#massmatrixv-array-f-array-type-int-1-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs the mass (area) matrix for a given mesh (V,F).</p>
<p><strong>Parameters</strong></p>
<p>v : #v by dim list of mesh vertex positions</p>
<p>f : #f by simplex_size list of mesh faces (must be triangles)</p>
<p>type : one of the following types:</p>
<p>-igl.MASSMATRIX_TYPE_BARYCENTRIC  barycentric</p>
<p>-igl.MASSMATRIX_TYPE_VORONOI voronoi-hybrid (default)</p>
<p>-igl.MASSMATRIX_TYPE_FULL full (not implemented)</p>
<hr />
<p><strong>Returns</strong></p>
<p>m : #v by #v mass matrix</p>
<hr />
<p><strong>See also</strong></p>
<p>adjacency_matrix, cotmatrix, grad</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.min_quad_dense_precompute = min_quad_dense_precompute(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object_1"><strong><code class="codehilite">min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object</code></strong><a class="headerlink" href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object_1" title="Permanent link">&para;</a></h3>
<p>MIN_QUAD_WITH_FIXED Minimize quadratic energy Z&rsquo;*A*Z + Z&rsquo;*B + C</p>
<p>subject to linear constraints Aeq*Z = Beq</p>
<p><strong>Parameters</strong></p>
<p>A  n by n matrix of quadratic coefficients</p>
<p>B  n by 1 column of linear coefficients</p>
<p>Aeq  m by n list of linear equality constraint coefficients</p>
<p>Beq  m by 1 list of linear equality constraint constant values</p>
<p>use_lu_decomposition  use lu rather than SVD</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  n by (n + m) &ldquo;solve&rdquo; matrix, such that S*[B&rsquo;, Beq&rsquo;] is a solution</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.min_quad_dense_precompute = min_quad_dense_precompute(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object_2"><strong><code class="codehilite">min_quad_dense_precompute(a: array, aeq: array, use_lu_decomposition: bool) -&gt; object</code></strong><a class="headerlink" href="#min_quad_dense_precomputea-array-aeq-array-use_lu_decomposition-bool-object_2" title="Permanent link">&para;</a></h3>
<p>MIN_QUAD_WITH_FIXED Minimize quadratic energy Z&rsquo;*A*Z + Z&rsquo;*B + C</p>
<p>subject to linear constraints Aeq*Z = Beq</p>
<p><strong>Parameters</strong></p>
<p>A  n by n matrix of quadratic coefficients</p>
<p>B  n by 1 column of linear coefficients</p>
<p>Aeq  m by n list of linear equality constraint coefficients</p>
<p>Beq  m by 1 list of linear equality constraint constant values</p>
<p>use_lu_decomposition  use lu rather than SVD</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  n by (n + m) &ldquo;solve&rdquo; matrix, such that S*[B&rsquo;, Beq&rsquo;] is a solution</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.orientable_patches = orientable_patches(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="orientable_patchesf-array-tupleobject-object_1"><strong><code class="codehilite">orientable_patches(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#orientable_patchesf-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Compute connected components of facets connected by manifold edges.</p>
<p><strong>Parameters</strong></p>
<p>f : n by dim array of face ids</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple (c, A) where c is an array of component ids (starting with 0)</p>
<p>and A is a #f x #f adjacency matri</p>
<hr />
<p><strong>See also</strong></p>
<p>components</p>
<hr />
<p><strong>Notes</strong></p>
<p>Known bugs: This will detect a moebius strip as a single patch (manifold, non-orientable) and also non-manfiold, yet orientable patches.</p>
<p><strong>Examples</strong></p>
<p>igl.orientable_patches = orientable_patches(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="orientable_patchesf-array-tupleobject-object_2"><strong><code class="codehilite">orientable_patches(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#orientable_patchesf-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Compute connected components of facets connected by manifold edges.</p>
<p><strong>Parameters</strong></p>
<p>f : n by dim array of face ids</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple (c, A) where c is an array of component ids (starting with 0)</p>
<p>and A is a #f x #f adjacency matri</p>
<hr />
<p><strong>See also</strong></p>
<p>components</p>
<hr />
<p><strong>Notes</strong></p>
<p>Known bugs: This will detect a moebius strip as a single patch (manifold, non-orientable) and also non-manfiold, yet orientable patches.</p>
<p><strong>Examples</strong></p>
<p>igl.oriented_facets = oriented_facets(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="oriented_facetsf-array-object_1"><strong><code class="codehilite">oriented_facets(f: array) -&gt; object</code></strong><a class="headerlink" href="#oriented_facetsf-array-object_1" title="Permanent link">&para;</a></h3>
<p>Determines all &lsquo;directed <a href="https:en.wikipedia.org/wiki/Simplex#Elements">facets</a>&lsquo; of a given set</p>
<p>of simplicial elements. For a manifold triangle mesh, this computes all half-edges.</p>
<p>For a manifold tetrahedral mesh, this computes all half-faces.</p>
<p><strong>Parameters</strong></p>
<p>f : #F by simplex_size list of simplices</p>
<hr />
<p><strong>Returns</strong></p>
<p>: by simplex_size-1 list of half-edges/facets</p>
<hr />
<p><strong>See also</strong></p>
<p>edges</p>
<hr />
<p><strong>Notes</strong></p>
<p>This is not the same as igl::edges because this includes every</p>
<p>directed edge including repeats (meaning interior edges on a surface will</p>
<p>show up once for each direction and non-manifold edges may appear more than</p>
<p>once for each direction).</p>
<p><strong>Examples</strong></p>
<p>igl.oriented_facets = oriented_facets(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="oriented_facetsf-array-object_2"><strong><code class="codehilite">oriented_facets(f: array) -&gt; object</code></strong><a class="headerlink" href="#oriented_facetsf-array-object_2" title="Permanent link">&para;</a></h3>
<p>Determines all &lsquo;directed <a href="https:en.wikipedia.org/wiki/Simplex#Elements">facets</a>&lsquo; of a given set</p>
<p>of simplicial elements. For a manifold triangle mesh, this computes all half-edges.</p>
<p>For a manifold tetrahedral mesh, this computes all half-faces.</p>
<p><strong>Parameters</strong></p>
<p>f : #F by simplex_size list of simplices</p>
<hr />
<p><strong>Returns</strong></p>
<p>: by simplex_size-1 list of half-edges/facets</p>
<hr />
<p><strong>See also</strong></p>
<p>edges</p>
<hr />
<p><strong>Notes</strong></p>
<p>This is not the same as igl::edges because this includes every</p>
<p>directed edge including repeats (meaning interior edges on a surface will</p>
<p>show up once for each direction and non-manifold edges may appear more than</p>
<p>once for each direction).</p>
<p><strong>Examples</strong></p>
<p>igl.per_edge_normals = per_edge_normals(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object_1"><strong><code class="codehilite">per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object_1" title="Permanent link">&para;</a></h3>
<p>Compute face normals via vertex position list, face list</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 eigen Matrix of mesh vertex 3D positions</p>
<p>F  #F by 3 eigen Matrix of face (triangle) indices</p>
<p>weight  weighting type</p>
<p>FN  #F by 3 matrix of 3D face normals per face</p>
<hr />
<p><strong>Returns</strong></p>
<p>N  <a class="magiclink magiclink-github magiclink-issue" href="https://github.com/libigl-python-bindings/libigl-python-bindings/issues/2" title="GitHub Issue: libigl-python-bindings/libigl-python-bindings#2">#2</a> by 3 matrix of mesh edge 3D normals per row</p>
<p>E  #E by 2 matrix of edge indices per row</p>
<p>EMAP  #E by 1 matrix of indices from all edges to E</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.per_edge_normals = per_edge_normals(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object_2"><strong><code class="codehilite">per_edge_normals(v: array, f: array, weight: igl::PerEdgeNormalsWeightingType, fn: array) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#per_edge_normalsv-array-f-array-weight-iglperedgenormalsweightingtype-fn-array-tupleobject-object-object_2" title="Permanent link">&para;</a></h3>
<p>Compute face normals via vertex position list, face list</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 eigen Matrix of mesh vertex 3D positions</p>
<p>F  #F by 3 eigen Matrix of face (triangle) indices</p>
<p>weight  weighting type</p>
<p>FN  #F by 3 matrix of 3D face normals per face</p>
<hr />
<p><strong>Returns</strong></p>
<p>N  <a class="magiclink magiclink-github magiclink-issue" href="https://github.com/libigl-python-bindings/libigl-python-bindings/issues/2" title="GitHub Issue: libigl-python-bindings/libigl-python-bindings#2">#2</a> by 3 matrix of mesh edge 3D normals per row</p>
<p>E  #E by 2 matrix of edge indices per row</p>
<p>EMAP  #E by 1 matrix of indices from all edges to E</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.per_face_normals = per_face_normals(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="per_face_normalsv-array-f-array-z-array-object_1"><strong><code class="codehilite">per_face_normals(v: array, f: array, z: array) -&gt; object</code></strong><a class="headerlink" href="#per_face_normalsv-array-f-array-z-array-object_1" title="Permanent link">&para;</a></h3>
<p>Compute face normals via vertex position list, face list</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 eigen Matrix of mesh vertex 3D positions</p>
<p>F  #F by 3 eigen Matrix of face (triangle) indices</p>
<p>Z  3 vector normal given to faces with degenerate normal.</p>
<hr />
<p><strong>Returns</strong></p>
<p>N  #F by 3 eigen Matrix of mesh face (triangle) 3D normals</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Give degenerate faces (&#8531;,&#8531;,&#8531;)^0.5</p>
<hr />
<h3 id="per_face_normalsvfvector3d111normalizedn_1"><strong><code class="codehilite">per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);</code></strong><a class="headerlink" href="#per_face_normalsvfvector3d111normalizedn_1" title="Permanent link">&para;</a></h3>
<p>igl.per_face_normals = per_face_normals(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="per_face_normalsv-array-f-array-z-array-object_2"><strong><code class="codehilite">per_face_normals(v: array, f: array, z: array) -&gt; object</code></strong><a class="headerlink" href="#per_face_normalsv-array-f-array-z-array-object_2" title="Permanent link">&para;</a></h3>
<p>Compute face normals via vertex position list, face list</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 eigen Matrix of mesh vertex 3D positions</p>
<p>F  #F by 3 eigen Matrix of face (triangle) indices</p>
<p>Z  3 vector normal given to faces with degenerate normal.</p>
<hr />
<p><strong>Returns</strong></p>
<p>N  #F by 3 eigen Matrix of mesh face (triangle) 3D normals</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Give degenerate faces (&#8531;,&#8531;,&#8531;)^0.5</p>
<hr />
<h3 id="per_face_normalsvfvector3d111normalizedn_2"><strong><code class="codehilite">per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);</code></strong><a class="headerlink" href="#per_face_normalsvfvector3d111normalizedn_2" title="Permanent link">&para;</a></h3>
<p>igl.per_face_normals = per_face_normals(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="per_face_normalsv-array-f-array-z-array-object_3"><strong><code class="codehilite">per_face_normals(v: array, f: array, z: array) -&gt; object</code></strong><a class="headerlink" href="#per_face_normalsv-array-f-array-z-array-object_3" title="Permanent link">&para;</a></h3>
<p>Compute face normals via vertex position list, face list</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 eigen Matrix of mesh vertex 3D positions</p>
<p>F  #F by 3 eigen Matrix of face (triangle) indices</p>
<p>Z  3 vector normal given to faces with degenerate normal.</p>
<hr />
<p><strong>Returns</strong></p>
<p>N  #F by 3 eigen Matrix of mesh face (triangle) 3D normals</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Give degenerate faces (&#8531;,&#8531;,&#8531;)^0.5</p>
<hr />
<h3 id="per_face_normalsvfvector3d111normalizedn_3"><strong><code class="codehilite">per_face_normals(V,F,Vector3d(1,1,1).normalized(),N);</code></strong><a class="headerlink" href="#per_face_normalsvfvector3d111normalizedn_3" title="Permanent link">&para;</a></h3>
<p>igl.per_vertex_attribute_smoothing = per_vertex_attribute_smoothing(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="per_vertex_attribute_smoothingain-array-f-array-object_1"><strong><code class="codehilite">per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#per_vertex_attribute_smoothingain-array-f-array-object_1" title="Permanent link">&para;</a></h3>
<p>Smooth vertex attributes using uniform Laplacian</p>
<p><strong>Parameters</strong></p>
<p>Ain  #V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes)</p>
<p>F    #F by 3 eigne Matrix of face (triangle) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>Aout #V by #A eigen Matrix of mesh vertex attributes</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.per_vertex_attribute_smoothing = per_vertex_attribute_smoothing(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="per_vertex_attribute_smoothingain-array-f-array-object_2"><strong><code class="codehilite">per_vertex_attribute_smoothing(ain: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#per_vertex_attribute_smoothingain-array-f-array-object_2" title="Permanent link">&para;</a></h3>
<p>Smooth vertex attributes using uniform Laplacian</p>
<p><strong>Parameters</strong></p>
<p>Ain  #V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes)</p>
<p>F    #F by 3 eigne Matrix of face (triangle) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>Aout #V by #A eigen Matrix of mesh vertex attributes</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.per_vertex_normals = per_vertex_normals(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="per_vertex_normalsv-array-f-array-weighting-int-0-object_1"><strong><code class="codehilite">per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object</code></strong><a class="headerlink" href="#per_vertex_normalsv-array-f-array-weighting-int-0-object_1" title="Permanent link">&para;</a></h3>
<p>Compute vertex normals via vertex position list, face list.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex 3D positions</p>
<p>f : #f by 3 array of face (triangle) indices</p>
<p>weighting : Weighting type, one of the following</p>
<p>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM uniform influence</p>
<p>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA area weighted</p>
<p>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE angle weighted</p>
<hr />
<p><strong>Returns</strong></p>
<p>n  #v by 3 array of mesh vertex 3D normals</p>
<hr />
<p><strong>See also</strong></p>
<p>per_face_normals, per_edge_normals</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>n = per_vertex_normals(v, f)</p>
<p>igl.per_vertex_normals = per_vertex_normals(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="per_vertex_normalsv-array-f-array-weighting-int-0-object_2"><strong><code class="codehilite">per_vertex_normals(v: array, f: array, weighting: int = 0) -&gt; object</code></strong><a class="headerlink" href="#per_vertex_normalsv-array-f-array-weighting-int-0-object_2" title="Permanent link">&para;</a></h3>
<p>Compute vertex normals via vertex position list, face list.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex 3D positions</p>
<p>f : #f by 3 array of face (triangle) indices</p>
<p>weighting : Weighting type, one of the following</p>
<p>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM uniform influence</p>
<p>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA area weighted</p>
<p>-igl.PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE angle weighted</p>
<hr />
<p><strong>Returns</strong></p>
<p>n  #v by 3 array of mesh vertex 3D normals</p>
<hr />
<p><strong>See also</strong></p>
<p>per_face_normals, per_edge_normals</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>n = per_vertex_normals(v, f)</p>
<p>igl.piecewise_constant_winding_number = piecewise_constant_winding_number(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="piecewise_constant_winding_numberf-array-bool_1"><strong><code class="codehilite">piecewise_constant_winding_number(f: array) -&gt; bool</code></strong><a class="headerlink" href="#piecewise_constant_winding_numberf-array-bool_1" title="Permanent link">&para;</a></h3>
<p>PIECEWISE_CONSTANT_WINDING_NUMBER Determine if a given mesh induces a</p>
<p>piecewise constant winding number field: Is this mesh valid input to solid</p>
<p>set operations.  <strong>Assumes</strong> that <code class="codehilite">(V,F)</code> contains no -intersections</p>
<p>(including degeneracies and co-incidences).  If there are co-planar and</p>
<p>co-incident vertex placements, a mesh could <em>fail</em> this combinatorial test</p>
<p>but still induce a piecewise-constant winding number <em>geometrically</em>. For</p>
<p>example, consider a hemisphere with boundary and then pinch the boundary</p>
<p>&ldquo;shut&rdquo; along a line segment. The <strong><em>bullet-proof</em></strong> check is to first</p>
<p>resolve all -intersections in <code class="codehilite">(V,F) -&gt; (SV,SF)</code> (i.e. what the</p>
<p><code class="codehilite">igl::copyleft::cgal::piecewise_constant_winding_number</code> overload does).</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of triangle indices into some (abstract) list of</p>
<p>vertices V</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns true if the mesh <em>combinatorially</em> induces a piecewise constant</strong></p>
<p>winding number field.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.piecewise_constant_winding_number = piecewise_constant_winding_number(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="piecewise_constant_winding_numberf-array-bool_2"><strong><code class="codehilite">piecewise_constant_winding_number(f: array) -&gt; bool</code></strong><a class="headerlink" href="#piecewise_constant_winding_numberf-array-bool_2" title="Permanent link">&para;</a></h3>
<p>PIECEWISE_CONSTANT_WINDING_NUMBER Determine if a given mesh induces a</p>
<p>piecewise constant winding number field: Is this mesh valid input to solid</p>
<p>set operations.  <strong>Assumes</strong> that <code class="codehilite">(V,F)</code> contains no -intersections</p>
<p>(including degeneracies and co-incidences).  If there are co-planar and</p>
<p>co-incident vertex placements, a mesh could <em>fail</em> this combinatorial test</p>
<p>but still induce a piecewise-constant winding number <em>geometrically</em>. For</p>
<p>example, consider a hemisphere with boundary and then pinch the boundary</p>
<p>&ldquo;shut&rdquo; along a line segment. The <strong><em>bullet-proof</em></strong> check is to first</p>
<p>resolve all -intersections in <code class="codehilite">(V,F) -&gt; (SV,SF)</code> (i.e. what the</p>
<p><code class="codehilite">igl::copyleft::cgal::piecewise_constant_winding_number</code> overload does).</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of triangle indices into some (abstract) list of</p>
<p>vertices V</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns true if the mesh <em>combinatorially</em> induces a piecewise constant</strong></p>
<p>winding number field.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.principal_curvature = principal_curvature(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object_1"><strong><code class="codehilite">principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]</code></strong><a class="headerlink" href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object_1" title="Permanent link">&para;</a></h3>
<p>Compute the principal curvature directions and magnitude of the given triangle mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : vertex array of size #V by 3</p>
<p>f : face index array #F by 3 list of mesh faces (must be triangles)</p>
<p>radius : controls the size of the neighbourhood used, 1 = average edge length (default: 5)</p>
<p>use_k_ring : (default: True)</p>
<hr />
<p><strong>Returns</strong></p>
<p>pd1 : #v by 3 maximal curvature direction for each vertex</p>
<p>pd2 : #v by 3 minimal curvature direction for each vertex</p>
<p>pv1 : #v by 1 maximal curvature value for each vertex</p>
<p>pv2 : #v by 1 minimal curvature value for each vertex</p>
<hr />
<p><strong>See also</strong></p>
<p>average_onto_faces, average_onto_vertices</p>
<hr />
<p><strong>Notes</strong></p>
<p>This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo.</p>
<p>The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation</p>
<p>Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>pd1, pd2, pv1, pv2 = principal_curvature(v, f)</p>
<p>igl.principal_curvature = principal_curvature(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object_2"><strong><code class="codehilite">principal_curvature(v: array, f: array, radius: int = 5, use_k_ring: bool = True) -&gt; Tuple[object, object, object, object]</code></strong><a class="headerlink" href="#principal_curvaturev-array-f-array-radius-int-5-use_k_ring-bool-true-tupleobject-object-object-object_2" title="Permanent link">&para;</a></h3>
<p>Compute the principal curvature directions and magnitude of the given triangle mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : vertex array of size #V by 3</p>
<p>f : face index array #F by 3 list of mesh faces (must be triangles)</p>
<p>radius : controls the size of the neighbourhood used, 1 = average edge length (default: 5)</p>
<p>use_k_ring : (default: True)</p>
<hr />
<p><strong>Returns</strong></p>
<p>pd1 : #v by 3 maximal curvature direction for each vertex</p>
<p>pd2 : #v by 3 minimal curvature direction for each vertex</p>
<p>pv1 : #v by 1 maximal curvature value for each vertex</p>
<p>pv2 : #v by 1 minimal curvature value for each vertex</p>
<hr />
<p><strong>See also</strong></p>
<p>average_onto_faces, average_onto_vertices</p>
<hr />
<p><strong>Notes</strong></p>
<p>This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo.</p>
<p>The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation</p>
<p>Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>pd1, pd2, pv1, pv2 = principal_curvature(v, f)</p>
<p>igl.procrustes = procrustes(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="procrustesx-array-y-array-tuplebool-bool-float-object-object_1"><strong><code class="codehilite">procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]</code></strong><a class="headerlink" href="#procrustesx-array-y-array-tuplebool-bool-float-object-object_1" title="Permanent link">&para;</a></h3>
<p>Solve Procrustes problem in d dimensions.  Given two point sets X,Y in R^d</p>
<p>find best scale s, orthogonal R  and translation t s.t. s*X*R + t - Y^2</p>
<p>is minimized.</p>
<p><strong>Parameters</strong></p>
<p>X  #V by DIM first list of points</p>
<p>Y  #V by DIM second list of points</p>
<p>includeScaling  if scaling should be allowed</p>
<p>includeReflections  if R is allowed to be a reflection</p>
<hr />
<p><strong>Returns</strong></p>
<p>scale  scaling</p>
<p>R      orthogonal matrix</p>
<p>t      translation</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>MatrixXd X, Y; (containing 3d points as rows)</p>
<p>double scale;</p>
<p>MatrixXd R;</p>
<p>VectorXd t;</p>
<p>igl::procrustes(X,Y,true,false,scale,R,t);</p>
<p>R *= scale;</p>
<p>MatrixXd Xprime = (X * R).rowwise() + t.transpose();</p>
<p>igl.procrustes = procrustes(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="procrustesx-array-y-array-tuplebool-bool-float-object-object_2"><strong><code class="codehilite">procrustes(x: array, y: array) -&gt; Tuple[bool, bool, float, object, object]</code></strong><a class="headerlink" href="#procrustesx-array-y-array-tuplebool-bool-float-object-object_2" title="Permanent link">&para;</a></h3>
<p>Solve Procrustes problem in d dimensions.  Given two point sets X,Y in R^d</p>
<p>find best scale s, orthogonal R  and translation t s.t. s*X*R + t - Y^2</p>
<p>is minimized.</p>
<p><strong>Parameters</strong></p>
<p>X  #V by DIM first list of points</p>
<p>Y  #V by DIM second list of points</p>
<p>includeScaling  if scaling should be allowed</p>
<p>includeReflections  if R is allowed to be a reflection</p>
<hr />
<p><strong>Returns</strong></p>
<p>scale  scaling</p>
<p>R      orthogonal matrix</p>
<p>t      translation</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>MatrixXd X, Y; (containing 3d points as rows)</p>
<p>double scale;</p>
<p>MatrixXd R;</p>
<p>VectorXd t;</p>
<p>igl::procrustes(X,Y,true,false,scale,R,t);</p>
<p>R *= scale;</p>
<p>MatrixXd Xprime = (X * R).rowwise() + t.transpose();</p>
<p>igl.qslim = qslim(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object_1"><strong><code class="codehilite">qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]</code></strong><a class="headerlink" href="#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object_1" title="Permanent link">&para;</a></h3>
<p>Decimate (simplify) a triangle mesh in nD according to the paper</p>
<p>&ldquo;Simplifying Surfaces with Color and Texture using Quadric Error Metrics&rdquo;</p>
<p>by [Garland and Heckbert, 1987] (technically a followup to qslim). The</p>
<p>mesh can have open boundaries but should be edge-manifold.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions. Assumes that vertices w</p>
<p>F  #F by 3 list of triangle indices into V</p>
<p>max_m  desired number of output faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>U  #U by dim list of output vertex posistions (can be same ref as V)</p>
<p>G  #G by 3 list of output face indices into U (can be same ref as G)</p>
<p>J  #G list of indices into F of birth face</p>
<p>I  #U list of indices into V of birth vertices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.qslim = qslim(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object_2"><strong><code class="codehilite">qslim(v: array, f: array, max_m: int) -&gt; Tuple[bool, object, object, object, object]</code></strong><a class="headerlink" href="#qslimv-array-f-array-max_m-int-tuplebool-object-object-object-object_2" title="Permanent link">&para;</a></h3>
<p>Decimate (simplify) a triangle mesh in nD according to the paper</p>
<p>&ldquo;Simplifying Surfaces with Color and Texture using Quadric Error Metrics&rdquo;</p>
<p>by [Garland and Heckbert, 1987] (technically a followup to qslim). The</p>
<p>mesh can have open boundaries but should be edge-manifold.</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions. Assumes that vertices w</p>
<p>F  #F by 3 list of triangle indices into V</p>
<p>max_m  desired number of output faces</p>
<hr />
<p><strong>Returns</strong></p>
<p>U  #U by dim list of output vertex posistions (can be same ref as V)</p>
<p>G  #G by 3 list of output face indices into U (can be same ref as G)</p>
<p>J  #G list of indices into F of birth face</p>
<p>I  #U list of indices into V of birth vertices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.quad_planarity = quad_planarity(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="quad_planarityv-array-f-array-object_1"><strong><code class="codehilite">quad_planarity(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#quad_planarityv-array-f-array-object_1" title="Permanent link">&para;</a></h3>
<p>Compute planarity of the faces of a quad mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex 3D positions</p>
<p>f : #f by 4 array of face (quad) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>p : #f by 1 array of mesh face (quad) planarities</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.quad_planarity = quad_planarity(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="quad_planarityv-array-f-array-object_2"><strong><code class="codehilite">quad_planarity(v: array, f: array) -&gt; object</code></strong><a class="headerlink" href="#quad_planarityv-array-f-array-object_2" title="Permanent link">&para;</a></h3>
<p>Compute planarity of the faces of a quad mesh.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 array of mesh vertex 3D positions</p>
<p>f : #f by 4 array of face (quad) indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>p : #f by 1 array of mesh face (quad) planarities</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.random_points_on_mesh = random_points_on_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="random_points_on_meshn-int-v-array-f-array-tupleobject-object_1"><strong><code class="codehilite">random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#random_points_on_meshn-int-v-array-f-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>RANDOM_POINTS_ON_MESH Randomly sample a mesh (V,F) n times.</p>
<p><strong>Parameters</strong></p>
<p>n  number of samples</p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh triangle indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>B  n by 3 list of barycentric coordinates, ith row are coordinates of</p>
<p>ith sampled point in face FI(i)</p>
<p>FI  n list of indices into F</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.random_points_on_mesh = random_points_on_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="random_points_on_meshn-int-v-array-f-array-tupleobject-object_2"><strong><code class="codehilite">random_points_on_mesh(n: int, v: array, f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#random_points_on_meshn-int-v-array-f-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>RANDOM_POINTS_ON_MESH Randomly sample a mesh (V,F) n times.</p>
<p><strong>Parameters</strong></p>
<p>n  number of samples</p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh triangle indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>B  n by 3 list of barycentric coordinates, ith row are coordinates of</p>
<p>ith sampled point in face FI(i)</p>
<p>FI  n list of indices into F</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.read_dmat = read_dmat(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="read_dmatfilename-str-dtype-numpydtype-str-type-float64-object_1"><strong><code class="codehilite">read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object</code></strong><a class="headerlink" href="#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object_1" title="Permanent link">&para;</a></h3>
<p>Read a matrix from an ascii dmat file, a simple ascii matrix file type, defined as follows. The first line is always:</p>
<p>&lt;#columns&gt; &lt;#rows&gt;</p>
<p>Then the coefficients of the matrix are given separated by whitespace with columns running fastest.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to .dmat file</p>
<p>dtype : data-type of the returned matrix. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>w : array containing read-in coefficients</p>
<hr />
<p><strong>See also</strong></p>
<p>read_triangle_mesh, read_off</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>w = read_dmat(&ldquo;my_model.dmat&rdquo;)</p>
<p>igl.read_dmat = read_dmat(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="read_dmatfilename-str-dtype-numpydtype-str-type-float64-object_2"><strong><code class="codehilite">read_dmat(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; object</code></strong><a class="headerlink" href="#read_dmatfilename-str-dtype-numpydtype-str-type-float64-object_2" title="Permanent link">&para;</a></h3>
<p>Read a matrix from an ascii dmat file, a simple ascii matrix file type, defined as follows. The first line is always:</p>
<p>&lt;#columns&gt; &lt;#rows&gt;</p>
<p>Then the coefficients of the matrix are given separated by whitespace with columns running fastest.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to .dmat file</p>
<p>dtype : data-type of the returned matrix. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>w : array containing read-in coefficients</p>
<hr />
<p><strong>See also</strong></p>
<p>read_triangle_mesh, read_off</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>w = read_dmat(&ldquo;my_model.dmat&rdquo;)</p>
<p>igl.read_obj = read_obj(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object_1"><strong><code class="codehilite">read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]</code></strong><a class="headerlink" href="#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object_1" title="Permanent link">&para;</a></h3>
<p>Read a mesh from an ascii obj file, filling in vertex positions, normals</p>
<p>and texture coordinates. Mesh may have faces of any number of degree.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to .obj file</p>
<p>dtype : data-type of the returned faces, texture coordinates and normals, optional. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v : array of vertex positions #v by 3</p>
<p>tc : array of texture coordinats #tc by 2</p>
<p>n : array of corner normals #n by 3</p>
<p>f : #f array of face indices into vertex positions</p>
<p>ftc : #f array of face indices into vertex texture coordinates</p>
<p>fn : #f array of face indices into vertex normals</p>
<hr />
<p><strong>See also</strong></p>
<p>read_triangle_mesh, read_off</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>v, _, n, f, _, _ = read_obj(&ldquo;my_model.obj&rdquo;)</p>
<p>igl.read_obj = read_obj(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object_2"><strong><code class="codehilite">read_obj(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object, object, object, object]</code></strong><a class="headerlink" href="#read_objfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object-object-object-object-object_2" title="Permanent link">&para;</a></h3>
<p>Read a mesh from an ascii obj file, filling in vertex positions, normals</p>
<p>and texture coordinates. Mesh may have faces of any number of degree.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to .obj file</p>
<p>dtype : data-type of the returned faces, texture coordinates and normals, optional. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v : array of vertex positions #v by 3</p>
<p>tc : array of texture coordinats #tc by 2</p>
<p>n : array of corner normals #n by 3</p>
<p>f : #f array of face indices into vertex positions</p>
<p>ftc : #f array of face indices into vertex texture coordinates</p>
<p>fn : #f array of face indices into vertex normals</p>
<hr />
<p><strong>See also</strong></p>
<p>read_triangle_mesh, read_off</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>v, _, n, f, _, _ = read_obj(&ldquo;my_model.obj&rdquo;)</p>
<p>igl.read_off = read_off(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object_1"><strong><code class="codehilite">read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object_1" title="Permanent link">&para;</a></h3>
<p>Read a mesh from an ascii off file, filling in vertex positions, normals</p>
<p>and texture coordinates. Mesh may have faces of any number of degree.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to .off file</p>
<p>read_normals : bool, determines whether normals are read. If false, <strong>returns []</strong></p>
<p>dtype : data-type of the returned vertices, faces, and normals, optional. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v : array of vertex positions #v by 3</p>
<p>f : #f list of face indices into vertex positions</p>
<p>n : list of vertex normals #v by 3</p>
<hr />
<p><strong>See also</strong></p>
<p>read_triangle_mesh, read_obj</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>v, f, n, c = read_off(&ldquo;my_model.off&rdquo;)</p>
<p>igl.read_off = read_off(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object_2"><strong><code class="codehilite">read_off(filename: str, read_normals: bool = True, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#read_offfilename-str-read_normals-bool-true-dtype-numpydtype-str-type-float64-tupleobject-object-object_2" title="Permanent link">&para;</a></h3>
<p>Read a mesh from an ascii off file, filling in vertex positions, normals</p>
<p>and texture coordinates. Mesh may have faces of any number of degree.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to .off file</p>
<p>read_normals : bool, determines whether normals are read. If false, <strong>returns []</strong></p>
<p>dtype : data-type of the returned vertices, faces, and normals, optional. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v : array of vertex positions #v by 3</p>
<p>f : #f list of face indices into vertex positions</p>
<p>n : list of vertex normals #v by 3</p>
<hr />
<p><strong>See also</strong></p>
<p>read_triangle_mesh, read_obj</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>v, f, n, c = read_off(&ldquo;my_model.off&rdquo;)</p>
<p>igl.read_triangle_mesh = read_triangle_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object_1"><strong><code class="codehilite">read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Read mesh from an ascii file with automatic detection of file format.</p>
<p>Supported: obj, off, stl, wrl, ply, mesh.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to mesh file</p>
<p>dtype : data-type of the returned vertices, optional. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v : array of vertex positions #v by 3</p>
<p>f : #f list of face indices into vertex positions</p>
<hr />
<p><strong>See also</strong></p>
<p>read_obj, read_off, read_stl</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>v, f = read_triangle_mesh(&ldquo;my_model.obj&rdquo;)</p>
<p>igl.read_triangle_mesh = read_triangle_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object_2"><strong><code class="codehilite">read_triangle_mesh(filename: str, dtype: numpy.dtype  str  type = &#39;float64&#39;) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#read_triangle_meshfilename-str-dtype-numpydtype-str-type-float64-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Read mesh from an ascii file with automatic detection of file format.</p>
<p>Supported: obj, off, stl, wrl, ply, mesh.</p>
<p><strong>Parameters</strong></p>
<p>filename : string, path to mesh file</p>
<p>dtype : data-type of the returned vertices, optional. Default is <code class="codehilite">float64</code>.</p>
<p>(returned faces always have type int32.)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v : array of vertex positions #v by 3</p>
<p>f : #f list of face indices into vertex positions</p>
<hr />
<p><strong>See also</strong></p>
<p>read_obj, read_off, read_stl</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>v, f = read_triangle_mesh(&ldquo;my_model.obj&rdquo;)</p>
<p>igl.remove_duplicate_vertices = remove_duplicate_vertices(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object_1"><strong><code class="codehilite">remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]</code></strong><a class="headerlink" href="#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object_1" title="Permanent link">&para;</a></h3>
<p>REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness</p>
<p>tolerance (epsilon)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>epsilon  uniqueness tolerance (significant digit), can probably think of</p>
<p>this as a tolerance on L1 distance</p>
<hr />
<p><strong>Returns</strong></p>
<p>SV  #SV by dim new list of vertex positions</p>
<p>SVI #V by 1 list of indices so SV = V(SVI,:)</p>
<p>SVJ #SV by 1 list of indices so V = SV(SVJ,:)</p>
<p>Wrapper that also remaps given faces (F) &rarr; (SF) so that SF index SV</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>% Mesh in (V,F)</p>
<p>[SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7);</p>
<p>% remap faces</p>
<p>SF = SVJ(F);</p>
<p>igl.remove_duplicate_vertices = remove_duplicate_vertices(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object_2"><strong><code class="codehilite">remove_duplicate_vertices(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object, object]</code></strong><a class="headerlink" href="#remove_duplicate_verticesv-array-f-array-epsilon-float-tupleobject-object-object-object_2" title="Permanent link">&para;</a></h3>
<p>REMOVE_DUPLICATE_VERTICES Remove duplicate vertices upto a uniqueness</p>
<p>tolerance (epsilon)</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of vertex positions</p>
<p>epsilon  uniqueness tolerance (significant digit), can probably think of</p>
<p>this as a tolerance on L1 distance</p>
<hr />
<p><strong>Returns</strong></p>
<p>SV  #SV by dim new list of vertex positions</p>
<p>SVI #V by 1 list of indices so SV = V(SVI,:)</p>
<p>SVJ #SV by 1 list of indices so V = SV(SVJ,:)</p>
<p>Wrapper that also remaps given faces (F) &rarr; (SF) so that SF index SV</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>% Mesh in (V,F)</p>
<p>[SV,SVI,SVJ] = remove_duplicate_vertices(V,1e-7);</p>
<p>% remap faces</p>
<p>SF = SVJ(F);</p>
<p>igl.remove_duplicates = remove_duplicates(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object_1"><strong><code class="codehilite">remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object_1" title="Permanent link">&para;</a></h3>
<p>Merge the duplicate vertices from V, fixing the topology accordingly</p>
<p><strong>Parameters</strong></p>
<p>V,F       mesh description</p>
<p>epsilon   minimal distance to consider two vertices identical</p>
<hr />
<p><strong>Returns</strong></p>
<p>NV, NF    new mesh without duplicate vertices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.remove_duplicates = remove_duplicates(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object_2"><strong><code class="codehilite">remove_duplicates(v: array, f: array, epsilon: float) -&gt; Tuple[object, object, object]</code></strong><a class="headerlink" href="#remove_duplicatesv-array-f-array-epsilon-float-tupleobject-object-object_2" title="Permanent link">&para;</a></h3>
<p>Merge the duplicate vertices from V, fixing the topology accordingly</p>
<p><strong>Parameters</strong></p>
<p>V,F       mesh description</p>
<p>epsilon   minimal distance to consider two vertices identical</p>
<hr />
<p><strong>Returns</strong></p>
<p>NV, NF    new mesh without duplicate vertices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.remove_unreferenced = remove_unreferenced(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="remove_unreferencedv-array-f-array-tupleobject-object-object-object_1"><strong><code class="codehilite">remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]</code></strong><a class="headerlink" href="#remove_unreferencedv-array-f-array-tupleobject-object-object-object_1" title="Permanent link">&para;</a></h3>
<p>Remove unreferenced vertices from V, updating F accordingly</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by ss list of simplices (Values of -1 are quitely skipped)</p>
<hr />
<p><strong>Returns</strong></p>
<p>NV  #NV by dim list of mesh vertex positions</p>
<p>NF  #NF by ss list of simplices</p>
<p>IM  #V by 1 list of indices such that: NF = IM(F) and NT = IM(T)</p>
<p>and V(find(IM&lt;=size(NV,1)),:) = NV</p>
<p>J  #RV by 1 list, such that RV = V(J,:)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.remove_unreferenced = remove_unreferenced(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="remove_unreferencedv-array-f-array-tupleobject-object-object-object_2"><strong><code class="codehilite">remove_unreferenced(v: array, f: array) -&gt; Tuple[object, object, object, object]</code></strong><a class="headerlink" href="#remove_unreferencedv-array-f-array-tupleobject-object-object-object_2" title="Permanent link">&para;</a></h3>
<p>Remove unreferenced vertices from V, updating F accordingly</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim list of mesh vertex positions</p>
<p>F  #F by ss list of simplices (Values of -1 are quitely skipped)</p>
<hr />
<p><strong>Returns</strong></p>
<p>NV  #NV by dim list of mesh vertex positions</p>
<p>NF  #NF by ss list of simplices</p>
<p>IM  #V by 1 list of indices such that: NF = IM(F) and NT = IM(T)</p>
<p>and V(find(IM&lt;=size(NV,1)),:) = NV</p>
<p>J  #RV by 1 list, such that RV = V(J,:)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.resolve_duplicated_faces = resolve_duplicated_faces(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="resolve_duplicated_facesf1-array-tupleobject-object_1"><strong><code class="codehilite">resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#resolve_duplicated_facesf1-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Resolve duplicated faces according to the following rules per unique face:</p>
<hr />
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of_3"><strong><code class="codehilite">If the number of positively oriented faces equals the number of</code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_3" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces, remove all duplicated faces at this triangle.</p>
<hr />
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of_4"><strong><code class="codehilite">If the number of positively oriented faces equals the number of</code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_4" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces plus 1, keeps one of the positively oriented</p>
<p>face.</p>
<hr />
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of_5"><strong><code class="codehilite">If the number of positively oriented faces equals the number of</code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_5" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces minus 1, keeps one of the negatively oriented</p>
<p>face.</p>
<hr />
<h3 id="if-the-number-of-postively-oriented-faces-differ-with-the-number-of_1"><strong><code class="codehilite">If the number of postively oriented faces differ with the number of</code></strong><a class="headerlink" href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of_1" title="Permanent link">&para;</a></h3>
<p>negativley oriented faces by more than 1, the mesh is not orientable.</p>
<p>An exception will be thrown.</p>
<p><strong>Parameters</strong></p>
<p>F1  #F1 by 3 array of input faces.</p>
<hr />
<p><strong>Returns</strong></p>
<p>F2  #F2 by 3 array of output faces without duplicated faces.</p>
<p>J   #F2 list of indices into F1.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.resolve_duplicated_faces = resolve_duplicated_faces(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="resolve_duplicated_facesf1-array-tupleobject-object_2"><strong><code class="codehilite">resolve_duplicated_faces(f1: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#resolve_duplicated_facesf1-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Resolve duplicated faces according to the following rules per unique face:</p>
<hr />
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of_6"><strong><code class="codehilite">If the number of positively oriented faces equals the number of</code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_6" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces, remove all duplicated faces at this triangle.</p>
<hr />
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of_7"><strong><code class="codehilite">If the number of positively oriented faces equals the number of</code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_7" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces plus 1, keeps one of the positively oriented</p>
<p>face.</p>
<hr />
<h3 id="if-the-number-of-positively-oriented-faces-equals-the-number-of_8"><strong><code class="codehilite">If the number of positively oriented faces equals the number of</code></strong><a class="headerlink" href="#if-the-number-of-positively-oriented-faces-equals-the-number-of_8" title="Permanent link">&para;</a></h3>
<p>negatively oriented faces minus 1, keeps one of the negatively oriented</p>
<p>face.</p>
<hr />
<h3 id="if-the-number-of-postively-oriented-faces-differ-with-the-number-of_2"><strong><code class="codehilite">If the number of postively oriented faces differ with the number of</code></strong><a class="headerlink" href="#if-the-number-of-postively-oriented-faces-differ-with-the-number-of_2" title="Permanent link">&para;</a></h3>
<p>negativley oriented faces by more than 1, the mesh is not orientable.</p>
<p>An exception will be thrown.</p>
<p><strong>Parameters</strong></p>
<p>F1  #F1 by 3 array of input faces.</p>
<hr />
<p><strong>Returns</strong></p>
<p>F2  #F2 by 3 array of output faces without duplicated faces.</p>
<p>J   #F2 list of indices into F1.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.shape_diameter_function = shape_diameter_function(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object_1"><strong><code class="codehilite">shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object</code></strong><a class="headerlink" href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object_1" title="Permanent link">&para;</a></h3>
<p>Compute shape diamater function per given point. In the parlence of the</p>
<p>paper &ldquo;Consistent Mesh Partitioning and Skeletonisation using the Shape</p>
<p>Diameter Function&rdquo; [Shapiro et al. 2008], this implementation uses a 180°</p>
<p>cone and a <em>uniform</em> average (<em>not</em> a average weighted by inverse angles).</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh face indices into V</p>
<p>P  #P by 3 list of origin points</p>
<p>N  #P by 3 list of origin normals</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  #P list of shape diamater function values between bounding box</p>
<p>diagonal (perfect sphere) and 0 (perfect needle hook)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.shape_diameter_function = shape_diameter_function(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object_2"><strong><code class="codehilite">shape_diameter_function(v: array, f: array, p: array, n: array, num_samples: int) -&gt; object</code></strong><a class="headerlink" href="#shape_diameter_functionv-array-f-array-p-array-n-array-num_samples-int-object_2" title="Permanent link">&para;</a></h3>
<p>Compute shape diamater function per given point. In the parlence of the</p>
<p>paper &ldquo;Consistent Mesh Partitioning and Skeletonisation using the Shape</p>
<p>Diameter Function&rdquo; [Shapiro et al. 2008], this implementation uses a 180°</p>
<p>cone and a <em>uniform</em> average (<em>not</em> a average weighted by inverse angles).</p>
<p><strong>Parameters</strong></p>
<p>V  #V by 3 list of mesh vertex positions</p>
<p>F  #F by 3 list of mesh face indices into V</p>
<p>P  #P by 3 list of origin points</p>
<p>N  #P by 3 list of origin normals</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  #P list of shape diamater function values between bounding box</p>
<p>diagonal (perfect sphere) and 0 (perfect needle hook)</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.sort_angles = sort_angles(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="sort_anglesm-array-object_1"><strong><code class="codehilite">sort_angles(m: array) -&gt; object</code></strong><a class="headerlink" href="#sort_anglesm-array-object_1" title="Permanent link">&para;</a></h3>
<p>Sort angles in ascending order in a numerically robust way.</p>
<p>Instead of computing angles using atan2(y, x), sort directly on (y, x).</p>
<p><strong>Parameters</strong></p>
<p>-</p>
<p>M: m by n matrix of scalars. (n &gt;= 2).  Assuming the first column of M</p>
<p>contains values for y, and the second column is x.  Using the rest</p>
<p>of the columns as tie-breaker.</p>
<hr />
<p><strong>Returns</strong></p>
<p>R: an array of m indices.  M.row(R[i]) contains the i-th smallest</p>
<p>angle.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None.</p>
<p><strong>Examples</strong></p>
<p>igl.sort_angles = sort_angles(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="sort_anglesm-array-object_2"><strong><code class="codehilite">sort_angles(m: array) -&gt; object</code></strong><a class="headerlink" href="#sort_anglesm-array-object_2" title="Permanent link">&para;</a></h3>
<p>Sort angles in ascending order in a numerically robust way.</p>
<p>Instead of computing angles using atan2(y, x), sort directly on (y, x).</p>
<p><strong>Parameters</strong></p>
<p>-</p>
<p>M: m by n matrix of scalars. (n &gt;= 2).  Assuming the first column of M</p>
<p>contains values for y, and the second column is x.  Using the rest</p>
<p>of the columns as tie-breaker.</p>
<hr />
<p><strong>Returns</strong></p>
<p>R: an array of m indices.  M.row(R[i]) contains the i-th smallest</p>
<p>angle.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None.</p>
<p><strong>Examples</strong></p>
<p>igl.tetrahedralize = tetrahedralize(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object_1"><strong><code class="codehilite">tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]</code></strong><a class="headerlink" href="#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object_1" title="Permanent link">&para;</a></h3>
<p>Mesh the interior of a surface mesh (V,F) using tetgen.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 vertex position array</p>
<p>f : #v array of polygon face indices into V (0-indexed)</p>
<p>switches : string of tetgen options (See tetgen documentation) e.g.</p>
<p>&ldquo;pq1.414a0.01&rdquo; tries to mesh the interior of a given surface with quality and area constraints. Will mesh the convex hull constrained to pass through V (ignores F)</p>
<hr />
<p><strong>Returns</strong></p>
<p>tv  #v by 3 vertex position array</p>
<p>tt  #t by 4 array of tet face indices</p>
<p>tf  #f by 3 array of triangle face indices</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Returns status:</strong></p>
<p>0 success</p>
<p>1 tetgen threw exception</p>
<p>2 tetgen did not crash but could not create any tets (probably there are</p>
<p>holes, duplicate faces etc.)</p>
<p>-1 other error</p>
<p><strong>Examples</strong></p>
<p>igl.tetrahedralize = tetrahedralize(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object_2"><strong><code class="codehilite">tetrahedralize(v: array, f: array, switches: str = &#39;pYQ&#39;) -&gt; Tuple[int, object, object, object]</code></strong><a class="headerlink" href="#tetrahedralizev-array-f-array-switches-str-pyq-tupleint-object-object-object_2" title="Permanent link">&para;</a></h3>
<p>Mesh the interior of a surface mesh (V,F) using tetgen.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 3 vertex position array</p>
<p>f : #v array of polygon face indices into V (0-indexed)</p>
<p>switches : string of tetgen options (See tetgen documentation) e.g.</p>
<p>&ldquo;pq1.414a0.01&rdquo; tries to mesh the interior of a given surface with quality and area constraints. Will mesh the convex hull constrained to pass through V (ignores F)</p>
<hr />
<p><strong>Returns</strong></p>
<p>tv  #v by 3 vertex position array</p>
<p>tt  #t by 4 array of tet face indices</p>
<p>tf  #f by 3 array of triangle face indices</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Returns status:</strong></p>
<p>0 success</p>
<p>1 tetgen threw exception</p>
<p>2 tetgen did not crash but could not create any tets (probably there are</p>
<p>holes, duplicate faces etc.)</p>
<p>-1 other error</p>
<p><strong>Examples</strong></p>
<p>igl.triangle_triangle_adjacency = triangle_triangle_adjacency(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="triangle_triangle_adjacencyf-array-tupleobject-object_1"><strong><code class="codehilite">triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#triangle_triangle_adjacencyf-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs the triangle-triangle adjacency matrix for a given</p>
<p>mesh (V,F).</p>
<p><strong>Parameters</strong></p>
<p>F  #F by simplex_size list of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p>TT   #F by <a class="magiclink magiclink-github magiclink-issue" href="https://github.com/libigl-python-bindings/libigl-python-bindings/issues/3" title="GitHub Issue: libigl-python-bindings/libigl-python-bindings#3">#3</a> adjacent matrix, the element i,j is the id of the triangle</p>
<p>adjacent to the j edge of triangle i</p>
<p>TTi  #F by <a class="magiclink magiclink-github magiclink-issue" href="https://github.com/libigl-python-bindings/libigl-python-bindings/issues/3" title="GitHub Issue: libigl-python-bindings/libigl-python-bindings#3">#3</a> adjacent matrix, the element i,j is the id of edge of the</p>
<p>triangle TT(i,j) that is adjacent with triangle i</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third</p>
<p>[2,3].  this convention is DIFFERENT from cotmatrix_entries.h</p>
<p><strong>Examples</strong></p>
<p>igl.triangle_triangle_adjacency = triangle_triangle_adjacency(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="triangle_triangle_adjacencyf-array-tupleobject-object_2"><strong><code class="codehilite">triangle_triangle_adjacency(f: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#triangle_triangle_adjacencyf-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs the triangle-triangle adjacency matrix for a given</p>
<p>mesh (V,F).</p>
<p><strong>Parameters</strong></p>
<p>F  #F by simplex_size list of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p>TT   #F by <a class="magiclink magiclink-github magiclink-issue" href="https://github.com/libigl-python-bindings/libigl-python-bindings/issues/3" title="GitHub Issue: libigl-python-bindings/libigl-python-bindings#3">#3</a> adjacent matrix, the element i,j is the id of the triangle</p>
<p>adjacent to the j edge of triangle i</p>
<p>TTi  #F by <a class="magiclink magiclink-github magiclink-issue" href="https://github.com/libigl-python-bindings/libigl-python-bindings/issues/3" title="GitHub Issue: libigl-python-bindings/libigl-python-bindings#3">#3</a> adjacent matrix, the element i,j is the id of edge of the</p>
<p>triangle TT(i,j) that is adjacent with triangle i</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>NOTE: the first edge of a triangle is [0,1] the second [1,2] and the third</p>
<p>[2,3].  this convention is DIFFERENT from cotmatrix_entries.h</p>
<p><strong>Examples</strong></p>
<p>igl.triangulate = triangulate(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object_1"><strong><code class="codehilite">triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Triangulate the interior of a polygon using the triangle library.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 2 array of 2D vertex positions</p>
<p>e : #e by 2 array of vertex ids forming unoriented edges of the boundary of the polygon</p>
<p>h : #h by 2 coordinates of points contained inside holes of the polygon</p>
<p>m : optional #v list of markers for input vertices</p>
<p>flags : string of options pass to triangle (see triangle documentation) (default &lsquo;a0.005q&rsquo;)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v2 : #v2 by 2 coordinates of the vertives of the generated triangulation</p>
<p>f2 : #f2 by 3 array of indices forming the faces of the generated triangulation</p>
<p>m2 : (only if you passed in m) #v2 list of markers for output vertices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>v2, f2 = triangulate(v, e, h)</p>
<p>igl.triangulate = triangulate(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object_2"><strong><code class="codehilite">triangulate(v: array, e: array, h: array, flags: str = &#39;a0.005qQ&#39;) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#triangulatev-array-e-array-h-array-flags-str-a0005qq-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Triangulate the interior of a polygon using the triangle library.</p>
<p><strong>Parameters</strong></p>
<p>v : #v by 2 array of 2D vertex positions</p>
<p>e : #e by 2 array of vertex ids forming unoriented edges of the boundary of the polygon</p>
<p>h : #h by 2 coordinates of points contained inside holes of the polygon</p>
<p>m : optional #v list of markers for input vertices</p>
<p>flags : string of options pass to triangle (see triangle documentation) (default &lsquo;a0.005q&rsquo;)</p>
<hr />
<p><strong>Returns</strong></p>
<p>v2 : #v2 by 2 coordinates of the vertives of the generated triangulation</p>
<p>f2 : #f2 by 3 array of indices forming the faces of the generated triangulation</p>
<p>m2 : (only if you passed in m) #v2 list of markers for output vertices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>v2, f2 = triangulate(v, e, h)</p>
<p>igl.uniformly_sample_two_manifold_at_vertices = uniformly_sample_two_manifold_at_vertices(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object_1"><strong><code class="codehilite">uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object</code></strong><a class="headerlink" href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object_1" title="Permanent link">&para;</a></h3>
<p>Find uniform sampling up to placing samples on mesh vertices</p>
<p><strong>Parameters</strong></p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.uniformly_sample_two_manifold_at_vertices = uniformly_sample_two_manifold_at_vertices(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object_2"><strong><code class="codehilite">uniformly_sample_two_manifold_at_vertices(ow: array, k: int, push: float) -&gt; object</code></strong><a class="headerlink" href="#uniformly_sample_two_manifold_at_verticesow-array-k-int-push-float-object_2" title="Permanent link">&para;</a></h3>
<p>Find uniform sampling up to placing samples on mesh vertices</p>
<p><strong>Parameters</strong></p>
<hr />
<p><strong>Returns</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.uniformly_sample_two_manifold_internal = uniformly_sample_two_manifold_internal(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object_1"><strong><code class="codehilite">uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object</code></strong><a class="headerlink" href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object_1" title="Permanent link">&para;</a></h3>
<p>UNIFORMLY_SAMPLE_TWO_MANIFOLD Attempt to sample a mesh uniformly by</p>
<p>furthest point relaxation as described in &ldquo;Fast Automatic Skinning</p>
<p>Transformations&rdquo;</p>
<p>[Jacobson et al. 12] Section 3.3.</p>
<p><strong>Parameters</strong></p>
<p>W  #W by dim positions of mesh in weight space</p>
<p>F  #F by 3 indices of triangles</p>
<p>k  number of samplse</p>
<p>push  factor by which corners should be pushed away</p>
<hr />
<p><strong>Returns</strong></p>
<p>WS  k by dim locations in weights space</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.uniformly_sample_two_manifold_internal = uniformly_sample_two_manifold_internal(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object_2"><strong><code class="codehilite">uniformly_sample_two_manifold_internal(w: array, f: array, k: int, push: float) -&gt; object</code></strong><a class="headerlink" href="#uniformly_sample_two_manifold_internalw-array-f-array-k-int-push-float-object_2" title="Permanent link">&para;</a></h3>
<p>UNIFORMLY_SAMPLE_TWO_MANIFOLD Attempt to sample a mesh uniformly by</p>
<p>furthest point relaxation as described in &ldquo;Fast Automatic Skinning</p>
<p>Transformations&rdquo;</p>
<p>[Jacobson et al. 12] Section 3.3.</p>
<p><strong>Parameters</strong></p>
<p>W  #W by dim positions of mesh in weight space</p>
<p>F  #F by 3 indices of triangles</p>
<p>k  number of samplse</p>
<p>push  factor by which corners should be pushed away</p>
<hr />
<p><strong>Returns</strong></p>
<p>WS  k by dim locations in weights space</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.unproject = unproject(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="unprojectwin-array-model-array-proj-array-viewport-array-object_1"><strong><code class="codehilite">unproject(win: array, model: array, proj: array, viewport: array) -&gt; object</code></strong><a class="headerlink" href="#unprojectwin-array-model-array-proj-array-viewport-array-object_1" title="Permanent link">&para;</a></h3>
<p>Reimplementation of gluUnproject</p>
<p><strong>Parameters</strong></p>
<p>win  #P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates</p>
<p>model  4x4 model-view matrix</p>
<p>proj  4x4 projection matrix</p>
<p>viewport  4-long viewport vector</p>
<hr />
<p><strong>Returns</strong></p>
<p>scene  #P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.unproject = unproject(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="unprojectwin-array-model-array-proj-array-viewport-array-object_2"><strong><code class="codehilite">unproject(win: array, model: array, proj: array, viewport: array) -&gt; object</code></strong><a class="headerlink" href="#unprojectwin-array-model-array-proj-array-viewport-array-object_2" title="Permanent link">&para;</a></h3>
<p>Reimplementation of gluUnproject</p>
<p><strong>Parameters</strong></p>
<p>win  #P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates</p>
<p>model  4x4 model-view matrix</p>
<p>proj  4x4 projection matrix</p>
<p>viewport  4-long viewport vector</p>
<hr />
<p><strong>Returns</strong></p>
<p>scene  #P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.unproject_in_mesh = unproject_in_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit_1"><strong><code class="codehilite">unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]</code></strong><a class="headerlink" href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit_1" title="Permanent link">&para;</a></h3>
<p>Unproject a screen location (using current opengl viewport, projection, and</p>
<p>model view) to a 3D position <em>inside</em> a given mesh. If the ray through the</p>
<p>given screen location (x,y) <em>hits</em> the mesh more than twice then the 3D</p>
<p>midpoint between the first two hits is return. If it hits once, then that</p>
<p>point is return. If it does not hit the mesh then obj is not set.</p>
<p><strong>Parameters</strong></p>
<p>pos        screen space coordinates</p>
<p>model      model matrix</p>
<p>proj       projection matrix</p>
<p>viewport   vieweport vector</p>
<p>V   #V by 3 list of mesh vertex positions</p>
<p>F   #F by 3 list of mesh triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>obj        3d unprojected mouse point in mesh</p>
<p>hits       vector of hits</p>
<p><strong>Returns number of hits</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.unproject_in_mesh = unproject_in_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit_2"><strong><code class="codehilite">unproject_in_mesh(pos: numpy.ndarray[float32[2, 1]], model: numpy.ndarray[float32[4, 4]], proj: numpy.ndarray[float32[4, 4]], viewport: numpy.ndarray[float32[4, 1]], v: array, f: array) -&gt; Tuple[object, std::__1::vector&lt;igl::Hit, std::__1::allocator&lt;igl::Hit&gt; &gt;]</code></strong><a class="headerlink" href="#unproject_in_meshpos-numpyndarrayfloat322-1-model-numpyndarrayfloat324-4-proj-numpyndarrayfloat324-4-viewport-numpyndarrayfloat324-1-v-array-f-array-tupleobject-std__1vectoriglhit-std__1allocatoriglhit_2" title="Permanent link">&para;</a></h3>
<p>Unproject a screen location (using current opengl viewport, projection, and</p>
<p>model view) to a 3D position <em>inside</em> a given mesh. If the ray through the</p>
<p>given screen location (x,y) <em>hits</em> the mesh more than twice then the 3D</p>
<p>midpoint between the first two hits is return. If it hits once, then that</p>
<p>point is return. If it does not hit the mesh then obj is not set.</p>
<p><strong>Parameters</strong></p>
<p>pos        screen space coordinates</p>
<p>model      model matrix</p>
<p>proj       projection matrix</p>
<p>viewport   vieweport vector</p>
<p>V   #V by 3 list of mesh vertex positions</p>
<p>F   #F by 3 list of mesh triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>obj        3d unprojected mouse point in mesh</p>
<p>hits       vector of hits</p>
<p><strong>Returns number of hits</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.unproject_onto_mesh = unproject_onto_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object_1"><strong><code class="codehilite">unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]</code></strong><a class="headerlink" href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object_1" title="Permanent link">&para;</a></h3>
<p>Unproject a screen location (using current opengl viewport, projection, and</p>
<p>model view) to a 3D position <em>onto</em> a given mesh, if the ray through the</p>
<p>given screen location (x,y) <em>hits</em> the mesh.</p>
<p><strong>Parameters</strong></p>
<p>pos        screen space coordinates</p>
<p>model      model matrix</p>
<p>proj       projection matrix</p>
<p>viewport   vieweport vector</p>
<p>V   #V by 3 list of mesh vertex positions</p>
<p>F   #F by 3 list of mesh triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>fid  id of the first face hit</p>
<p>bc  barycentric coordinates of hit</p>
<p><strong>Returns true if there&rsquo;s a hit</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.unproject_onto_mesh = unproject_onto_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object_2"><strong><code class="codehilite">unproject_onto_mesh(pos: array, model: array, proj: array, viewport: array, v: array, f: array) -&gt; Tuple[bool, int, object]</code></strong><a class="headerlink" href="#unproject_onto_meshpos-array-model-array-proj-array-viewport-array-v-array-f-array-tuplebool-int-object_2" title="Permanent link">&para;</a></h3>
<p>Unproject a screen location (using current opengl viewport, projection, and</p>
<p>model view) to a 3D position <em>onto</em> a given mesh, if the ray through the</p>
<p>given screen location (x,y) <em>hits</em> the mesh.</p>
<p><strong>Parameters</strong></p>
<p>pos        screen space coordinates</p>
<p>model      model matrix</p>
<p>proj       projection matrix</p>
<p>viewport   vieweport vector</p>
<p>V   #V by 3 list of mesh vertex positions</p>
<p>F   #F by 3 list of mesh triangle indices into V</p>
<hr />
<p><strong>Returns</strong></p>
<p>fid  id of the first face hit</p>
<p>bc  barycentric coordinates of hit</p>
<p><strong>Returns true if there&rsquo;s a hit</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.unproject_ray = unproject_ray(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object_1"><strong><code class="codehilite">unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Construct a ray (source point + direction vector) given a screen space</p>
<p>positions (e.g. mouse) and a model-view projection constellation.</p>
<p><strong>Parameters</strong></p>
<p>pos  2d screen-space position (x,y)</p>
<p>model  4x4 model-view matrix</p>
<p>proj  4x4 projection matrix</p>
<p>viewport  4-long viewport vector</p>
<hr />
<p><strong>Returns</strong></p>
<p>s  source of ray (pos unprojected with z=0)</p>
<p>dir  direction of ray (d - s) where d is pos unprojected with z=1</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.unproject_ray = unproject_ray(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object_2"><strong><code class="codehilite">unproject_ray(pos: array, model: array, proj: array, viewport: array) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#unproject_raypos-array-model-array-proj-array-viewport-array-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Construct a ray (source point + direction vector) given a screen space</p>
<p>positions (e.g. mouse) and a model-view projection constellation.</p>
<p><strong>Parameters</strong></p>
<p>pos  2d screen-space position (x,y)</p>
<p>model  4x4 model-view matrix</p>
<p>proj  4x4 projection matrix</p>
<p>viewport  4-long viewport vector</p>
<hr />
<p><strong>Returns</strong></p>
<p>s  source of ray (pos unprojected with z=0)</p>
<p>dir  direction of ray (d - s) where d is pos unprojected with z=1</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.upsample = upsample(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object_1"><strong><code class="codehilite">upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Subdivide a mesh without moving vertices: loop subdivision but odd</p>
<p>vertices stay put and even vertices are just edge midpoints</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim  mesh vertices</p>
<p>F  #F by 3  mesh triangles</p>
<hr />
<p><strong>Returns</strong></p>
<p>NV new vertex positions, V is guaranteed to be at top</p>
<p>NF new list of face indices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<ul>
<li>assumes (V,F) is edge-manifold.</li>
</ul>
<p><strong>Examples</strong></p>
<p>igl.upsample = upsample(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object_2"><strong><code class="codehilite">upsample(v: array, f: array, number_of_subdivs: int = 1) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#upsamplev-array-f-array-number_of_subdivs-int-1-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Subdivide a mesh without moving vertices: loop subdivision but odd</p>
<p>vertices stay put and even vertices are just edge midpoints</p>
<p><strong>Parameters</strong></p>
<p>V  #V by dim  mesh vertices</p>
<p>F  #F by 3  mesh triangles</p>
<hr />
<p><strong>Returns</strong></p>
<p>NV new vertex positions, V is guaranteed to be at top</p>
<p>NF new list of face indices</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<ul>
<li>assumes (V,F) is edge-manifold.</li>
</ul>
<p><strong>Examples</strong></p>
<p>igl.vector_area_matrix = vector_area_matrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="vector_area_matrixf-array-object_1"><strong><code class="codehilite">vector_area_matrix(f: array) -&gt; object</code></strong><a class="headerlink" href="#vector_area_matrixf-array-object_1" title="Permanent link">&para;</a></h3>
<p>Constructs the symmetric area matrix A, s.t. [V.col(0)&rsquo; V.col(1)&rsquo;] * A *</p>
<p>[V.col(0); V.col(1)] is the <strong>vector area</strong> of the mesh (V,F).</p>
<p><strong>Parameters</strong></p>
<p>f : #f by 3 array of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p>a : #vx2 by #vx2 area matrix</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.vector_area_matrix = vector_area_matrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="vector_area_matrixf-array-object_2"><strong><code class="codehilite">vector_area_matrix(f: array) -&gt; object</code></strong><a class="headerlink" href="#vector_area_matrixf-array-object_2" title="Permanent link">&para;</a></h3>
<p>Constructs the symmetric area matrix A, s.t. [V.col(0)&rsquo; V.col(1)&rsquo;] * A *</p>
<p>[V.col(0); V.col(1)] is the <strong>vector area</strong> of the mesh (V,F).</p>
<p><strong>Parameters</strong></p>
<p>f : #f by 3 array of mesh faces (must be triangles)</p>
<hr />
<p><strong>Returns</strong></p>
<p>a : #vx2 by #vx2 area matrix</p>
<hr />
<p><strong>See also</strong></p>
<p>None</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.vertex_components = vertex_components(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="vertex_componentsf-array-object_1"><strong><code class="codehilite">vertex_components(f: array) -&gt; object</code></strong><a class="headerlink" href="#vertex_componentsf-array-object_1" title="Permanent link">&para;</a></h3>
<p>Compute connected components of the vertices of a mesh given the mesh&rsquo; face indices.</p>
<p><strong>Parameters</strong></p>
<p>f : #f x dim array of face indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>An array of component ids (starting with 0)</p>
<hr />
<p><strong>See also</strong></p>
<p>vertex_components_from_adjacency_matrix</p>
<p>face_components_from_faces</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.vertex_components = vertex_components(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="vertex_componentsf-array-object_2"><strong><code class="codehilite">vertex_components(f: array) -&gt; object</code></strong><a class="headerlink" href="#vertex_componentsf-array-object_2" title="Permanent link">&para;</a></h3>
<p>Compute connected components of the vertices of a mesh given the mesh&rsquo; face indices.</p>
<p><strong>Parameters</strong></p>
<p>f : #f x dim array of face indices</p>
<hr />
<p><strong>Returns</strong></p>
<p>An array of component ids (starting with 0)</p>
<hr />
<p><strong>See also</strong></p>
<p>vertex_components_from_adjacency_matrix</p>
<p>face_components_from_faces</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.vertex_components_from_adjacency_matrix = vertex_components_from_adjacency_matrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object_1"><strong><code class="codehilite">vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>Compute connected components of a graph represented by a sparse adjacency</p>
<p>matrix.</p>
<p><strong>Parameters</strong></p>
<p>a : n by n sparse adjacency matrix</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple (c, counts) where c is an array of component ids (starting with 0)</p>
<p>and counts is a #components array of counts for each component</p>
<hr />
<p><strong>See also</strong></p>
<p>vertex_components</p>
<p>face_components</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.vertex_components_from_adjacency_matrix = vertex_components_from_adjacency_matrix(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object_2"><strong><code class="codehilite">vertex_components_from_adjacency_matrix(a: scipy.sparse.csr_matrix  scipy.sparse.csc_matrix) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#vertex_components_from_adjacency_matrixa-scipysparsecsr_matrix-scipysparsecsc_matrix-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>Compute connected components of a graph represented by a sparse adjacency</p>
<p>matrix.</p>
<p><strong>Parameters</strong></p>
<p>a : n by n sparse adjacency matrix</p>
<hr />
<p><strong>Returns</strong></p>
<p>A tuple (c, counts) where c is an array of component ids (starting with 0)</p>
<p>and counts is a #components array of counts for each component</p>
<hr />
<p><strong>See also</strong></p>
<p>vertex_components</p>
<p>face_components</p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.vertex_triangle_adjacency = vertex_triangle_adjacency(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="vertex_triangle_adjacencyf-array-n-int-tupleobject-object_1"><strong><code class="codehilite">vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#vertex_triangle_adjacencyf-array-n-int-tupleobject-object_1" title="Permanent link">&para;</a></h3>
<p>vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of triangle indices into some vertex list V</p>
<p>n  number of vertices, #V (e.g., F.maxCoeff()+1)</p>
<hr />
<p><strong>Returns</strong></p>
<p>VF  3*#F list  List of faces indice on each vertex, so that VF(NI(i)+j) =</p>
<p>f, means that face f is the jth face (in no particular order) incident</p>
<p>on vertex i.</p>
<p>NI  #V+1 list  cumulative sum of vertex-triangle degrees with a</p>
<p>preceeding zero. &ldquo;How many faces&rdquo; have been seen before visiting this</p>
<p>vertex and its incident faces.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.vertex_triangle_adjacency = vertex_triangle_adjacency(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="vertex_triangle_adjacencyf-array-n-int-tupleobject-object_2"><strong><code class="codehilite">vertex_triangle_adjacency(f: array, n: int) -&gt; Tuple[object, object]</code></strong><a class="headerlink" href="#vertex_triangle_adjacencyf-array-n-int-tupleobject-object_2" title="Permanent link">&para;</a></h3>
<p>vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F)</p>
<p><strong>Parameters</strong></p>
<p>F  #F by 3 list of triangle indices into some vertex list V</p>
<p>n  number of vertices, #V (e.g., F.maxCoeff()+1)</p>
<hr />
<p><strong>Returns</strong></p>
<p>VF  3*#F list  List of faces indice on each vertex, so that VF(NI(i)+j) =</p>
<p>f, means that face f is the jth face (in no particular order) incident</p>
<p>on vertex i.</p>
<p>NI  #V+1 list  cumulative sum of vertex-triangle degrees with a</p>
<p>preceeding zero. &ldquo;How many faces&rdquo; have been seen before visiting this</p>
<p>vertex and its incident faces.</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.winding_number = winding_number(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="winding_numberv-array-f-array-o-array-object_1"><strong><code class="codehilite">winding_number(v: array, f: array, o: array) -&gt; object</code></strong><a class="headerlink" href="#winding_numberv-array-f-array-o-array-object_1" title="Permanent link">&para;</a></h3>
<p>WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron</p>
<p>described by points (vectors) V</p>
<p><strong>Parameters</strong></p>
<p>V  n by 3 list of vertex positions</p>
<p>F  #F by 3 list of triangle indices, minimum index is 0</p>
<p>O  no by 3 list of origin positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  no by 1 list of winding numbers</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.winding_number = winding_number(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="winding_numberv-array-f-array-o-array-object_2"><strong><code class="codehilite">winding_number(v: array, f: array, o: array) -&gt; object</code></strong><a class="headerlink" href="#winding_numberv-array-f-array-o-array-object_2" title="Permanent link">&para;</a></h3>
<p>WINDING_NUMBER Compute the sum of solid angles of a triangle/tetrahedron</p>
<p>described by points (vectors) V</p>
<p><strong>Parameters</strong></p>
<p>V  n by 3 list of vertex positions</p>
<p>F  #F by 3 list of triangle indices, minimum index is 0</p>
<p>O  no by 3 list of origin positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>S  no by 1 list of winding numbers</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.winding_number_for_point = winding_number_for_point(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="winding_number_for_pointv-array-f-array-p-array-float_1"><strong><code class="codehilite">winding_number_for_point(v: array, f: array, p: array) -&gt; float</code></strong><a class="headerlink" href="#winding_number_for_pointv-array-f-array-p-array-float_1" title="Permanent link">&para;</a></h3>
<p>Compute winding number of a single point</p>
<p><strong>Parameters</strong></p>
<p>V  n by dim list of vertex positions</p>
<p>F  #F by dim list of triangle indices, minimum index is 0</p>
<p>p  single origin position</p>
<hr />
<p><strong>Returns</strong></p>
<p>w  winding number of this point</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.winding_number_for_point = winding_number_for_point(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="winding_number_for_pointv-array-f-array-p-array-float_2"><strong><code class="codehilite">winding_number_for_point(v: array, f: array, p: array) -&gt; float</code></strong><a class="headerlink" href="#winding_number_for_pointv-array-f-array-p-array-float_2" title="Permanent link">&para;</a></h3>
<p>Compute winding number of a single point</p>
<p><strong>Parameters</strong></p>
<p>V  n by dim list of vertex positions</p>
<p>F  #F by dim list of triangle indices, minimum index is 0</p>
<p>p  single origin position</p>
<hr />
<p><strong>Returns</strong></p>
<p>w  winding number of this point</p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.write_obj = write_obj(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="write_objfilename-str-v-array-f-array-bool_1"><strong><code class="codehilite">write_obj(filename: str, v: array, f: array) -&gt; bool</code></strong><a class="headerlink" href="#write_objfilename-str-v-array-f-array-bool_1" title="Permanent link">&para;</a></h3>
<p>Write a mesh in an ascii obj file.</p>
<p><strong>Parameters</strong></p>
<p>filename : path to outputfile</p>
<p>v : array of vertex positions #v by 3</p>
<p>f : #f list of face indices into vertex positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>ret : bool if output was successful</p>
<hr />
<p><strong>See also</strong></p>
<p>read_obj</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>success = write_obj(v, f)</p>
<p>igl.write_obj = write_obj(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="write_objfilename-str-v-array-f-array-bool_2"><strong><code class="codehilite">write_obj(filename: str, v: array, f: array) -&gt; bool</code></strong><a class="headerlink" href="#write_objfilename-str-v-array-f-array-bool_2" title="Permanent link">&para;</a></h3>
<p>Write a mesh in an ascii obj file.</p>
<p><strong>Parameters</strong></p>
<p>filename : path to outputfile</p>
<p>v : array of vertex positions #v by 3</p>
<p>f : #f list of face indices into vertex positions</p>
<hr />
<p><strong>Returns</strong></p>
<p>ret : bool if output was successful</p>
<hr />
<p><strong>See also</strong></p>
<p>read_obj</p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>Mesh in (v, f)</p>
<p>success = write_obj(v, f)</p>
<p>igl.write_off = write_off(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="write_offstr-str-v-array-f-array-c-array-bool_1"><strong><code class="codehilite">write_off(str: str, v: array, f: array, c: array) -&gt; bool</code></strong><a class="headerlink" href="#write_offstr-str-v-array-f-array-c-array-bool_1" title="Permanent link">&para;</a></h3>
<p>Export geometry and colors-by-vertex</p>
<p>Export a mesh from an ascii OFF file, filling in vertex positions.</p>
<p>Only triangle meshes are supported</p>
<p><strong>Parameters</strong></p>
<p>str  path to .off output file</p>
<p>V  #V by 3 mesh vertex positions</p>
<p>F  #F by 3 mesh indices into V</p>
<p>C  double matrix of rgb values per vertex #V by 3</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns true on success, false on errors</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.write_off = write_off(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="write_offstr-str-v-array-f-array-c-array-bool_2"><strong><code class="codehilite">write_off(str: str, v: array, f: array, c: array) -&gt; bool</code></strong><a class="headerlink" href="#write_offstr-str-v-array-f-array-c-array-bool_2" title="Permanent link">&para;</a></h3>
<p>Export geometry and colors-by-vertex</p>
<p>Export a mesh from an ascii OFF file, filling in vertex positions.</p>
<p>Only triangle meshes are supported</p>
<p><strong>Parameters</strong></p>
<p>str  path to .off output file</p>
<p>V  #V by 3 mesh vertex positions</p>
<p>F  #F by 3 mesh indices into V</p>
<p>C  double matrix of rgb values per vertex #V by 3</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns true on success, false on errors</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p>None</p>
<p><strong>Examples</strong></p>
<p>igl.write_triangle_mesh = write_triangle_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool_1"><strong><code class="codehilite">write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool</code></strong><a class="headerlink" href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool_1" title="Permanent link">&para;</a></h3>
<p>write mesh to a file with automatic detection of file format.  supported: obj, off, stl, wrl, ply, mesh).</p>
<p><strong>Parameters</strong></p>
<p>str  path to file</p>
<p>V  eigen double matrix #V by 3</p>
<p>F  eigen int matrix #F by 3</p>
<p>force_ascii=True  force ascii format even if binary is available</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns true iff success</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>igl.write_triangle_mesh = write_triangle_mesh(&hellip;) method of builtins.PyCapsule instance</p>
<hr />
<h3 id="write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool_2"><strong><code class="codehilite">write_triangle_mesh(str: str, v: array, f: array, force_ascii: bool = True) -&gt; bool</code></strong><a class="headerlink" href="#write_triangle_meshstr-str-v-array-f-array-force_ascii-bool-true-bool_2" title="Permanent link">&para;</a></h3>
<p>write mesh to a file with automatic detection of file format.  supported: obj, off, stl, wrl, ply, mesh).</p>
<p><strong>Parameters</strong></p>
<p>str  path to file</p>
<p>V  eigen double matrix #V by 3</p>
<p>F  eigen int matrix #F by 3</p>
<p>force_ascii=True  force ascii format even if binary is available</p>
<hr />
<p><strong>Returns</strong></p>
<p><strong>Returns true iff success</strong></p>
<hr />
<p><strong>See also</strong></p>
<hr />
<p><strong>Notes</strong></p>
<p><strong>Examples</strong></p>
<p>class ARAP</p>
<hr />
<h3 id="solve-iglpyigl_classesarap-arg0-numpyndarray-arg1-numpyndarray-object"><strong><code class="codehilite">solve(: igl.pyigl_classes.ARAP, arg0: numpy.ndarray, arg1: numpy.ndarray) -&gt; object</code></strong><a class="headerlink" href="#solve-iglpyigl_classesarap-arg0-numpyndarray-arg1-numpyndarray-object" title="Permanent link">&para;</a></h3>
<p>class BBW</p>
<hr />
<h3 id="solve-iglpyigl_classesbbw-arg0-numpyndarray-arg1-numpyndarray-arg2-numpyndarrayint32m-1-arg3-numpyndarray-object"><strong><code class="codehilite">solve(: igl.pyigl_classes.BBW, arg0: numpy.ndarray, arg1: numpy.ndarray, arg2: numpy.ndarray[int32[m, 1]], arg3: numpy.ndarray) -&gt; object</code></strong><a class="headerlink" href="#solve-iglpyigl_classesbbw-arg0-numpyndarray-arg1-numpyndarray-arg2-numpyndarrayint32m-1-arg3-numpyndarray-object" title="Permanent link">&para;</a></h3>
<p>class SLIM</p>
<hr />
<h3 id="energy-iglpyigl_classesslim-float"><strong><code class="codehilite">energy(: igl.pyigl_classes.SLIM) -&gt; float</code></strong><a class="headerlink" href="#energy-iglpyigl_classesslim-float" title="Permanent link">&para;</a></h3>
<hr />
<h3 id="solve-iglpyigl_classesslim-arg0-int"><strong><code class="codehilite">solve(: igl.pyigl_classes.SLIM, arg0: int)</code></strong><a class="headerlink" href="#solve-iglpyigl_classesslim-arg0-int" title="Permanent link">&para;</a></h3>
<hr />
<h3 id="vertices-iglpyigl_classesslim-object"><strong><code class="codehilite">vertices(: igl.pyigl_classes.SLIM) -&gt; object</code></strong><a class="headerlink" href="#vertices-iglpyigl_classesslim-object" title="Permanent link">&para;</a></h3>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../tutorials.ipynb" title="Tutorial" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Tutorial
              </span>
            </div>
          </a>
        
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
  <div class="md-footer-social">
    <link rel="stylesheet" href="../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/geometryprocessing/libigl-python-bindings" class="md-footer-social__link fa fa-github"></a>
    
  </div>

      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.9e1f3b71.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
    
      
    
  </body>
</html>