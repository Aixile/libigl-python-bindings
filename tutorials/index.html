



<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="Simple Python geometry processing library">
      
      
        <link rel="canonical" href="https://libigl.github.io/tutorials/">
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../favicon.ico">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-3.1.0">
    
    
      
        <title>Tutorial - igl</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.11e41852.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.22915126.css">
      
      
        
        
        <meta name="theme-color" content="#03a9f4">
      
    
    
      <script src="../assets/javascripts/modernizr.20ef595d.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="light-blue" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448"
    viewBox="0 0 416 448" id="__github">
  <path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19-18.125
        8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19 18.125-8.5
        18.125 8.5 10.75 19 3.125 20.5zM320 304q0 10-3.125 20.5t-10.75
        19-18.125 8.5-18.125-8.5-10.75-19-3.125-20.5 3.125-20.5 10.75-19
        18.125-8.5 18.125 8.5 10.75 19 3.125 20.5zM360
        304q0-30-17.25-51t-46.75-21q-10.25 0-48.75 5.25-17.75 2.75-39.25
        2.75t-39.25-2.75q-38-5.25-48.75-5.25-29.5 0-46.75 21t-17.25 51q0 22 8
        38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0
        37.25-1.75t35-7.375 30.5-15 20.25-25.75 8-38.375zM416 260q0 51.75-15.25
        82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5-41.75
        1.125q-19.5 0-35.5-0.75t-36.875-3.125-38.125-7.5-34.25-12.875-30.25-20.25-21.5-28.75q-15.5-30.75-15.5-82.75
        0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25
        30.875q36.75-8.75 77.25-8.75 37 0 70 8 26.25-20.5
        46.75-30.25t47.25-9.75q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34
        99.5z" />
</svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#libigl-tutorials" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://libigl.github.io/" title="igl" class="md-header-nav__button md-logo">
          
            <i class="md-icon"> </i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                igl
              </span>
              <span class="md-header-nav__topic">
                Tutorial
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/geometryprocessing/libigl-python-bindings/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#__github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      libigl-python-bindings
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://libigl.github.io/" title="igl" class="md-nav__button md-logo">
      
        <i class="md-icon"> </i>
      
    </a>
    igl
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/geometryprocessing/libigl-python-bindings/" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#__github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      libigl-python-bindings
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Tutorial
      </label>
    
    <a href="./" title="Tutorial" class="md-nav__link md-nav__link--active">
      Tutorial
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#libigl-tutorials" title="Libigl Tutorials" class="md-nav__link">
    Libigl Tutorials
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-0" title="Chapter 0" class="md-nav__link">
    Chapter 0
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#libigl-design-principles" title="Libigl design principles" class="md-nav__link">
    Libigl design principles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#downloading-libigl" title="Downloading Libigl" class="md-nav__link">
    Downloading Libigl
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mesh-representation" title="Mesh representation" class="md-nav__link">
    Mesh representation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-1-discrete-geometric-quantities-and-operators" title="Chapter 1: Discrete Geometric Quantities and Operators" class="md-nav__link">
    Chapter 1: Discrete Geometric Quantities and Operators
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gaussian-curvature" title="Gaussian curvature" class="md-nav__link">
    Gaussian curvature
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#curvature-directions" title="Curvature directions" class="md-nav__link">
    Curvature directions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gradient" title="Gradient" class="md-nav__link">
    Gradient
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#laplacian" title="Laplacian" class="md-nav__link">
    Laplacian
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mass-matrix" title="Mass matrix" class="md-nav__link">
    Mass matrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative-construction-of-laplacian" title="Alternative construction of Laplacian" class="md-nav__link">
    Alternative construction of Laplacian
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exact-discrete-geodesic-distances" title="Exact Discrete Geodesic Distances" class="md-nav__link">
    Exact Discrete Geodesic Distances
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-2-matrices-and-linear-algebra" title="Chapter 2: Matrices and Linear Algebra" class="md-nav__link">
    Chapter 2: Matrices and Linear Algebra
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#laplace-equation" title="Laplace equation" class="md-nav__link">
    Laplace equation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quadratic-energy-minimization" title="Quadratic energy minimization" class="md-nav__link">
    Quadratic energy minimization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linear-equality-constraints" title="Linear equality constraints" class="md-nav__link">
    Linear equality constraints
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigen-decomposition" title="Eigen Decomposition" class="md-nav__link">
    Eigen Decomposition
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-3-shape-deformation" title="Chapter 3: Shape deformation" class="md-nav__link">
    Chapter 3: Shape deformation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#biharmonic-deformation" title="Biharmonic deformation" class="md-nav__link">
    Biharmonic deformation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#biharmonic-surfaces" title="Biharmonic surfaces" class="md-nav__link">
    Biharmonic surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#biharmonic-deformation-fields" title="Biharmonic deformation fields" class="md-nav__link">
    Biharmonic deformation fields
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relationship-to-differential-coordinates-and-laplacian-surface-editing" title="Relationship to "differential coordinates" and Laplacian surface editing" class="md-nav__link">
    Relationship to "differential coordinates" and Laplacian surface editing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polyharmonic-deformation" title="Polyharmonic deformation" class="md-nav__link">
    Polyharmonic deformation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-4-parametrization" title="Chapter 4: Parametrization" class="md-nav__link">
    Chapter 4: Parametrization
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#harmonic-parametrization" title="Harmonic parametrization" class="md-nav__link">
    Harmonic parametrization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#least-squares-conformal-maps" title="Least squares conformal maps" class="md-nav__link">
    Least squares conformal maps
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-5-external-libraries" title="Chapter 5: External libraries" class="md-nav__link">
    Chapter 5: External libraries
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#triangulation-of-closed-polygons" title="Triangulation of closed polygons" class="md-nav__link">
    Triangulation of closed polygons
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tetrahedralization-of-closed-surfaces" title="Tetrahedralization of closed surfaces" class="md-nav__link">
    Tetrahedralization of closed surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#baking-ambient-occlusion" title="Baking ambient occlusion" class="md-nav__link">
    Baking ambient occlusion
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-6-miscellaneous" title="Chapter 6: Miscellaneous" class="md-nav__link">
    Chapter 6: Miscellaneous
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mesh-statistics" title="Mesh Statistics" class="md-nav__link">
    Mesh Statistics
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" title="References" class="md-nav__link">
    References
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../igl_docs/" title="Docs" class="md-nav__link">
      Docs
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#libigl-tutorials" title="Libigl Tutorials" class="md-nav__link">
    Libigl Tutorials
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-0" title="Chapter 0" class="md-nav__link">
    Chapter 0
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#libigl-design-principles" title="Libigl design principles" class="md-nav__link">
    Libigl design principles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#downloading-libigl" title="Downloading Libigl" class="md-nav__link">
    Downloading Libigl
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mesh-representation" title="Mesh representation" class="md-nav__link">
    Mesh representation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-1-discrete-geometric-quantities-and-operators" title="Chapter 1: Discrete Geometric Quantities and Operators" class="md-nav__link">
    Chapter 1: Discrete Geometric Quantities and Operators
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gaussian-curvature" title="Gaussian curvature" class="md-nav__link">
    Gaussian curvature
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#curvature-directions" title="Curvature directions" class="md-nav__link">
    Curvature directions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gradient" title="Gradient" class="md-nav__link">
    Gradient
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#laplacian" title="Laplacian" class="md-nav__link">
    Laplacian
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mass-matrix" title="Mass matrix" class="md-nav__link">
    Mass matrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative-construction-of-laplacian" title="Alternative construction of Laplacian" class="md-nav__link">
    Alternative construction of Laplacian
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exact-discrete-geodesic-distances" title="Exact Discrete Geodesic Distances" class="md-nav__link">
    Exact Discrete Geodesic Distances
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-2-matrices-and-linear-algebra" title="Chapter 2: Matrices and Linear Algebra" class="md-nav__link">
    Chapter 2: Matrices and Linear Algebra
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#laplace-equation" title="Laplace equation" class="md-nav__link">
    Laplace equation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quadratic-energy-minimization" title="Quadratic energy minimization" class="md-nav__link">
    Quadratic energy minimization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linear-equality-constraints" title="Linear equality constraints" class="md-nav__link">
    Linear equality constraints
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigen-decomposition" title="Eigen Decomposition" class="md-nav__link">
    Eigen Decomposition
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-3-shape-deformation" title="Chapter 3: Shape deformation" class="md-nav__link">
    Chapter 3: Shape deformation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#biharmonic-deformation" title="Biharmonic deformation" class="md-nav__link">
    Biharmonic deformation
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#biharmonic-surfaces" title="Biharmonic surfaces" class="md-nav__link">
    Biharmonic surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#biharmonic-deformation-fields" title="Biharmonic deformation fields" class="md-nav__link">
    Biharmonic deformation fields
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relationship-to-differential-coordinates-and-laplacian-surface-editing" title="Relationship to "differential coordinates" and Laplacian surface editing" class="md-nav__link">
    Relationship to "differential coordinates" and Laplacian surface editing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polyharmonic-deformation" title="Polyharmonic deformation" class="md-nav__link">
    Polyharmonic deformation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-4-parametrization" title="Chapter 4: Parametrization" class="md-nav__link">
    Chapter 4: Parametrization
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#harmonic-parametrization" title="Harmonic parametrization" class="md-nav__link">
    Harmonic parametrization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#least-squares-conformal-maps" title="Least squares conformal maps" class="md-nav__link">
    Least squares conformal maps
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-5-external-libraries" title="Chapter 5: External libraries" class="md-nav__link">
    Chapter 5: External libraries
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#triangulation-of-closed-polygons" title="Triangulation of closed polygons" class="md-nav__link">
    Triangulation of closed polygons
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tetrahedralization-of-closed-surfaces" title="Tetrahedralization of closed surfaces" class="md-nav__link">
    Tetrahedralization of closed surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#baking-ambient-occlusion" title="Baking ambient occlusion" class="md-nav__link">
    Baking ambient occlusion
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-6-miscellaneous" title="Chapter 6: Miscellaneous" class="md-nav__link">
    Chapter 6: Miscellaneous
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mesh-statistics" title="Mesh Statistics" class="md-nav__link">
    Mesh Statistics
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" title="References" class="md-nav__link">
    References
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/geometryprocessing/libigl-python-bindings/edit/master/docs/tutorials.ipynb" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                  <h1>Tutorial</h1>
                
                <h2 id="libigl-tutorials">Libigl Tutorials<a class="headerlink" href="#libigl-tutorials" title="Permanent link">&para;</a></h2>
<p><a href="https://conda.anaconda.org/conda-forge"><img alt="Anaconda-Server Badge" src="https://anaconda.org/conda-forge/igl/badges/installer/conda.svg" /></a></p>
<p><a href="https://anaconda.org/conda-forge/igl"><img alt="Anaconda-Server Badge" src="https://anaconda.org/conda-forge/igl/badges/downloads.svg" /></a></p>
<p><a href="https://anaconda.org/conda-forge/igl"><img alt="Anaconda-Server Badge" src="https://anaconda.org/conda-forge/igl/badges/platforms.svg" /></a></p>
<p><a href="https://anaconda.org/conda-forge/igl"><img alt="Anaconda-Server Badge" src="https://anaconda.org/conda-forge/igl/badges/latest_release_date.svg" /></a></p>
<p><img alt="" src="../images/libigl-logo.jpg" /></p>
<p>Libigl is an open source C++ library for geometry processing research and development. The python bindings combine the rapid prototyping familiar to Matlab to Python programmers with the performance and versatility of C++. The tutorial is a self-contained, hands-on introduction to libigl in Python.  Via interactive, step-by-step examples, we demonstrate how to accomplish common geometry processing tasks such as computation of differential quantities and operators, real-time deformation, parametrization, numerical optimization and remeshing. Each section of the lecture notes contains a simple Python example application.</p>
<h2 id="chapter-0">Chapter 0<a class="headerlink" href="#chapter-0" title="Permanent link">&para;</a></h2>
<p>We introduce libigl with a series of self-contained examples. The purpose of
each example is to showcase a feature of libigl while applying to a practical
problem in geometry processing. In this chapter, we will present the basic
concepts of libigl.</p>
<h3 id="libigl-design-principles">Libigl design principles<a class="headerlink" href="#libigl-design-principles" title="Permanent link">&para;</a></h3>
<p>Before getting into the examples, we summarize the two main design principles in
libigl:</p>
<ol>
<li>
<p><strong>No complex data types.</strong> We mostly use <code class="codehilite">numpy</code> or <code class="codehilite">scipy</code> matrices and vectors. This greatly
  favors code reusability and interoperability and forces the function authors to expose all the
  parameters used by the algorithm.</p>
</li>
<li>
<p><strong>Function encapsulation.</strong> Every function is contained in a unique Python function.</p>
</li>
</ol>
<h3 id="downloading-libigl">Downloading Libigl<a class="headerlink" href="#downloading-libigl" title="Permanent link">&para;</a></h3>
<p>Libigl can be downloaded from <a href="https://anaconda.org/conda-forge/igl">Conda forge</a>:
<div class="codehilite"><pre><span></span>conda install -c conda-forge igl 
</pre></div></p>
<p>All of libigl functionality depends only on <code class="codehilite">numpy</code> and <code class="codehilite">scipy</code>. For the visualization in this tutorial we use <a href="https://anaconda.org/conda-forge/meshplot">meshplot</a> which can be easily installed from Conda:
<div class="codehilite"><pre><span></span>conda install -c conda-forge meshplot 
</pre></div></p>
<p>To start using libigl (with the plots) you just need to import it together with the <code class="codehilite">numpy</code>, <code class="codehilite">scipy</code>, and <code class="codehilite">meshplot</code>.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">igl</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">meshplot</span> <span class="kn">import</span> <span class="n">plot</span><span class="p">,</span> <span class="n">subplot</span><span class="p">,</span> <span class="n">interact</span>
</pre></div>

<h3 id="mesh-representation">Mesh representation<a class="headerlink" href="#mesh-representation" title="Permanent link">&para;</a></h3>
<p>Libigl uses <code class="codehilite">numpy</code> to encode vectors and matrices and <code class="codehilite">scipy</code> for sparse matrices.</p>
<p>A triangular mesh is encoded as a pair of matrices:</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>
<span class="n">f</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>
</pre></div>

<p><code class="codehilite">v</code> is a #N by 3 matrix which stores the coordinates of the vertices. Each
row stores the coordinate of a vertex, with its x, y and z coordinates in the first,
second and third column, respectively. The matrix <code class="codehilite">f</code> stores the triangle
connectivity: each line of <code class="codehilite">f</code> denotes a triangle whose 3 vertices are
represented as indices pointing to rows of <code class="codehilite">f</code>.</p>
<p><img alt="A simple mesh made of 2 triangles and 4 vertices." src="../images/VF.png" /></p>
<div class="codehilite"><pre><span></span><span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">])</span>

<span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">])</span>

<span class="n">plot</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(1.0, 0.5,…
</pre></div>


<p>Note that the order of the vertex indices in <code class="codehilite">f</code> determines the orientation of
the triangles and it should thus be consistent for the entire surface.
This simple representation has many advantages:</p>
<ol>
<li>It is memory efficient and cache friendly</li>
<li>The use of indices instead of pointers greatly simplifies debugging</li>
<li>The data can be trivially copied and serialized</li>
</ol>
<p>Libigl provides input and output functions to read and write many common mesh formats.
The IO functions are igl.read_* and igl.write_*.</p>
<p>Reading a mesh from a file requires a single libigl function call:</p>
<div class="codehilite"><pre><span></span><span class="c1">## Load a mesh in OFF format</span>
<span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/bunny.off&quot;</span><span class="p">)</span>

<span class="c1">## Print the vertices and faces matrices </span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Vertices: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Faces: &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
</pre></div>

<div class="codehilite"><pre><span></span><span class="n">Vertices</span><span class="o">:</span>  <span class="mi">3485</span>
<span class="n">Faces</span><span class="o">:</span>  <span class="mi">6966</span>
</pre></div>


<p>The function reads the mesh bumpy.off and returns the <code class="codehilite">v</code> and <code class="codehilite">f</code> matrices.
Similarly, a mesh can be written to an OBJ file using:</p>
<div class="codehilite"><pre><span></span><span class="c1">## Save the mesh in OBJ format</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">write_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/bunny.obj&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>

<h2 id="chapter-1-discrete-geometric-quantities-and-operators">Chapter 1: Discrete Geometric Quantities and Operators<a class="headerlink" href="#chapter-1-discrete-geometric-quantities-and-operators" title="Permanent link">&para;</a></h2>
<p>This chapter illustrates a few discrete quantities that libigl can compute on a mesh and the libigl functions that construct popular discrete differential geometry operators. It also provides an introduction to basic drawing and coloring routines of our viewer.</p>
<h3 id="gaussian-curvature">Gaussian curvature<a class="headerlink" href="#gaussian-curvature" title="Permanent link">&para;</a></h3>
<p>Gaussian curvature on a continuous surface is defined as the product of the
principal curvatures:</p>
<p><span><span class="MathJax_Preview">k_G = k_1 k_2.</span><script type="math/tex">k_G = k_1 k_2.</script></span></p>
<p>As an <em>intrinsic</em> measure, it depends on the metric and
not the surface&rsquo;s embedding.</p>
<p>Intuitively, Gaussian curvature tells how locally spherical or <em>elliptic</em> the
surface is ( <span><span class="MathJax_Preview">k_G&gt;0</span><script type="math/tex">k_G>0</script></span> ), how locally saddle-shaped or <em>hyperbolic</em> the surface
is ( <span><span class="MathJax_Preview">k_G&lt;0</span><script type="math/tex">k_G<0</script></span> ), or how locally cylindrical or <em>parabolic</em> ( <span><span class="MathJax_Preview">k_G=0</span><script type="math/tex">k_G=0</script></span> ) the
surface is.</p>
<p>In the discrete setting, one definition for a &ldquo;discrete Gaussian curvature&rdquo;
on a triangle mesh is via a vertex&rsquo;s <em>angular deficit</em>:</p>
<p><span><span class="MathJax_Preview">k_G(v_i) = 2π - \sum\limits_{j\in N(i)}θ_{ij},</span><script type="math/tex">k_G(v_i) = 2π - \sum\limits_{j\in N(i)}θ_{ij},</script></span></p>
<p>where <span><span class="MathJax_Preview">N(i)</span><script type="math/tex">N(i)</script></span> are the triangles incident on vertex <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> and <span><span class="MathJax_Preview">θ_{ij}</span><script type="math/tex">θ_{ij}</script></span> is the angle
at vertex <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> in triangle <span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> <cite data-cite="meyer2003">(Meyer, 2003)</cite>.</p>
<p>Just like the continuous analog, our discrete Gaussian curvature reveals
elliptic, hyperbolic and parabolic vertices on the domain.</p>
<p>Let&rsquo;s compute Gaussian curvature and visualize it in pseudocolor. First, calculate the curvature with libigl and then plot it in pseudocolors.</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/bumpy.off&quot;</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">gaussian_curvature</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(0.0, 0.0,…
</pre></div>


<p>Next, compute the massmatrix and divide the gaussian curvature values by area to get the integral average.</p>
<div class="codehilite"><pre><span></span><span class="n">m</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">igl</span><span class="o">.</span><span class="n">MASSMATRIX_TYPE_VORONOI</span><span class="p">)</span>
<span class="n">minv</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">m</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>
<span class="n">kn</span> <span class="o">=</span> <span class="n">minv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">kn</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(0.0, 0.0,…
</pre></div>


<h3 id="curvature-directions">Curvature directions<a class="headerlink" href="#curvature-directions" title="Permanent link">&para;</a></h3>
<p>The two principal curvatures <span><span class="MathJax_Preview">(k_1,k_2)</span><script type="math/tex">(k_1,k_2)</script></span> at a point on a surface measure how
much the surface bends in different directions. The directions of maximum and
minimum (signed) bending are called principal directions and are always
orthogonal.</p>
<p>Mean curvature is defined as the average of principal curvatures:</p>
<p><span><span class="MathJax_Preview">H = \frac{1}{2}(k_1 + k_2).</span><script type="math/tex">H = \frac{1}{2}(k_1 + k_2).</script></span></p>
<p>One way to extract mean curvature is by examining the Laplace-Beltrami operator
applied to the surface positions. The result is a so-called mean-curvature
normal:</p>
<p><span><span class="MathJax_Preview">-\Delta \mathbf{x} = H \mathbf{n}.</span><script type="math/tex">-\Delta \mathbf{x} = H \mathbf{n}.</script></span></p>
<p>It is easy to compute this on a discrete triangle mesh in libigl using the
cotangent Laplace-Beltrami operator <cite data-cite="meyer2003">(Meyer, 2003)</cite>. </p>
<div class="codehilite"><pre><span></span><span class="n">l</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">igl</span><span class="o">.</span><span class="n">MASSMATRIX_TYPE_VORONOI</span><span class="p">)</span>

<span class="n">minv</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">m</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>

<span class="n">hn</span> <span class="o">=</span> <span class="o">-</span><span class="n">minv</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">hn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(0.0, 0.0,…
</pre></div>


<p>Combined with the angle defect definition of discrete Gaussian curvature, one
can define principal curvatures and use least squares fitting to find
directions  <cite data-cite="meyer2003">(Meyer, 2003)</cite>.</p>
<p>Alternatively, a robust method for determining principal curvatures is via
quadric fitting  <cite data-cite="panozzo2010">(Panozzo, 2010)</cite>. In the neighborhood around every vertex, a
best-fit quadric is found and principal curvature values and directions are
analytically computed on this quadric.</p>
<div class="codehilite"><pre><span></span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">principal_curvature</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">h2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">},</span> <span class="n">return_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">avg</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">avg_edge_length</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_lines</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">v1</span> <span class="o">*</span> <span class="n">avg</span><span class="p">,</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v1</span> <span class="o">*</span> <span class="n">avg</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;line_color&quot;</span><span class="p">:</span> <span class="s2">&quot;red&quot;</span><span class="p">})</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_lines</span><span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">v2</span> <span class="o">*</span> <span class="n">avg</span><span class="p">,</span> <span class="n">v</span> <span class="o">-</span> <span class="n">v2</span> <span class="o">*</span> <span class="n">avg</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;line_color&quot;</span><span class="p">:</span> <span class="s2">&quot;green&quot;</span><span class="p">});</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(0.0, 0.0,…
</pre></div>


<h3 id="gradient">Gradient<a class="headerlink" href="#gradient" title="Permanent link">&para;</a></h3>
<p>Scalar functions on a surface can be discretized as a piecewise linear function
with values defined at each mesh vertex:</p>
<p><span><span class="MathJax_Preview">f(\mathbf{x}) \approx \sum\limits_{i=1}^n \phi_i(\mathbf{x})\, f_i,</span><script type="math/tex">f(\mathbf{x}) \approx \sum\limits_{i=1}^n \phi_i(\mathbf{x})\, f_i,</script></span></p>
<p>where <span><span class="MathJax_Preview">\phi_i</span><script type="math/tex">\phi_i</script></span> is a piecewise linear hat function defined by the mesh so that
for each triangle <span><span class="MathJax_Preview">\phi_i</span><script type="math/tex">\phi_i</script></span> is <em>the</em> linear function which is one only at
vertex <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> and zero at the other corners.</p>
<p><img alt="Hat function \phi_i\phi_i is one at vertex ii, zero at all other vertices, and linear on incident triangles." src="../images/hat-function.jpg" /></p>
<p>Thus gradients of such piecewise linear functions are simply sums of gradients
of the hat functions:</p>
<p><span><span class="MathJax_Preview">\nabla f(\mathbf{x}) \approx
 \nabla \sum\limits_{i=1}^n \phi_i(\mathbf{x})\, f_i =
 \sum\limits_{i=1}^n \nabla \phi_i(\mathbf{x})\, f_i.</span><script type="math/tex">\nabla f(\mathbf{x}) \approx
 \nabla \sum\limits_{i=1}^n \phi_i(\mathbf{x})\, f_i =
 \sum\limits_{i=1}^n \nabla \phi_i(\mathbf{x})\, f_i.</script></span></p>
<p>This reveals that the gradient is a linear function of the vector of <span><span class="MathJax_Preview">f_i</span><script type="math/tex">f_i</script></span>
values. Because the <span><span class="MathJax_Preview">\phi_i</span><script type="math/tex">\phi_i</script></span> are linear in each triangle, their gradients are
<em>constant</em> in each triangle. Thus our discrete gradient operator can be written
as a matrix multiplication taking vertex values to triangle values:</p>
<p><span><span class="MathJax_Preview">\nabla f \approx \mathbf{G}\,\mathbf{f},</span><script type="math/tex">\nabla f \approx \mathbf{G}\,\mathbf{f},</script></span></p>
<p>where <span><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span> is <span><span class="MathJax_Preview">n\times 1</span><script type="math/tex">n\times 1</script></span> and <span><span class="MathJax_Preview">\mathbf{G}</span><script type="math/tex">\mathbf{G}</script></span> is an <span><span class="MathJax_Preview">md\times n</span><script type="math/tex">md\times n</script></span> sparse
matrix. This matrix <span><span class="MathJax_Preview">\mathbf{G}</span><script type="math/tex">\mathbf{G}</script></span> can be derived geometrically <cite data-cite="jacobson2013">(Jacobson, 2013)</cite>.</p>
<p>Libigl&rsquo;s <code class="codehilite">grad</code> function computes <span><span class="MathJax_Preview">\mathbf{G}</span><script type="math/tex">\mathbf{G}</script></span> for
triangle and tetrahedral meshes. 
Let&rsquo;s see how this works. First load a mesh and a corresponding surface function.
Next, compute the gradient operator g (#F*3 x #V) on the triangle mesh, apply it to the surface function and extract the magnitude.</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/cheburashka.off&quot;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_dmat</span><span class="p">(</span><span class="s2">&quot;data/cheburashka-scalar.dmat&quot;</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">gu</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

<span class="n">gu_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gu</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span><span class="bp">False</span><span class="p">},</span> <span class="n">return_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">max_size</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">avg_edge_length</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">gu_mag</span><span class="p">)</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">bcn</span> <span class="o">=</span> <span class="n">bc</span> <span class="o">+</span> <span class="n">max_size</span> <span class="o">*</span> <span class="n">gu</span>
<span class="n">p</span><span class="o">.</span><span class="n">add_lines</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">bcn</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;line_color&quot;</span><span class="p">:</span> <span class="s2">&quot;black&quot;</span><span class="p">});</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(0.4999999…
</pre></div>


<h3 id="laplacian">Laplacian<a class="headerlink" href="#laplacian" title="Permanent link">&para;</a></h3>
<p>The discrete Laplacian is an essential geometry processing tool. Many
interpretations and flavors of the Laplace and Laplace-Beltrami operator exist.</p>
<p>In open Euclidean space, the <em>Laplace</em> operator is the usual divergence of
gradient (or equivalently the Laplacian of a function is the trace of its
Hessian):</p>
<p><span><span class="MathJax_Preview">\Delta f =
 \frac{\partial^2 f}{\partial x^2} +
 \frac{\partial^2 f}{\partial y^2} +
 \frac{\partial^2 f}{\partial z^2}.</span><script type="math/tex">\Delta f =
 \frac{\partial^2 f}{\partial x^2} +
 \frac{\partial^2 f}{\partial y^2} +
 \frac{\partial^2 f}{\partial z^2}.</script></span></p>
<p>The <em>Laplace-Beltrami</em> operator generalizes this to surfaces.</p>
<p>When considering piecewise-linear functions on a triangle mesh, a discrete
Laplacian may be derived in a variety of ways. The most popular in geometry
processing is the so-called &ldquo;cotangent Laplacian&rdquo; <span><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>, arising
simultaneously from FEM, DEC and applying divergence theorem to vertex
one-rings. As a linear operator taking vertex values to vertex values, the
Laplacian <span><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span> is a <span><span class="MathJax_Preview">n\times n</span><script type="math/tex">n\times n</script></span> matrix with elements:</p>
<p><span><span class="MathJax_Preview">L_{ij} = \begin{cases}j \in N(i) &amp;\cot \alpha_{ij} + \cot \beta_{ij},\\
j \notin N(i) &amp; 0,\\
i = j &amp; -\sum\limits_{k\neq i} L_{ik},
\end{cases}</span><script type="math/tex">L_{ij} = \begin{cases}j \in N(i) &\cot \alpha_{ij} + \cot \beta_{ij},\\
j \notin N(i) & 0,\\
i = j & -\sum\limits_{k\neq i} L_{ik},
\end{cases}</script></span></p>
<p>where <span><span class="MathJax_Preview">N(i)</span><script type="math/tex">N(i)</script></span> are the vertices adjacent to (neighboring) vertex <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>, and
<span><span class="MathJax_Preview">\alpha_{ij},\beta_{ij}</span><script type="math/tex">\alpha_{ij},\beta_{ij}</script></span> are the angles opposite to edge <span><span class="MathJax_Preview">{ij}</span><script type="math/tex">{ij}</script></span>.</p>
<p>Libigl implements discrete &ldquo;cotangent Laplacians&rdquo; for triangles meshes and
tetrahedral meshes, building both with fast geometric rules rather than &ldquo;by the
book&rdquo; FEM construction which involves many (small) matrix inversions <cite data-cite="sharf_2007">(Sharf, 2007)</cite>.</p>
<p>First, load a triangle mesh and then calculate the Laplace-Beltrami operator, visualize the normals as pseudocolors.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>

<span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/cow.off&quot;</span><span class="p">)</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">per_vertex_normals</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">+</span><span class="mf">0.5</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">},</span> <span class="n">return_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">vs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
<span class="n">cs</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">igl</span><span class="o">.</span><span class="n">MASSMATRIX_TYPE_BARYCENTRIC</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">l</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">per_vertex_normals</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span><span class="o">*</span><span class="mf">0.5</span><span class="o">+</span><span class="mf">0.5</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">vs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">cs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="nd">@interact</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">mcf</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">update_object</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">vs</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">colors</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(0.0, 0.0,…



interactive(children=(IntSlider(value=0, description=&#39;level&#39;, max=9), Output()), _dom_classes=(&#39;widget-interac…
</pre></div>


<p>The operator applied to mesh vertex positions amounts to smoothing by <em>flowing</em>
the surface along the mean curvature normal direction. Note that this is equivalent to minimizing surface area. The following example computes conformalized mean curvature flow using the cotangent Laplacian <cite data-cite="kazhdan_2012">(Kazhdan, 2012)</cite> </p>
<h3 id="mass-matrix">Mass matrix<a class="headerlink" href="#mass-matrix" title="Permanent link">&para;</a></h3>
<p>The mass matrix <span><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span> is another <span><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> matrix which takes vertex
values to vertex values. From an FEM point of view, it is a discretization of
the inner-product: it accounts for the area around each vertex. Consequently,
<span><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span> is often a diagonal matrix, such that <span><span class="MathJax_Preview">M_{ii}</span><script type="math/tex">M_{ii}</script></span> is the barycentric
or voronoi area around vertex <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> in the mesh <cite data-cite="meyer_2003">(Meyer, 2003)</cite>. The inverse of this matrix is also very useful as it transforms integrated quantities into point-wise quantities, e.g.:</p>
<p><span><span class="MathJax_Preview">\Delta f \approx \mathbf{M}^{-1} \mathbf{L} \mathbf{f}.</span><script type="math/tex">\Delta f \approx \mathbf{M}^{-1} \mathbf{L} \mathbf{f}.</script></span></p>
<p>In general, when encountering squared quantities integrated over the surface,
the mass matrix will be used as the discretization of the inner product when
sampling function values at vertices:</p>
<p><span><span class="MathJax_Preview">\int_S x\, y\ dA \approx \mathbf{x}^T\mathbf{M}\,\mathbf{y}.</span><script type="math/tex">\int_S x\, y\ dA \approx \mathbf{x}^T\mathbf{M}\,\mathbf{y}.</script></span></p>
<p>An alternative mass matrix <span><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span> is a <span><span class="MathJax_Preview">md \times md</span><script type="math/tex">md \times md</script></span> matrix which takes
triangle vector values to triangle vector values. This matrix represents an
inner-product accounting for the area associated with each triangle (i.e. the
triangles true area).</p>
<h3 id="alternative-construction-of-laplacian">Alternative construction of Laplacian<a class="headerlink" href="#alternative-construction-of-laplacian" title="Permanent link">&para;</a></h3>
<p>An alternative construction of the discrete cotangent Laplacian is by
&ldquo;squaring&rdquo; the discrete gradient operator. This may be derived by applying
Green&rsquo;s identity (ignoring boundary conditions for the moment):</p>
<p><span><span class="MathJax_Preview">\int_S \|\nabla f\|^2 dA = \int_S f \Delta f dA</span><script type="math/tex">\int_S \|\nabla f\|^2 dA = \int_S f \Delta f dA</script></span></p>
<p>Or in matrix form which is immediately translatable to code:</p>
<p><span><span class="MathJax_Preview">\mathbf{f}^T \mathbf{G}^T \mathbf{T} \mathbf{G} \mathbf{f} =
  \mathbf{f}^T \mathbf{M} \mathbf{M}^{-1} \mathbf{L} \mathbf{f} =
  \mathbf{f}^T \mathbf{L} \mathbf{f}.</span><script type="math/tex">\mathbf{f}^T \mathbf{G}^T \mathbf{T} \mathbf{G} \mathbf{f} =
  \mathbf{f}^T \mathbf{M} \mathbf{M}^{-1} \mathbf{L} \mathbf{f} =
  \mathbf{f}^T \mathbf{L} \mathbf{f}.</script></span></p>
<p>So we have that <span><span class="MathJax_Preview">\mathbf{L} = \mathbf{G}^T \mathbf{T} \mathbf{G}</span><script type="math/tex">\mathbf{L} = \mathbf{G}^T \mathbf{T} \mathbf{G}</script></span>. This also
hints that we may consider <span><span class="MathJax_Preview">\mathbf{G}^T</span><script type="math/tex">\mathbf{G}^T</script></span> as a discrete <em>divergence</em> operator,
since the Laplacian is the divergence of the gradient. Naturally, <span><span class="MathJax_Preview">\mathbf{G}^T</span><script type="math/tex">\mathbf{G}^T</script></span> is
a <span><span class="MathJax_Preview">n \times md</span><script type="math/tex">n \times md</script></span> sparse matrix which takes vector values stored at triangle faces
to scalar divergence values at vertices.</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/cow.off&quot;</span><span class="p">)</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

<span class="n">d_area</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">d_area</span><span class="p">,</span> <span class="n">d_area</span><span class="p">,</span> <span class="n">d_area</span><span class="p">])</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

<span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="n">g</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;|k-l|: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">l</span><span class="p">))</span>
</pre></div>

<div class="codehilite"><pre><span></span>|k-l|: 6.654117928693559e-13
</pre></div>


<h3 id="exact-discrete-geodesic-distances">Exact Discrete Geodesic Distances<a class="headerlink" href="#exact-discrete-geodesic-distances" title="Permanent link">&para;</a></h3>
<p>The discrete geodesic distance between two points is the length of the shortest
path between then restricted to the surface. For triangle meshes, such a path is
made of a set of segments which can be either edges of the mesh or crossing a
triangle.</p>
<p>Libigl includes a wrapper for the exact geodesic algorithm <cite data-cite="mitchell_1987">(Mitchell, 1987)</cite>
developed by Danil Kirsanov (<a href="https://code.google.com/archive/p/geodesic/">https://code.google.com/archive/p/geodesic/</a>),
exposing it through an Eigen-based API. The function 
<div class="codehilite"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">exact_geodesic</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">vt</span><span class="p">,</span> <span class="n">ft</span><span class="p">)</span>
</pre></div>
computes the closest geodesic distances of each vertex in vt or face in ft, from
the source vertices vs or faces fs of the input mesh v, f. The output is written
in the vector d, which lists first the distances for the vertices in vt, and
then for the faces in ft. </p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/armadillo.obj&quot;</span><span class="p">)</span>

<span class="c1">## Select a vertex from which the distances should be calculated</span>
<span class="n">vs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="c1">##All vertices are the targets</span>
<span class="n">vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">exact_geodesic</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">vt</span><span class="p">)</span><span class="c1">#, fs, ft)</span>

<span class="n">strip_size</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="c1">##The function should be 1 on each integer coordinate</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="n">d</span> <span class="o">/</span> <span class="n">strip_size</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)))</span>
<span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">})</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(-0.015966…
</pre></div>


<h2 id="chapter-2-matrices-and-linear-algebra">Chapter 2: Matrices and Linear Algebra<a class="headerlink" href="#chapter-2-matrices-and-linear-algebra" title="Permanent link">&para;</a></h2>
<h3 id="laplace-equation">Laplace equation<a class="headerlink" href="#laplace-equation" title="Permanent link">&para;</a></h3>
<p>A common linear system in geometry processing is the Laplace equation:</p>
<p><span><span class="MathJax_Preview">∆z = 0</span><script type="math/tex">∆z = 0</script></span></p>
<p>subject to some boundary conditions, for example Dirichlet boundary conditions
(fixed value):</p>
<p><span><span class="MathJax_Preview">\left.z\right|_{\partial{S}} = z_{bc}</span><script type="math/tex">\left.z\right|_{\partial{S}} = z_{bc}</script></span></p>
<p>In the discrete setting, the linear system can be written as:</p>
<p><span><span class="MathJax_Preview">\mathbf{L} \mathbf{z} = \mathbf{0}</span><script type="math/tex">\mathbf{L} \mathbf{z} = \mathbf{0}</script></span></p>
<p>where <span><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span> is the <span><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> discrete Laplacian and <span><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> is a
vector of per-vertex values. Most of <span><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> correspond to interior
vertices and are unknown, but some of <span><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> represent values at boundary
vertices. Their values are known so we may move their corresponding terms to
the right-hand side.</p>
<p>Conceptually, this is very easy if we have sorted <span><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> so that interior
vertices come first and then boundary vertices:</p>
<div>
<div class="MathJax_Preview">
 \left(\begin{array}{cc}
 \mathbf{L}_{in,in} &amp; \mathbf{L}_{in,b}\\
 \mathbf{L}_{b,in} &amp; \mathbf{L}_{b,b}\end{array}\right)
 \left(\begin{array}{c}
 \mathbf{z}_{in}\\
 \mathbf{z}_{b}\end{array}\right) =
 \left(\begin{array}{c}
 \mathbf{0}_{in}\\
 \mathbf{z}_{bc}\end{array}\right)
</div>
<script type="math/tex; mode=display">
 \left(\begin{array}{cc}
 \mathbf{L}_{in,in} & \mathbf{L}_{in,b}\\
 \mathbf{L}_{b,in} & \mathbf{L}_{b,b}\end{array}\right)
 \left(\begin{array}{c}
 \mathbf{z}_{in}\\
 \mathbf{z}_{b}\end{array}\right) =
 \left(\begin{array}{c}
 \mathbf{0}_{in}\\
 \mathbf{z}_{bc}\end{array}\right)
</script>
</div>
<p>The bottom block of equations is no longer meaningful so we&rsquo;ll only consider
the top block:</p>
<div>
<div class="MathJax_Preview">
 \left(\begin{array}{cc}
 \mathbf{L}_{in,in} &amp; \mathbf{L}_{in,b}\end{array}\right)
 \left(\begin{array}{c}
 \mathbf{z}_{in}\\
 \mathbf{z}_{b}\end{array}\right) =
 \mathbf{0}_{in}
</div>
<script type="math/tex; mode=display">
 \left(\begin{array}{cc}
 \mathbf{L}_{in,in} & \mathbf{L}_{in,b}\end{array}\right)
 \left(\begin{array}{c}
 \mathbf{z}_{in}\\
 \mathbf{z}_{b}\end{array}\right) =
 \mathbf{0}_{in}
</script>
</div>
<p>We can move the known values to the right-hand side:</p>
<div>
<div class="MathJax_Preview">
 \mathbf{L}_{in,in}
 \mathbf{z}_{in} = -
 \mathbf{L}_{in,b}
 \mathbf{z}_{b}
</div>
<script type="math/tex; mode=display">
 \mathbf{L}_{in,in}
 \mathbf{z}_{in} = -
 \mathbf{L}_{in,b}
 \mathbf{z}_{b}
</script>
</div>
<p>Finally we can solve this equation for the unknown values at interior vertices
<span><span class="MathJax_Preview">\mathbf{z}_{in}</span><script type="math/tex">\mathbf{z}_{in}</script></span>.</p>
<p>However, our vertices will often not be sorted in this way. One option would be to sort <code class="codehilite">V</code>,
then proceed as above and then <em>unsort</em> the solution <code class="codehilite">Z</code> to match <code class="codehilite">V</code>. However,
this solution is not very general.</p>
<p>With array slicing no explicit sort is needed. Instead we can <em>slice-out</em>
submatrix blocks (<span><span class="MathJax_Preview">\mathbf{L}_{in,in}</span><script type="math/tex">\mathbf{L}_{in,in}</script></span>, <span><span class="MathJax_Preview">\mathbf{L}_{in,b}</span><script type="math/tex">\mathbf{L}_{in,b}</script></span>, etc.) and follow
the linear algebra above directly. Then we can slice the solution <em>into</em> the
rows of <code class="codehilite">Z</code> corresponding to the interior vertices.</p>
<div class="codehilite"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span>

<span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/camelhead.off&quot;</span><span class="p">)</span>

<span class="c1">## Find boundary vertices</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">boundary_facets</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">v_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

<span class="c1">## List of all vertex indices</span>
<span class="n">v_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1">## List of interior indices</span>
<span class="n">v_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">v_all</span><span class="p">,</span> <span class="n">v_b</span><span class="p">)</span>

<span class="c1">## Construct and slice up Laplacian</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">l_ii</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">v_in</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">l_ii</span> <span class="o">=</span> <span class="n">l_ii</span><span class="p">[:,</span> <span class="n">v_in</span><span class="p">]</span>

<span class="n">l_ib</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">v_in</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">l_ib</span> <span class="o">=</span> <span class="n">l_ib</span><span class="p">[:,</span> <span class="n">v_b</span><span class="p">]</span>

<span class="c1">## Dirichlet boundary conditions from z-coordinate</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">v_b</span><span class="p">]</span>

<span class="c1">## Solve PDE</span>
<span class="n">z_in</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="o">-</span><span class="n">l_ii</span><span class="p">,</span> <span class="n">l_ib</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bc</span><span class="p">))</span>

<span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(1.9967555…
</pre></div>


<h3 id="quadratic-energy-minimization">Quadratic energy minimization<a class="headerlink" href="#quadratic-energy-minimization" title="Permanent link">&para;</a></h3>
<p>The same Laplace equation may be equivalently derived by minimizing Dirichlet
energy subject to the same boundary conditions:</p>
<p><span><span class="MathJax_Preview">\mathop{\text{minimize }}_z \frac{1}{2}\int\limits_S \|\nabla z\|^2 dA</span><script type="math/tex">\mathop{\text{minimize }}_z \frac{1}{2}\int\limits_S \|\nabla z\|^2 dA</script></span></p>
<p>On our discrete mesh, recall that this becomes</p>
<p><span><span class="MathJax_Preview">\mathop{\text{minimize }}_\mathbf{z}  \frac{1}{2}\mathbf{z}^T \mathbf{G}^T \mathbf{D}
 \mathbf{G} \mathbf{z} \rightarrow \mathop{\text{minimize }}_\mathbf{z} \mathbf{z}^T \mathbf{L} \mathbf{z}</span><script type="math/tex">\mathop{\text{minimize }}_\mathbf{z}  \frac{1}{2}\mathbf{z}^T \mathbf{G}^T \mathbf{D}
 \mathbf{G} \mathbf{z} \rightarrow \mathop{\text{minimize }}_\mathbf{z} \mathbf{z}^T \mathbf{L} \mathbf{z}</script></span></p>
<p>The general problem of minimizing some energy over a mesh subject to fixed
value boundary conditions is so wide spread that libigl has a dedicated api for
solving such systems.</p>
<p>Let us consider a general quadratic minimization problem subject to different
common constraints:</p>
<div>
<div class="MathJax_Preview">
 \mathop{\text{minimize }}_\mathbf{z}  \frac{1}{2}\mathbf{z}^T \mathbf{Q} \mathbf{z} +
 \mathbf{z}^T \mathbf{B} + \text{constant},
</div>
<script type="math/tex; mode=display">
 \mathop{\text{minimize }}_\mathbf{z}  \frac{1}{2}\mathbf{z}^T \mathbf{Q} \mathbf{z} +
 \mathbf{z}^T \mathbf{B} + \text{constant},
</script>
</div>
<p>subject to</p>
<div>
<div class="MathJax_Preview">
 \mathbf{z}_b = \mathbf{z}_{bc} \text{ and } \mathbf{A}_{eq} \mathbf{z} =
 \mathbf{B}_{eq},
</div>
<script type="math/tex; mode=display">
 \mathbf{z}_b = \mathbf{z}_{bc} \text{ and } \mathbf{A}_{eq} \mathbf{z} =
 \mathbf{B}_{eq},
</script>
</div>
<p>where</p>
<ul>
<li><span><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span> is a (usually sparse) <span><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> positive semi-definite
    matrix of quadratic coefficients (Hessian),</li>
<li><span><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> is a <span><span class="MathJax_Preview">n \times 1</span><script type="math/tex">n \times 1</script></span> vector of linear coefficients,</li>
<li><span><span class="MathJax_Preview">\mathbf{z}_b</span><script type="math/tex">\mathbf{z}_b</script></span> is a <span><span class="MathJax_Preview">|b| \times 1</span><script type="math/tex">|b| \times 1</script></span> portion of
<span><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> corresponding to boundary or <em>fixed</em> vertices,</li>
<li><span><span class="MathJax_Preview">\mathbf{z}_{bc}</span><script type="math/tex">\mathbf{z}_{bc}</script></span> is a <span><span class="MathJax_Preview">|b| \times 1</span><script type="math/tex">|b| \times 1</script></span> vector of known values corresponding to
    <span><span class="MathJax_Preview">\mathbf{z}_b</span><script type="math/tex">\mathbf{z}_b</script></span>,</li>
<li><span><span class="MathJax_Preview">\mathbf{A}_{eq}</span><script type="math/tex">\mathbf{A}_{eq}</script></span> is a (usually sparse) <span><span class="MathJax_Preview">m \times n</span><script type="math/tex">m \times n</script></span> matrix of linear
    equality constraint coefficients (one row per constraint), and</li>
<li><span><span class="MathJax_Preview">\mathbf{B}_{eq}</span><script type="math/tex">\mathbf{B}_{eq}</script></span> is a <span><span class="MathJax_Preview">m \times 1</span><script type="math/tex">m \times 1</script></span> vector of linear equality constraint
    right-hand side values.</li>
</ul>
<p>This specification is overly general as we could write <span><span class="MathJax_Preview">\mathbf{z}_b =
\mathbf{z}_{bc}</span><script type="math/tex">\mathbf{z}_b =
\mathbf{z}_{bc}</script></span> as rows of <span><span class="MathJax_Preview">\mathbf{A}_{eq} \mathbf{z} =
\mathbf{B}_{eq}</span><script type="math/tex">\mathbf{A}_{eq} \mathbf{z} =
\mathbf{B}_{eq}</script></span>, but these fixed value constraints appear so often that they
merit a dedicated function: <code class="codehilite">min_quad_with_fixed</code>.</p>
<h3 id="linear-equality-constraints">Linear equality constraints<a class="headerlink" href="#linear-equality-constraints" title="Permanent link">&para;</a></h3>
<p>We saw above that <code class="codehilite">min_quad_with_fixed</code> in libigl provides a compact way to
solve general quadratic programs. Let&rsquo;s consider another example, this time
with active linear equality constraints. Specifically let&rsquo;s solve the
<code class="codehilite">bi-Laplace equation</code> or equivalently minimize the Laplace energy:</p>
<div>
<div class="MathJax_Preview">
 \Delta^2 z = 0 \leftrightarrow \mathop{\text{minimize }}\limits_z \frac{1}{2}
 \int\limits_S (\Delta z)^2 dA
</div>
<script type="math/tex; mode=display">
 \Delta^2 z = 0 \leftrightarrow \mathop{\text{minimize }}\limits_z \frac{1}{2}
 \int\limits_S (\Delta z)^2 dA
</script>
</div>
<p>subject to fixed value constraints and a linear equality constraint:</p>
<p><span><span class="MathJax_Preview">z_{a} = 1, z_{b} = -1</span><script type="math/tex">z_{a} = 1, z_{b} = -1</script></span> and <span><span class="MathJax_Preview">z_{c} = z_{d}</span><script type="math/tex">z_{c} = z_{d}</script></span>.</p>
<p>Notice that we can rewrite the last constraint in the familiar form from above:</p>
<p><span><span class="MathJax_Preview">z_{c} - z_{d} = 0.</span><script type="math/tex">z_{c} - z_{d} = 0.</script></span></p>
<p>Now we can assembly <code class="codehilite">Aeq</code> as a <span><span class="MathJax_Preview">1 \times n</span><script type="math/tex">1 \times n</script></span> sparse matrix with a coefficient
<span><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> in the column corresponding to vertex <span><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span> and a <span><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span> at <span><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>. The right-hand
side <code class="codehilite">Beq</code> is simply zero.</p>
<p>Internally, <code class="codehilite">min_quad_with_fixed</code> solves using the Lagrange Multiplier
method. This method adds additional variables for each linear constraint (in
general a <span><span class="MathJax_Preview">m \times 1</span><script type="math/tex">m \times 1</script></span> vector of variables <span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>) and then solves the
saddle problem:</p>
<div>
<div class="MathJax_Preview">
  \mathop{\text{find saddle }}_{\mathbf{z},\lambda}\, \frac{1}{2}\mathbf{z}^T \mathbf{Q} \mathbf{z} +
  \mathbf{z}^T \mathbf{B} + \text{constant} + \lambda^T\left(\mathbf{A}_{eq}
 \mathbf{z} - \mathbf{B}_{eq}\right)
</div>
<script type="math/tex; mode=display">
  \mathop{\text{find saddle }}_{\mathbf{z},\lambda}\, \frac{1}{2}\mathbf{z}^T \mathbf{Q} \mathbf{z} +
  \mathbf{z}^T \mathbf{B} + \text{constant} + \lambda^T\left(\mathbf{A}_{eq}
 \mathbf{z} - \mathbf{B}_{eq}\right)
</script>
</div>
<p>This can be rewritten in a more familiar form by stacking <span><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> and
<span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span> into one <span><span class="MathJax_Preview">(m+n) \times 1</span><script type="math/tex">(m+n) \times 1</script></span> vector of unknowns:</p>
<div>
<div class="MathJax_Preview">
 \mathop{\text{find saddle }}_{\mathbf{z},\lambda}\,
 \frac{1}{2}
 \left(
  \mathbf{z}^T
  \lambda^T
 \right)
 \left(
  \begin{array}{cc}
  \mathbf{Q}      &amp; \mathbf{A}_{eq}^T\\
  \mathbf{A}_{eq} &amp; 0
  \end{array}
 \right)
 \left(
  \begin{array}{c}
  \mathbf{z}\\
  \lambda
  \end{array}
 \right) +
 \left(
  \mathbf{z}^T
  \lambda^T
 \right)
 \left(
  \begin{array}{c}
  \mathbf{B}\\
  -\mathbf{B}_{eq}
  \end{array}
  \right)
  + \text{constant}
</div>
<script type="math/tex; mode=display">
 \mathop{\text{find saddle }}_{\mathbf{z},\lambda}\,
 \frac{1}{2}
 \left(
  \mathbf{z}^T
  \lambda^T
 \right)
 \left(
  \begin{array}{cc}
  \mathbf{Q}      & \mathbf{A}_{eq}^T\\
  \mathbf{A}_{eq} & 0
  \end{array}
 \right)
 \left(
  \begin{array}{c}
  \mathbf{z}\\
  \lambda
  \end{array}
 \right) +
 \left(
  \mathbf{z}^T
  \lambda^T
 \right)
 \left(
  \begin{array}{c}
  \mathbf{B}\\
  -\mathbf{B}_{eq}
  \end{array}
  \right)
  + \text{constant}
</script>
</div>
<p>Differentiating with respect to <span><span class="MathJax_Preview">\left( \mathbf{z}^T \lambda^T \right)</span><script type="math/tex">\left( \mathbf{z}^T \lambda^T \right)</script></span> reveals
a linear system and we can solve for <span><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> and <span><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>. The only
difference from the straight quadratic <em>minimization</em> system, is that this
saddle problem system will not be positive definite. Thus, we must use a
different factorization technique (LDLT rather than LLT): libigl&rsquo;s
<code class="codehilite">min_quad_with_fixed</code> automatically chooses the correct solver in
the presence of linear equality constraints.</p>
<p>The following example first solves with just fixed value constraints (left: 1 and -1 on the left hand and foot respectively), then solves with an additional linear equality constraint (right: points on right hand and foot constrained to be equal).</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/cheburashka.off&quot;</span><span class="p">)</span>

<span class="c1">## Two fixed points: Left hand, left foot should have values 1 and -1</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4331</span><span class="p">,</span> <span class="mi">5957</span><span class="p">])</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">])</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1">## Construct Laplacian and mass matrix</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">igl</span><span class="o">.</span><span class="n">MASSMATRIX_TYPE_VORONOI</span><span class="p">)</span>
<span class="n">Minv</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">M</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>

<span class="c1">## Bi-Laplacian</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">L</span> <span class="err">@</span> <span class="p">(</span><span class="n">Minv</span> <span class="err">@</span> <span class="n">L</span><span class="p">)</span>

<span class="c1">## Solve with only equality constraints</span>
<span class="n">Aeq</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">Beq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
<span class="n">_</span><span class="p">,</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">min_quad_with_fixed</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">Aeq</span><span class="p">,</span> <span class="n">Beq</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

<span class="c1">## Solve with equality and linear constraints</span>
<span class="n">Aeq</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="n">Aeq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6074</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">Aeq</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6523</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">Beq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span>
<span class="n">_</span><span class="p">,</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">min_quad_with_fixed</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">Aeq</span><span class="p">,</span> <span class="n">Beq</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

<span class="c1">## Normalize colors to same range</span>
<span class="n">min_z</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z2</span><span class="p">))</span>
<span class="n">max_z</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z2</span><span class="p">))</span>
<span class="n">z</span> <span class="o">=</span> <span class="p">[(</span><span class="n">z1</span> <span class="o">-</span> <span class="n">min_z</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_z</span> <span class="o">-</span> <span class="n">min_z</span><span class="p">),</span> <span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">min_z</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_z</span> <span class="o">-</span> <span class="n">min_z</span><span class="p">)]</span>

<span class="c1">## Plot the functions</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span><span class="bp">False</span><span class="p">},</span> <span class="n">return_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="nd">@interact</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;z0&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;z1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">sf</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">update_object</span><span class="p">(</span><span class="n">colors</span><span class="o">=</span><span class="n">z</span><span class="p">[</span><span class="n">function</span><span class="p">])</span>
</pre></div>

<div class="codehilite"><pre><span></span>/Users/teseo/conda/envs/base2/lib/python3.6/site-packages/ipykernel_launcher.py:23: SparseEfficiencyWarning: Changing the sparsity structure of a csc_matrix is expensive. lil_matrix is more efficient.
/Users/teseo/conda/envs/base2/lib/python3.6/site-packages/ipykernel_launcher.py:24: SparseEfficiencyWarning: Changing the sparsity structure of a csc_matrix is expensive. lil_matrix is more efficient.



Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(0.4999999…



interactive(children=(Dropdown(description=&#39;function&#39;, options=((&#39;z0&#39;, 0), (&#39;z1&#39;, 1)), value=0), Output()), _d…
</pre></div>


<h3 id="eigen-decomposition">Eigen Decomposition<a class="headerlink" href="#eigen-decomposition" title="Permanent link">&para;</a></h3>
<p>Libigl has rudimentary support for extracting eigen pairs of a generalized
eigen value problem:</p>
<p><span><span class="MathJax_Preview">Ax = \lambda B x</span><script type="math/tex">Ax = \lambda B x</script></span></p>
<p>where <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> is a sparse symmetric matrix and <span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> is a sparse positive definite
matrix. Most commonly in geometry processing, we let <span><span class="MathJax_Preview">A=L</span><script type="math/tex">A=L</script></span> the cotangent
Laplacian and <span><span class="MathJax_Preview">B=M</span><script type="math/tex">B=M</script></span> the per-vertex mass matrix <cite data-cite="vallet_2008">(Vallet, 2008)</cite>.
Typically applications will make use of the <em>low frequency</em> eigen modes.
Analogous to the Fourier decomposition, a function <span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> on a surface can be
represented via its spectral decomposition of the eigen modes of the
Laplace-Beltrami:</p>
<p><span><span class="MathJax_Preview">f = \sum\limits_{i=1}^\infty a_i \phi_i</span><script type="math/tex">f = \sum\limits_{i=1}^\infty a_i \phi_i</script></span></p>
<p>where each <span><span class="MathJax_Preview">\phi_i</span><script type="math/tex">\phi_i</script></span> is an eigen function satisfying: <span><span class="MathJax_Preview">\Delta \phi_i = \lambda_i
\phi_i</span><script type="math/tex">\Delta \phi_i = \lambda_i
\phi_i</script></span> and <span><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span> are scalar coefficients. For a discrete triangle mesh, a
completely analogous decomposition exists, albeit with finite sum:</p>
<p><span><span class="MathJax_Preview">\mathbf{f} = \sum\limits_{i=1}^n a_i \phi_i</span><script type="math/tex">\mathbf{f} = \sum\limits_{i=1}^n a_i \phi_i</script></span></p>
<p>where now a column vector of values at vertices <span><span class="MathJax_Preview">\mathbf{f} \in \mathcal{R}^n</span><script type="math/tex">\mathbf{f} \in \mathcal{R}^n</script></span>
specifies a piecewise linear function and <span><span class="MathJax_Preview">\phi_i \in \mathcal{R}^n</span><script type="math/tex">\phi_i \in \mathcal{R}^n</script></span> is an
eigen vector satisfying:</p>
<p><span><span class="MathJax_Preview">\mathbf{L} \phi_i = \lambda_i \mathbf{M} \phi_i</span><script type="math/tex">\mathbf{L} \phi_i = \lambda_i \mathbf{M} \phi_i</script></span>.</p>
<p>Note that Vallet &amp; Levy <cite data-cite="vallet_2008">(Vallet, 2008)</cite> propose solving a symmetrized
<em>standard</em> eigen problem <span><span class="MathJax_Preview">\mathbf{M}^{-1/2}\mathbf{L}\mathbf{M}^{-1/2} \phi_i
= \lambda_i \phi_i</span><script type="math/tex">\mathbf{M}^{-1/2}\mathbf{L}\mathbf{M}^{-1/2} \phi_i
= \lambda_i \phi_i</script></span>. Libigl implements a generalized eigen problem solver so
this unnecessary symmetrization can be avoided.</p>
<p>Often the sum above is <em>truncated</em> to the first <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> eigen vectors. If the low
frequency modes are chosen, i.e. those corresponding to small <span><span class="MathJax_Preview">\lambda_i</span><script type="math/tex">\lambda_i</script></span>
values, then this truncation effectively <em>regularizes</em> <span><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span> to smooth,
slowly changing functions over the mesh <cite data-cite="hildebrandt_2011">(Hildebrandt, 2011)</cite>. Modal
analysis and model subspaces have been used frequently in real-time deformation
<cite data-cite="barbic_2012">(Barbic, 2005)</cite>.</p>
<p>In the following example, the first k eigen vectors of the discrete Laplace-Beltrami operator are computed and displayed in
pseudocolors atop the beetle. 
Low frequency eigen vectors of the discrete Laplace-Beltrami operator vary smoothly and slowly over the model.
At first, calculate the Laplace-Betrami operator and solve the generalized Eigen problem with scipy/arpack. 
Then, rescale the Eigen vectors and visualize them.</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/beetle.off&quot;</span><span class="p">)</span>
<span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="n">igl</span><span class="o">.</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">igl</span><span class="o">.</span><span class="n">MASSMATRIX_TYPE_VORONOI</span><span class="p">)</span>

<span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">d</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigsh</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;LM&quot;</span><span class="p">)</span>

<span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
<span class="n">bbd</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">bbd</span> <span class="o">*</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span><span class="bp">False</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">},</span> <span class="n">return_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="nd">@interact</span><span class="p">(</span><span class="n">ev</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;EV </span><span class="si">%i</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">sf</span><span class="p">(</span><span class="n">ev</span><span class="p">):</span>
    <span class="n">p</span><span class="o">.</span><span class="n">update_object</span><span class="p">(</span><span class="n">colors</span><span class="o">=</span><span class="n">u</span><span class="p">[:,</span> <span class="n">ev</span><span class="p">])</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(0.0, 0.0,…



interactive(children=(Dropdown(description=&#39;ev&#39;, options=((&#39;EV 0&#39;, 0), (&#39;EV 1&#39;, 1), (&#39;EV 2&#39;, 2), (&#39;EV 3&#39;, 3), …
</pre></div>


<h2 id="chapter-3-shape-deformation">Chapter 3: Shape deformation<a class="headerlink" href="#chapter-3-shape-deformation" title="Permanent link">&para;</a></h2>
<p>Modern mesh-based shape deformation methods satisfy user deformation
constraints at handles (selected vertices or regions on the mesh) and propagate
these handle deformations to the rest of the shape <em>smoothly</em> and <em>without removing
or distorting details</em>. Libigl provides implementations of a variety of
state-of-the-art deformation techniques, ranging from quadratic mesh-based
energy minimizers, to skinning methods, to non-linear elasticity-inspired
techniques.</p>
<h3 id="biharmonic-deformation">Biharmonic deformation<a class="headerlink" href="#biharmonic-deformation" title="Permanent link">&para;</a></h3>
<p>The period of research between 2000 and 2010 produced a collection of
techniques that cast the problem of handle-based shape deformation as a
quadratic energy minimization problem or equivalently the solution to a linear
partial differential equation.</p>
<p>There are many flavors of these techniques, but a prototypical subset are those
that consider solutions to the bi-Laplace equation, that is a biharmonic
function <cite data-cite="botsch_2004">(Botsch, 2004)</cite>. This fourth-order PDE provides sufficient
flexibility in boundary conditions to ensure <span><span class="MathJax_Preview">C^1</span><script type="math/tex">C^1</script></span> continuity at handle
constraints in the limit under refinement <cite data-cite="jacobson_mixed_2010">(Jacobson, 2010)</cite>.</p>
<h4 id="biharmonic-surfaces">Biharmonic surfaces<a class="headerlink" href="#biharmonic-surfaces" title="Permanent link">&para;</a></h4>
<p>Let us first begin our discussion of biharmonic <em>deformation</em>, by considering
biharmonic <em>surfaces</em>. We will casually define biharmonic surfaces as surface
whose <em>position functions</em> are biharmonic with respect to some initial
parameterization:</p>
<p><span><span class="MathJax_Preview">\Delta^2 \mathbf{x}' = 0</span><script type="math/tex">\Delta^2 \mathbf{x}' = 0</script></span></p>
<p>and subject to some handle constraints, conceptualized as &ldquo;boundary
conditions&rdquo;:</p>
<p><span><span class="MathJax_Preview">\mathbf{x}'_{b} = \mathbf{x}_{bc}.</span><script type="math/tex">\mathbf{x}'_{b} = \mathbf{x}_{bc}.</script></span></p>
<p>where <span><span class="MathJax_Preview">\mathbf{x}'</span><script type="math/tex">\mathbf{x}'</script></span> is the unknown 3D position of a point on the surface. So we
are asking that the bi-Laplacian of each of spatial coordinate function to be
zero.</p>
<p>In libigl, one can solve a biharmonic problem with <code class="codehilite">harmonic_weights</code>
and setting <span><span class="MathJax_Preview">k=2</span><script type="math/tex">k=2</script></span> (<em>bi</em>-harmonic).</p>
<p>This produces a smooth surface that interpolates the handle constraints, but all
original details on the surface will be <em>smoothed away</em>. Most obviously, if the
original surface is not already biharmonic, then giving all handles the
identity deformation (keeping them at their rest positions) will <strong>not</strong>
reproduce the original surface. Rather, the result will be the biharmonic
surface that does interpolate those handle positions.</p>
<p>Thus, we may conclude that this is not an intuitive technique for shape
deformation.</p>
<h4 id="biharmonic-deformation-fields">Biharmonic deformation fields<a class="headerlink" href="#biharmonic-deformation-fields" title="Permanent link">&para;</a></h4>
<p>Now we know that one useful property for a deformation technique is &ldquo;rest pose
reproduction&rdquo;: applying no deformation to the handles should apply no
deformation to the shape.</p>
<p>To guarantee this by construction we can work with <em>deformation fields</em> (ie.
displacements)
<span><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span> rather
than directly with positions <span><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>. Then the deformed positions can be
recovered as</p>
<p><span><span class="MathJax_Preview">\mathbf{x}' = \mathbf{x}+\mathbf{d}.</span><script type="math/tex">\mathbf{x}' = \mathbf{x}+\mathbf{d}.</script></span></p>
<p>A smooth deformation field <span><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span> which interpolates the deformation
fields of the handle constraints will impose a smooth deformed shape
<span><span class="MathJax_Preview">\mathbf{x}'</span><script type="math/tex">\mathbf{x}'</script></span>. Naturally, we consider <em>biharmonic deformation fields</em>:</p>
<p><span><span class="MathJax_Preview">\Delta^2 \mathbf{d} = 0</span><script type="math/tex">\Delta^2 \mathbf{d} = 0</script></span></p>
<p>subject to the same handle constraints, but rewritten in terms of their implied
deformation field at the boundary (handles).</p>
<p><span><span class="MathJax_Preview">\mathbf{d}_b = \mathbf{x}_{bc} - \mathbf{x}_b.</span><script type="math/tex">\mathbf{d}_b = \mathbf{x}_{bc} - \mathbf{x}_b.</script></span></p>
<p>Again we can use <code class="codehilite">harmonic_weights</code> with <span><span class="MathJax_Preview">k=2</span><script type="math/tex">k=2</script></span>, but this time solve for the
deformation field and then recover the deformed positions:</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/decimated-max.obj&quot;</span><span class="p">)</span>
<span class="n">v</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="c1"># Swap X and Z axes</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_dmat</span><span class="p">(</span><span class="s2">&quot;data/decimated-max-selection.dmat&quot;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

<span class="c1">## Boundary conditions directly on deformed positions</span>
<span class="n">u_bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">v_bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

<span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">v_bc</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">bi</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">bi</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Don&#39;t move handle 0</span>
        <span class="n">u_bc</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">bi</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="n">s</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">bi</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Move handle 1 down</span>
        <span class="n">u_bc</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">bi</span><span class="p">]]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># Move other handles forward</span>
        <span class="n">u_bc</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">bi</span><span class="p">]]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">25</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span> <span class="s2">&quot;colormap&quot;</span><span class="p">:</span> <span class="s2">&quot;tab10&quot;</span><span class="p">},</span> <span class="n">return_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="nd">@interact</span><span class="p">(</span><span class="n">deformation_field</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">deformation_field</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="c1"># Determine boundary conditions</span>
    <span class="n">u_bc_anim</span> <span class="o">=</span> <span class="n">v_bc</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="p">(</span><span class="n">u_bc</span> <span class="o">-</span> <span class="n">v_bc</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">deformation_field</span><span class="p">:</span>
        <span class="n">d_bc</span> <span class="o">=</span> <span class="n">u_bc_anim</span> <span class="o">-</span> <span class="n">v_bc</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">harmonic_weights</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d_bc</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="n">d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">harmonic_weights</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">u_bc_anim</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">update_object</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(82.297483…



interactive(children=(Checkbox(value=True, description=&#39;deformation_field&#39;), FloatSlider(value=0.0, descriptio…
</pre></div>


<h4 id="relationship-to-differential-coordinates-and-laplacian-surface-editing">Relationship to &ldquo;differential coordinates&rdquo; and Laplacian surface editing<a class="headerlink" href="#relationship-to-differential-coordinates-and-laplacian-surface-editing" title="Permanent link">&para;</a></h4>
<p>Biharmonic functions (whether positions or displacements) are solutions to the
bi-Laplace equation, but also minimizers of the &ldquo;Laplacian energy&rdquo;. For
example, for displacements <span><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span>, the energy reads</p>
<p><span><span class="MathJax_Preview">\int\limits_S \|\Delta \mathbf{d}\|^2 dA,</span><script type="math/tex">\int\limits_S \|\Delta \mathbf{d}\|^2 dA,</script></span></p>
<p>where we define <span><span class="MathJax_Preview">\Delta \mathbf{d}</span><script type="math/tex">\Delta \mathbf{d}</script></span> to simply apply the Laplacian
coordinate-wise.</p>
<p>By linearity of the Laplace(-Beltrami) operator we can reexpress this energy in
terms of the original positions <span><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> and the unknown positions
<span><span class="MathJax_Preview">\mathbf{x}' = \mathbf{x} - \mathbf{d}</span><script type="math/tex">\mathbf{x}' = \mathbf{x} - \mathbf{d}</script></span>:</p>
<p><span><span class="MathJax_Preview">\int\limits_S \|\Delta (\mathbf{x}' - \mathbf{x})\|^2 dA = \int\limits_S
 \|\Delta \mathbf{x}' - \Delta \mathbf{x})\|^2 dA.</span><script type="math/tex">\int\limits_S \|\Delta (\mathbf{x}' - \mathbf{x})\|^2 dA = \int\limits_S
 \|\Delta \mathbf{x}' - \Delta \mathbf{x})\|^2 dA.</script></span></p>
<p>In the early work of Sorkine et al., the quantities <span><span class="MathJax_Preview">\Delta \mathbf{x}'</span><script type="math/tex">\Delta \mathbf{x}'</script></span> and
<span><span class="MathJax_Preview">\Delta \mathbf{x}</span><script type="math/tex">\Delta \mathbf{x}</script></span> were dubbed &ldquo;differential coordinates&rdquo;  <cite data-cite="sorkine_2002">(Sorkine, 2004)</cite>.
Their deformations (without linearized rotations) is thus equivalent to
biharmonic deformation fields.</p>
<h3 id="polyharmonic-deformation">Polyharmonic deformation<a class="headerlink" href="#polyharmonic-deformation" title="Permanent link">&para;</a></h3>
<p>We can generalize biharmonic deformation by considering different powers of
the Laplacian, resulting in a series of PDEs of the form:</p>
<p><span><span class="MathJax_Preview">\Delta^k \mathbf{d} = 0.</span><script type="math/tex">\Delta^k \mathbf{d} = 0.</script></span></p>
<p>with <span><span class="MathJax_Preview">k\in{1,2,3,\dots}</span><script type="math/tex">k\in{1,2,3,\dots}</script></span>. The choice of <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> determines the level of continuity
at the handles. In particular, <span><span class="MathJax_Preview">k=1</span><script type="math/tex">k=1</script></span> implies <span><span class="MathJax_Preview">C^0</span><script type="math/tex">C^0</script></span> at the boundary, <span><span class="MathJax_Preview">k=2</span><script type="math/tex">k=2</script></span>
implies <span><span class="MathJax_Preview">C^1</span><script type="math/tex">C^1</script></span>, <span><span class="MathJax_Preview">k=3</span><script type="math/tex">k=3</script></span> implies <span><span class="MathJax_Preview">C^2</span><script type="math/tex">C^2</script></span> and in general <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> implies <span><span class="MathJax_Preview">C^{k-1}</span><script type="math/tex">C^{k-1}</script></span>.</p>
<p>The following example deforms a flat domain (left) into a bump as a solution to various <span><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-harmonic PDEs.</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/bump-domain.obj&quot;</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Find boundary vertices outside annulus</span>
<span class="n">vrn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">is_outer</span> <span class="o">=</span> <span class="p">[</span><span class="n">vrn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.00</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">1e-15</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
<span class="n">is_inner</span> <span class="o">=</span> <span class="p">[</span><span class="n">vrn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.15</span> <span class="o">&lt;</span> <span class="mf">1e-15</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
<span class="n">in_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">is_outer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">is_inner</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">is_outer</span><span class="p">))]</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="p">(</span><span class="n">in_b</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span><span class="o">.</span><span class="n">T</span>
<span class="n">bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

<span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
    <span class="n">bc</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">is_outer</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">bi</span><span class="p">]]</span> <span class="k">else</span> <span class="mf">1.0</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">is_outer</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wire_width&quot;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span> <span class="s2">&quot;colormap&quot;</span><span class="p">:</span> <span class="s2">&quot;tab10&quot;</span><span class="p">},</span> <span class="n">return_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>                

<span class="nd">@interact</span><span class="p">(</span><span class="n">z_max</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">z_max</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">harmonic_weights</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
    <span class="n">u</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_max</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">p</span><span class="o">.</span><span class="n">update_object</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(0.0, 0.0,…



interactive(children=(FloatSlider(value=0.5, description=&#39;z_max&#39;, max=1.0), IntSlider(value=2, description=&#39;k&#39;…
</pre></div>


<h2 id="chapter-4-parametrization">Chapter 4: Parametrization<a class="headerlink" href="#chapter-4-parametrization" title="Permanent link">&para;</a></h2>
<p>In computer graphics, we denote as surface parametrization a map from the
surface to \(\mathbf{R}^2\). It is usually encoded by a new set of 2D
coordinates for each vertex of the mesh (and possibly also by a new set of
faces in one to one correspondence with the faces of the original surface).
Note that
this definition is the <em>inverse</em> of the classical differential geometry
definition.</p>
<p>A parametrization has many applications, ranging from texture mapping to
surface remeshing. Many algorithms have been proposed, and they can be broadly
divided in four families:</p>
<ol>
<li>
<p><strong>Single patch, fixed boundary</strong>: these algorithm can parametrize a
disk-like part of the surface given fixed 2D positions for its boundary. These
algorithms are efficient and simple, but they usually produce high-distortion maps due to the fixed boundary.</p>
</li>
<li>
<p><strong>Single patch, free boundary:</strong> these algorithms let the boundary
deform freely, greatly reducing the map distortion. Care should be taken to
prevent the border to self-intersect.</p>
</li>
<li>
<p><strong>Global parametrization</strong>: these algorithms work on meshes with arbitrary
genus. They initially cut the mesh in multiple patches that can be separately parametrized. The generated maps are discontinuous on the cuts (often referred as <em>seams</em>).</p>
</li>
<li>
<p><strong>Global seamless parametrization</strong>: these are global parametrization algorithm that hides the seams, making the parametrization &ldquo;continuous&rdquo;, under specific assumptions that we will discuss later.</p>
</li>
</ol>
<h3 id="harmonic-parametrization">Harmonic parametrization<a class="headerlink" href="#harmonic-parametrization" title="Permanent link">&para;</a></h3>
<p>Harmonic parametrization <cite data-cite="eck_2005">(Eck, 2005)</cite> is a single patch, fixed boundary parametrization
algorithm that computes the 2D coordinates of the flattened mesh as two
harmonic functions.</p>
<p>The algorithm is divided in 3 steps:</p>
<ol>
<li>Detection of the boundary vertices</li>
<li>Map the boundary vertices to a circle</li>
<li>Compute two harmonic functions (one for u and one for the v coordinate). The harmonic functions use the fixed vertices on the circle as boundary constraints.</li>
</ol>
<p>The algorithm is coded with libigl in the following example. <code class="codehilite">bnd</code> contains the indices of the boundary vertices, bnd_uv their position on the UV plane, and &ldquo;1&rdquo; denotes that we want to compute an harmonic function (2 will be for biharmonic, 3 for triharmonic, etc.). Note that each of the three
functions is designed to be reusable in other parametrization algorithms.
The UV coordinates are then used to apply a procedural checkerboard texture to the mesh.</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span>  <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/camelhead.off&quot;</span><span class="p">)</span>
<span class="c1">## Find the open boundary</span>
<span class="n">bnd</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">boundary_loop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="c1">## Map the boundary to a circle, preserving edge proportions</span>
<span class="n">bnd_uv</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">map_vertices_to_circle</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">bnd</span><span class="p">)</span>

<span class="c1">## Harmonic parametrization for the internal vertices</span>
<span class="n">uv</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">harmonic_weights</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">bnd</span><span class="p">,</span> <span class="n">bnd_uv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">v_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">uv</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">uv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))])</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">uv</span><span class="o">=</span><span class="n">uv</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">},</span> <span class="n">return_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="nd">@interact</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;3D&#39;</span><span class="p">,</span><span class="s1">&#39;2D&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">switch</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;3D&quot;</span><span class="p">:</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">uv</span><span class="o">=</span><span class="n">uv</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">},</span> <span class="n">plot</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;2D&quot;</span><span class="p">:</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">v_p</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">uv</span><span class="o">=</span><span class="n">uv</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">},</span> <span class="n">plot</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(1.9967555…



interactive(children=(Dropdown(description=&#39;mode&#39;, options=(&#39;3D&#39;, &#39;2D&#39;), value=&#39;3D&#39;), Output()), _dom_classes=…
</pre></div>


<h3 id="least-squares-conformal-maps">Least squares conformal maps<a class="headerlink" href="#least-squares-conformal-maps" title="Permanent link">&para;</a></h3>
<p>Least squares conformal maps parametrization <cite data-cite="levy_2002">(Levy, 2002)</cite> minimizes the
conformal (angular) distortion of the parametrization. Differently from
harmonic parametrization, it does not need to have a fixed boundary.</p>
<p>LSCM minimizes the following energy:</p>
<p>\[ E_{LSCM}(\mathbf{u},\mathbf{v}) = \int_X \frac{1}{2}| \nabla \mathbf{u}^{\perp} - \nabla \mathbf{v} |^2 dA \]</p>
<p>which can be rewritten in matrix form as <cite data-cite="mullen_2008">(Mullen, 2008)</cite>:</p>
<p>\[ E_{LSCM}(\mathbf{u},\mathbf{v}) = \frac{1}{2} [\mathbf{u},\mathbf{v}]^t (L_c - 2A) [\mathbf{u},\mathbf{v}] \]</p>
<p>where <span><span class="MathJax_Preview">L_c</span><script type="math/tex">L_c</script></span> is the cotangent Laplacian matrix and <span><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> is a matrix such that
<span><span class="MathJax_Preview">[\mathbf{u},\mathbf{v}]^t A  [\mathbf{u},\mathbf{v}]</span><script type="math/tex">[\mathbf{u},\mathbf{v}]^t A  [\mathbf{u},\mathbf{v}]</script></span> is equal to the <a href="http://en.wikipedia.org/wiki/Vector_area">vector
area</a> of the mesh.</p>
<p>Using libigl, this matrix energy can be written in a few lines of code. The
cotangent matrix can be computed using <code class="codehilite">igl.cotmatrix</code>. Note that we want to apply the Laplacian matrix to the u and v coordinates at the same time, thus we need to extend it taking the left Kronecker product with a 2x2 identity matrix. The area matrix is computed with <code class="codehilite">igl.vector_area_matrix</code>.</p>
<p>The final energy matrix is <span><span class="MathJax_Preview">L_{flat} - 2A</span><script type="math/tex">L_{flat} - 2A</script></span>. Note that in this
case we do not need to fix the boundary. To remove the null space of the energy and make the minimum unique, it is sufficient to fix two arbitrary
vertices to two arbitrary positions. The full source code is provided in the following LSCM parametrization example.</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/camelhead.off&quot;</span><span class="p">)</span>

<span class="c1"># Fix two points on the boundary</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">bnd</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">boundary_loop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bnd</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">bnd</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>

<span class="n">bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>

<span class="c1"># LSCM parametrization</span>
<span class="n">_</span><span class="p">,</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">lscm</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">uv</span><span class="o">=</span><span class="n">uv</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">},</span> <span class="n">return_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="nd">@interact</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;3D&#39;</span><span class="p">,</span><span class="s1">&#39;2D&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">switch</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;3D&quot;</span><span class="p">:</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">uv</span><span class="o">=</span><span class="n">uv</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">},</span> <span class="n">plot</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;2D&quot;</span><span class="p">:</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">uv</span><span class="o">=</span><span class="n">uv</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;wireframe&quot;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">},</span> <span class="n">plot</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(1.9967555…



interactive(children=(Dropdown(description=&#39;mode&#39;, options=(&#39;3D&#39;, &#39;2D&#39;), value=&#39;3D&#39;), Output()), _dom_classes=…
</pre></div>


<h2 id="chapter-5-external-libraries">Chapter 5: External libraries<a class="headerlink" href="#chapter-5-external-libraries" title="Permanent link">&para;</a></h2>
<p>An additional positive side effect of using matrices as basic types is that it
is easy to exchange data between libigl and other software and libraries.</p>
<h3 id="triangulation-of-closed-polygons">Triangulation of closed polygons<a class="headerlink" href="#triangulation-of-closed-polygons" title="Permanent link">&para;</a></h3>
<p>The generation of high-quality triangle and tetrahedral meshes is a very common
task in geometry processing. We provide wrappers in libigl to
<a href="http://www.cs.cmu.edu/~quake/triangle.html">triangle</a> and
<a href="http://wias-berlin.de/software/tetgen/">Tetgen</a>.</p>
<p>A triangle mesh with a given boundary can be created as in the following example. <code class="codehilite">e</code> is a set of boundary edges (#e by 2), <code class="codehilite">h</code> is a set of 2D positions of points contained in holes of the triangulation (#h by 2) and (<code class="codehilite">v</code>,<code class="codehilite">f</code>) is the
generated triangulation. Additional parameters can be passed to <code class="codehilite">triangle</code>, to
control the quality: <code class="codehilite">&quot;a0.005q&quot;</code> enforces a bound on the maximal area of the
triangles and a minimal angle of 20 degrees. In the following example, the interior of a square (excluded a smaller square in its interior) is triangulated.</p>
<div class="codehilite"><pre><span></span><span class="c1">## Input polygon</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>

<span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">triangulate</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;a0.05q&quot;</span><span class="p">)</span>
<span class="n">ext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">))</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ext</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(0.0, 0.0,…
</pre></div>


<h3 id="tetrahedralization-of-closed-surfaces">Tetrahedralization of closed surfaces<a class="headerlink" href="#tetrahedralization-of-closed-surfaces" title="Permanent link">&para;</a></h3>
<p>Similarly, the interior of a closed manifold surface can be tetrahedralized
using the function <code class="codehilite">tetrahedralize</code> which wraps the Tetgen library.</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/fertility.off&quot;</span><span class="p">)</span>

<span class="c1">## Tetrahedralize the interior</span>
<span class="n">success</span><span class="p">,</span> <span class="n">tv</span><span class="p">,</span> <span class="n">tt</span><span class="p">,</span> <span class="n">tf</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">tetrahedralize</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s2">&quot;pq1.414Y&quot;</span><span class="p">)</span>

<span class="c1">## Compute barycenters</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">barycenter</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="n">tt</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">return_plot</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="nd">@interact</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">level</span> <span class="o">/</span> <span class="mf">9.0</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">b</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">v</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">f_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="n">tet</span> <span class="o">=</span> <span class="n">tt</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">f_tmp</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">tet</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tet</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tet</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">tet</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tet</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tet</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span>
                                     <span class="p">[</span><span class="n">tet</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tet</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tet</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span> <span class="p">[</span><span class="n">tet</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tet</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tet</span><span class="p">[</span><span class="mi">3</span><span class="p">]]],</span><span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>

    <span class="n">plot</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="n">f_tmp</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(23.939350…



interactive(children=(IntSlider(value=5, description=&#39;level&#39;, max=9, min=1), Output()), _dom_classes=(&#39;widget-…
</pre></div>


<h3 id="baking-ambient-occlusion">Baking ambient occlusion<a class="headerlink" href="#baking-ambient-occlusion" title="Permanent link">&para;</a></h3>
<p><a href="http://en.wikipedia.org/wiki/Ambient_occlusion">Ambient occlusion</a> is a
rendering technique used to calculate the exposure of each point in a surface
to ambient lighting. It is usually encoded as a scalar (normalized between 0
and 1) associated with the vertice of a mesh.</p>
<p>Formally, ambient occlusion is defined as:</p>
<p>\[ A_p = \frac{1}{\pi} \int_\omega V_{p,\omega}(n \cdot \omega) d\omega \]</p>
<p>where <span><span class="MathJax_Preview">V_{p,\omega}</span><script type="math/tex">V_{p,\omega}</script></span> is the visibility function at  p, defined to be zero if p
is occluded in the direction <span><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span> and one otherwise, and <span><span class="MathJax_Preview">d\omega</span><script type="math/tex">d\omega</script></span> is the
infinitesimal solid angle step of the integration variable <span><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span>.</p>
<p>The integral is usually approximated by casting rays in random directions
around each vertex. This approximation can be computed using the function:</p>
<div class="codehilite"><pre><span></span>ao = igl.ambient_occlusion(v, f, v_samples, n_samples, 500)
</pre></div>

<p>that given a scene described in <code class="codehilite">v</code> and <code class="codehilite">f</code>, computes the ambient occlusion of
the points in <code class="codehilite">v_samples</code> whose associated normals are <code class="codehilite">n_samples</code>. The
number of casted rays can be controlled (usually at least 300-500 rays are
required to get a smooth result) and the result is returned in <code class="codehilite">ao</code>, as a
single scalar for each sample.</p>
<p>Ambient occlusion can be used to darken the surface colors, as shown in the following example:</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/fertility.off&quot;</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">per_vertex_normals</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

<span class="c1"># Compute ambient occlusion factor using embree</span>
<span class="n">ao</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">ambient_occlusion</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">ao</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">ao</span>

<span class="n">plot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">ao</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;colormap&quot;</span><span class="p">:</span> <span class="s2">&quot;gist_gray&quot;</span><span class="p">})</span>
</pre></div>

<div class="codehilite"><pre><span></span>Renderer(camera=PerspectiveCamera(children=(DirectionalLight(color=&#39;white&#39;, intensity=0.6, position=(23.939350…
</pre></div>


<h2 id="chapter-6-miscellaneous">Chapter 6: Miscellaneous<a class="headerlink" href="#chapter-6-miscellaneous" title="Permanent link">&para;</a></h2>
<p>Libigl contains a <em>wide</em> variety of geometry processing tools and functions for
dealing with meshes and the linear algebra related to them: far too many to
discuss in this introductory tutorial. We&rsquo;ve pulled out a couple of the
interesting functions in this chapter to highlight.</p>
<h3 id="mesh-statistics">Mesh Statistics<a class="headerlink" href="#mesh-statistics" title="Permanent link">&para;</a></h3>
<p>Libigl contains various mesh statistics, including face angles, face areas and
the detection of singular vertices, which are vertices with more or less than 6
neighbours in triangulations or 4 in quadrangulations.</p>
<p>The example computes these quantities and
does a basic statistic analysis that allows to estimate the isometry and
regularity of a mesh:</p>
<div class="codehilite"><pre><span></span><span class="n">v</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">read_triangle_mesh</span><span class="p">(</span><span class="s2">&quot;data/horse_quad.obj&quot;</span><span class="p">)</span>

<span class="c1">## Count the number of irregular vertices, the border is ignored</span>
<span class="n">irregular</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">is_irregular_vertex</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> 
<span class="n">v_count</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">irregular_v_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">irregular</span><span class="p">)</span>
<span class="n">irregular_ratio</span> <span class="o">=</span> <span class="n">irregular_v_count</span> <span class="o">/</span> <span class="n">v_count</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Irregular vertices: </span><span class="se">\n</span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2"> (</span><span class="si">%.2f%%</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">irregular_v_count</span><span class="p">,</span> <span class="n">v_count</span><span class="p">,</span> <span class="n">irregular_ratio</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>

<span class="c1">## Compute areas, min, max and standard deviation</span>
<span class="n">area</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">doublearea</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>

<span class="n">area_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
<span class="n">area_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">/</span> <span class="n">area_avg</span>
<span class="n">area_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">area</span><span class="p">)</span> <span class="o">/</span> <span class="n">area_avg</span>
<span class="n">area_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">area</span> <span class="o">-</span> <span class="n">area_avg</span><span class="p">)</span> <span class="o">/</span> <span class="n">area_avg</span>
<span class="n">area_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">area_ns</span><span class="p">)))</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Areas (Min/Max)/Avg_Area Sigma: </span><span class="se">\n</span><span class="si">%.2f</span><span class="s2">/</span><span class="si">%.2f</span><span class="s2"> (</span><span class="si">%.2f</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">area_min</span><span class="p">,</span> <span class="n">area_max</span><span class="p">,</span> <span class="n">area_sigma</span><span class="p">))</span>

<span class="c1">## Compute per face angles, min, max and standard deviation</span>
<span class="n">angles</span> <span class="o">=</span> <span class="n">igl</span><span class="o">.</span><span class="n">internal_angles</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="n">angles</span> <span class="o">=</span> <span class="mf">360.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">angles</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>

<span class="n">angle_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
<span class="n">angle_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
<span class="n">angle_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
<span class="n">angle_ns</span> <span class="o">=</span> <span class="n">angles</span> <span class="o">-</span> <span class="n">angle_avg</span>
<span class="n">angle_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">angle_ns</span><span class="p">)))</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Angles in degrees (Min/Max) Sigma: </span><span class="se">\n</span><span class="si">%.2f</span><span class="s2">/</span><span class="si">%.2f</span><span class="s2"> (</span><span class="si">%.2f</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">angle_min</span><span class="p">,</span> <span class="n">angle_max</span><span class="p">,</span> <span class="n">angle_sigma</span><span class="p">))</span>
</pre></div>

<div class="codehilite"><pre><span></span>Irregular vertices: 
659/2400 (27.46%)

Areas (Min/Max)/Avg_Area Sigma: 
0.01/6.26 (0.88)

Angles in degrees (Min/Max) Sigma: 
2.36/171.79 (25.02)
</pre></div>


<p>The first row contains the number and percentage of irregular vertices, which
is particularly important for quadrilateral meshes when they are used to define
subdivision surfaces: every singular point will result in a point of the
surface that is only C^1.</p>
<p>The second row reports the area of the minimal element, maximal element and the
standard deviation.  These numbers are normalized by the mean area, so in the
example above 5.33 max area means that the biggest face is 5 times larger than
the average face. An ideal isotropic mesh would have both min and max area
close to 1.</p>
<p>The third row measures the face angles, which should be close to 60 degrees (90
for quads) in a perfectly regular triangulation. For FEM purposes, the closer
the angles are to 60 degrees the more stable will the optimization be. In this
case, it is clear that the mesh is of bad quality and it will probably result
in artifacts if used for solving PDEs.</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<!-- Chapter 2 -->

<!-- Chapter 3 -->

<!-- Chapter 4 -->

<!-- Chapter 5 -->

<!-- Chapter 6 -->

<!-- Chapter 7 -->

<div class="codehilite"><pre><span></span>
</pre></div>

<div class="footnote">
<hr />
<ol>
<li id="fn:jacobson_thesis_2013">
<p>Alec Jacobson, <a href="https://www.google.com/search?q=Algorithms+and+Interfaces+for+Real-Time+Deformation+of+2D+and+3D+Shapes"><em>Algorithms and Interfaces for Real-Time Deformation of 2D and 3D Shapes</em></a>, 2013.&#160;<a class="footnote-backref" href="#fnref:jacobson_thesis_2013" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:kazhdan_2012">
<p>Michael Kazhdan, Jake Solomon, Mirela Ben-Chen, <a href="https://www.google.com/search?q=Can+Mean-Curvature+Flow+Be+Made+Non-Singular">Can Mean-Curvature Flow Be Made Non-Singular</a>, 2012.&#160;<a class="footnote-backref" href="#fnref:kazhdan_2012" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:meyer_2003">
<p>Mark Meyer, Mathieu Desbrun, Peter Schröder and Alan H.  Barr, <a href="https://www.google.com/search?q=Discrete+Differential-Geometry+Operators+for+Triangulated+2-Manifolds">Discrete Differential-Geometry Operators for Triangulated 2-Manifolds</a>, 2003.&#160;<a class="footnote-backref" href="#fnref:meyer_2003" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:mitchell_1987">
<p>Joseph S. B. Mitchell, David M. Mount, Christos H. Papadimitriou. <a href="https://www.google.com/search?q=The+Discrete+Geodesic+Problem">The Discrete Geodesic Problem</a>, 1987&#160;<a class="footnote-backref" href="#fnref:mitchell_1987" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:panozzo_2010">
<p>Daniele Panozzo, Enrico Puppo, Luigi Rocca, <a href="https://www.google.com/search?q=Efficient+Multi-scale+Curvature+and+Crease+Estimation">Efficient Multi-scale Curvature and Crease Estimation</a>, 2010.&#160;<a class="footnote-backref" href="#fnref:panozzo_2010" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:sharf_2007">
<p>Andrei Sharf, Thomas Lewiner, Gil Shklarski, Sivan Toledo, and Daniel Cohen-Or. <a href="https://www.google.com/search?q=Interactive+topology-aware+surface+reconstruction">Interactive topology-aware surface reconstruction</a>, 2007.&#160;<a class="footnote-backref" href="#fnref:sharf_2007" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:barbic_2005">
<p>Jernej Barbic and Doug James. <a href="https://www.google.com/search?q=Real-Time+Subspace+Integration+for+St.Venant-Kirchhoff+Deformable+Models">Real-Time Subspace Integration for St.Venant-Kirchhoff Deformable Models</a>, 2005.&#160;<a class="footnote-backref" href="#fnref:barbic_2005" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:hildebrandt_2011">
<p>Klaus Hildebrandt, Christian Schulz, Christoph von Tycowicz, and Konrad Polthier. <a href="https://www.google.com/search?q=Interactive+Surface+Modeling+using+Modal+Analysis">Interactive Surface Modeling using Modal Analysis</a>, 2011.&#160;<a class="footnote-backref" href="#fnref:hildebrandt_2011" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:rustamov_2011">
<p>Raid M. Rustamov, <a href="https://www.google.com/search?q=Multiscale+Biharmonic+Kernels">Multiscale Biharmonic Kernels</a>, 2011.&#160;<a class="footnote-backref" href="#fnref:rustamov_2011" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
<li id="fn:vallet_2008">
<p>Bruno Vallet and Bruno Lévy. <a href="https://www.google.com/search?q=Spectral+Geometry+Processing+with+Manifold+Harmonics">Spectral Geometry Processing with Manifold Harmonics</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:vallet_2008" title="Jump back to footnote 10 in the text">&#8617;</a></p>
</li>
<li id="fn:botsch_2004">
<p>Matrio Botsch and Leif Kobbelt. <a href="https://www.google.com/search?q=An+Intuitive+Framework+for+Real-Time+Freeform+Modeling">An Intuitive Framework for Real-Time Freeform Modeling</a>, 2004.&#160;<a class="footnote-backref" href="#fnref:botsch_2004" title="Jump back to footnote 11 in the text">&#8617;</a></p>
</li>
<li id="fn:chao_2010">
<p>Isaac Chao, Ulrich Pinkall, Patrick Sanan, Peter Schröder. <a href="https://www.google.com/search?q=A+Simple+Geometric+Model+for+Elastic+Deformations">A Simple Geometric Model for Elastic Deformations</a>, 2010.&#160;<a class="footnote-backref" href="#fnref:chao_2010" title="Jump back to footnote 12 in the text">&#8617;</a></p>
</li>
<li id="fn:jacobson_2011">
<p>Alec Jacobson, Ilya Baran, Jovan Popović, and Olga Sorkine. <a href="https://www.google.com/search?q=Bounded+biharmonic+weights+for+real-time+deformation">Bounded Biharmonic Weights for Real-Time Deformation</a>, 2011.&#160;<a class="footnote-backref" href="#fnref:jacobson_2011" title="Jump back to footnote 13 in the text">&#8617;</a></p>
</li>
<li id="fn:jacobson_2012">
<p>Alec Jacobson, Ilya Baran, Ladislav Kavan, Jovan Popović, and Olga Sorkine. <a href="https://www.google.com/search?q=Fast+Automatic+Skinning+Transformations">Fast Automatic Skinning Transformations</a>, 2012.&#160;<a class="footnote-backref" href="#fnref:jacobson_2012" title="Jump back to footnote 14 in the text">&#8617;</a></p>
</li>
<li id="fn:jacobson_mixed_2010">
<p>Alec Jacobson, Elif Tosun, Olga Sorkine, and Denis Zorin. <a href="https://www.google.com/search?q=Mixed+Finite+Elements+for+Variational+Surface+Modeling">Mixed Finite Elements for Variational Surface Modeling</a>, 2010.&#160;<a class="footnote-backref" href="#fnref:jacobson_mixed_2010" title="Jump back to footnote 15 in the text">&#8617;</a></p>
</li>
<li id="fn:jacobson_skinning_course_2014">
<p>Alec Jacobson, Zhigang Deng, Ladislav Kavan, J.P. Lewis. <a href="https://www.google.com/search?q=Skinning+Real-Time+Shape+Deformation"><em>Skinning: Real-Time Shape Deformation</em></a>, 2014.&#160;<a class="footnote-backref" href="#fnref:jacobson_skinning_course_2014" title="Jump back to footnote 16 in the text">&#8617;</a></p>
</li>
<li id="fn:kavan_2008">
<p>Ladislav Kavan, Steven Collins, Jiri Zara, and Carol O&rsquo;Sullivan. <a href="https://www.google.com/search?q=Geometric+Skinning+with+Approximate+Dual+Quaternion+Blending">Geometric Skinning with Approximate Dual Quaternion Blending</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:kavan_2008" title="Jump back to footnote 17 in the text">&#8617;</a></p>
</li>
<li id="fn:mcadams_2011">
<p>Alexa McAdams, Andrew Selle, Rasmus Tamstorf, Joseph Teran, Eftychios Sifakis. <a href="https://www.google.com/search?q=Computing+the+Singular+Value+Decomposition+of+3x3+matrices+with+minimal+branching+and+elementary+floating+point+operations">Computing the Singular Value Decomposition of 3x3 matrices with minimal branching and elementary floating point operations</a>, 2011.&#160;<a class="footnote-backref" href="#fnref:mcadams_2011" title="Jump back to footnote 18 in the text">&#8617;</a></p>
</li>
<li id="fn:sorkine_2004">
<p>Olga Sorkine, Yaron Lipman, Daniel Cohen-Or, Marc Alexa, Christian Rössl and Hans-Peter Seidel. <a href="https://www.google.com/search?q=Laplacian+Surface+Editing">Laplacian Surface Editing</a>, 2004.&#160;<a class="footnote-backref" href="#fnref:sorkine_2004" title="Jump back to footnote 19 in the text">&#8617;</a></p>
</li>
<li id="fn:sorkine_2007">
<p>Olga Sorkine and Marc Alexa. <a href="https://www.google.com/search?q=As-rigid-as-possible+Surface+Modeling">As-rigid-as-possible Surface Modeling</a>, 2007.&#160;<a class="footnote-backref" href="#fnref:sorkine_2007" title="Jump back to footnote 20 in the text">&#8617;</a></p>
</li>
<li id="fn:wang_bc_2015">
<p>Yu Wang, Alec Jacobson, Jernej Barbic, Ladislav Kavan. <a href="https://www.google.com/search?q=Linear+Subspace+Design+for+Real-Time+Shape+Deformation">Linear Subspace Design for Real-Time Shape Deformation</a>, 2015&#160;<a class="footnote-backref" href="#fnref:wang_bc_2015" title="Jump back to footnote 21 in the text">&#8617;</a></p>
</li>
<li id="fn:bommes_2009">
<p>David Bommes, Henrik Zimmer, Leif Kobbelt. <a href="http://www-sop.inria.fr/members/David.Bommes/publications/miq.pdf">Mixed-integer quadrangulation</a>, 2009.&#160;<a class="footnote-backref" href="#fnref:bommes_2009" title="Jump back to footnote 22 in the text">&#8617;</a></p>
</li>
<li id="fn:bouaziz_2012">
<p>Sofien Bouaziz, Mario Deuss, Yuliy Schwartzburg, Thibaut Weise, Mark Pauly <a href="http://lgg.epfl.ch/publications/2012/shapeup.pdf">Shape-Up: Shaping Discrete Geometry with Projections</a>, 2012&#160;<a class="footnote-backref" href="#fnref:bouaziz_2012" title="Jump back to footnote 23 in the text">&#8617;</a></p>
</li>
<li id="fn:eck_2005">
<p>Matthias Eck, Tony DeRose, Tom Duchamp, Hugues Hoppe, Michael Lounsbery, Werner Stuetzle.  <a href="http://research.microsoft.com/en-us/um/people/hoppe/mra.pdf">Multiresolution Analysis of Arbitrary Meshes</a>, 2005.&#160;<a class="footnote-backref" href="#fnref:eck_2005" title="Jump back to footnote 24 in the text">&#8617;</a></p>
</li>
<li id="fn:levy_2002">
<p>Bruno Lévy, Sylvain Petitjean, Nicolas Ray, Jérome Maillot. <a href="http://www.cs.jhu.edu/~misha/Fall09/Levy02.pdf">Least Squares Conformal Maps, for Automatic Texture Atlas Generation</a>, 2002.&#160;<a class="footnote-backref" href="#fnref:levy_2002" title="Jump back to footnote 25 in the text">&#8617;</a></p>
</li>
<li id="fn:levy_2008">
<p>Nicolas Ray, Bruno Vallet, Wan Chiu Li, Bruno Lévy. <a href="http://alice.loria.fr/publications/papers/2008/DGF/NSDFD-TOG.pdf">N-Symmetry Direction Field Design</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:levy_2008" title="Jump back to footnote 26 in the text">&#8617;</a></p>
</li>
<li id="fn:liu_2008">
<p>Ligang Liu, Lei Zhang, Yin Xu, Craig Gotsman, Steven J. Gortler. <a href="http://cs.harvard.edu/~sjg/papers/arap.pdf">A Local/Global Approach to Mesh Parameterization</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:liu_2008" title="Jump back to footnote 27 in the text">&#8617;</a></p>
</li>
<li id="fn:mullen_2008">
<p>Patrick Mullen, Yiying Tong, Pierre Alliez, Mathieu Desbrun. <a href="http://www.geometry.caltech.edu/pubs/MTAD08.pdf">Spectral Conformal Parameterization</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:mullen_2008" title="Jump back to footnote 28 in the text">&#8617;</a></p>
</li>
<li id="fn:panozzo_2014">
<p>Daniele Panozzo, Enrico Puppo, Marco Tarini, Olga Sorkine-Hornung.  <a href="http://cs.nyu.edu/~panozzo/papers/frame-fields-2014.pdf">Frame Fields: Anisotropic and Non-Orthogonal Cross Fields</a>, 2014.&#160;<a class="footnote-backref" href="#fnref:panozzo_2014" title="Jump back to footnote 29 in the text">&#8617;</a></p>
</li>
<li id="fn:vaxman_2016">
<p>Amir Vaxman, Marcel Campen, Olga Diamanti, Daniele Panozzo, David Bommes, Klaus Hildebrandt, Mirela Ben-Chen. <a href="https://www.google.com/search?q=Directional+Field+Synthesis+Design+and+Processing">Directional Field Synthesis, Design, and Processing</a>, 2016&#160;<a class="footnote-backref" href="#fnref:vaxman_2016" title="Jump back to footnote 30 in the text">&#8617;</a></p>
</li>
<li id="fn:schuller_2013">
<p>Christian Schüller, Ladislav Kavan, Daniele Panozzo, Olga Sorkine-Hornung.  <a href="http://igl.ethz.ch/projects/LIM/">Locally Injective Mappings</a>, 2013.&#160;<a class="footnote-backref" href="#fnref:schuller_2013" title="Jump back to footnote 31 in the text">&#8617;</a></p>
</li>
<li id="fn:zhou_2016">
<p>Qingnan Zhou, Eitan Grinspun, Denis Zorin. <a href="https://www.google.com/search?q=Mesh+Arrangements+for+Solid+Geometry">Mesh Arrangements for Solid Geometry</a>, 2016&#160;<a class="footnote-backref" href="#fnref:zhou_2016" title="Jump back to footnote 32 in the text">&#8617;</a></p>
</li>
<li id="fn:baerentzen_2005">
<p>J Andreas Baerentzen and Henrik Aanaes. <a href="https://www.google.com/search?q=Signed+distance+computation+using+the+angle+weighted+pseudonormal">Signed distance computation using the angle weighted pseudonormal</a>, 2005.&#160;<a class="footnote-backref" href="#fnref:baerentzen_2005" title="Jump back to footnote 33 in the text">&#8617;</a></p>
</li>
<li id="fn:garg_2016">
<p>Akash Garg, Alec Jacobson, Eitan Grinspun. <a href="https://www.google.com/search?q=Computational+Design+of+Reconfigurables">Computational Design of Reconfigurables</a>, 2016&#160;<a class="footnote-backref" href="#fnref:garg_2016" title="Jump back to footnote 34 in the text">&#8617;</a></p>
</li>
<li id="fn:hoppe_1996">
<p>Hugues Hoppe. <a href="https://www.google.com/search?q=Progressive+meshes">Progressive Meshes</a>, 1996&#160;<a class="footnote-backref" href="#fnref:hoppe_1996" title="Jump back to footnote 35 in the text">&#8617;</a></p>
</li>
<li id="fn:jacobson_2013">
<p>Alec Jacobson, Ladislav Kavan, and Olga Sorkine. <a href="https://www.google.com/search?q=Robust+Inside-Outside+Segmentation+using+Generalized+Winding+Numbers">Robust Inside-Outside Segmentation using Generalized Winding Numbers</a>, 2013.&#160;<a class="footnote-backref" href="#fnref:jacobson_2013" title="Jump back to footnote 36 in the text">&#8617;</a></p>
</li>
<li id="fn:loop_1987">
<p>Charles Loop. <a href="https://www.google.com/search?q=smooth+subdivision+surfaces+based+on+triangles">Smooth Subdivision Surfaces Based on Triangles</a>, 1987.&#160;<a class="footnote-backref" href="#fnref:loop_1987" title="Jump back to footnote 37 in the text">&#8617;</a></p>
</li>
<li id="fn:lorensen_1987">
<p>W.E. Lorensen and Harvey E. Cline. <a href="https://www.google.com/search?q=Marching+cubes:+A+high+resolution+3d+surface+construction+algorithm">Marching cubes: A high resolution 3d surface construction algorithm</a>, 1987.&#160;<a class="footnote-backref" href="#fnref:lorensen_1987" title="Jump back to footnote 38 in the text">&#8617;</a></p>
</li>
<li id="fn:rabinovich_2016">
<p>Michael Rabinovich, Roi Poranne, Daniele Panozzo, Olga Sorkine-Hornung. <a href="http://cs.nyu.edu/~panozzo/papers/SLIM-2016.pdf">Scalable Locally Injective Mappings</a>, 2016.&#160;<a class="footnote-backref" href="#fnref:rabinovich_2016" title="Jump back to footnote 39 in the text">&#8617;</a></p>
</li>
<li id="fn:schroeder_1994">
<p>William J. Schroeder, William E. Lorensen, and Steve Linthicum. <a href="https://www.google.com/search?q=implicit+modeling+of+swept+surfaces+and+volumes">Implicit Modeling of Swept Surfaces and Volumes</a>, 1994.&#160;<a class="footnote-backref" href="#fnref:schroeder_1994" title="Jump back to footnote 40 in the text">&#8617;</a></p>
</li>
<li id="fn:takayama14">
<p>Kenshi Takayama, Alec Jacobson, Ladislav Kavan, Olga Sorkine-Hornung. <a href="https://www.google.com/search?q=A+Simple+Method+for+Correcting+Facet+Orientations+in+Polygon+Meshes+Based+on+Ray+Casting">A Simple Method for Correcting Facet Orientations in Polygon Meshes Based on Ray Casting</a>, 2014.&#160;<a class="footnote-backref" href="#fnref:takayama14" title="Jump back to footnote 41 in the text">&#8617;</a></p>
</li>
<li id="fn:treece_1999">
<p>G.M. Treece, R.W. Prager, and A.H.Gee <a href="https://www.sciencedirect.com/science/article/pii/S009784939900076X">Regularised marching tetrahedra: improved iso-surface extraction</a>, 1999.&#160;<a class="footnote-backref" href="#fnref:treece_1999" title="Jump back to footnote 42 in the text">&#8617;</a></p>
</li>
<li id="fn:crane_2013">
<p>Keenan Crane, Clarisse Weischedel, and Max Wardetzky. <a href="https://www.google.com/search?q=geodesics+in+heat+a+new+approach+to+computing+distance+based+on+heat+flow">Geodesics in Heat: A New Approach to Computing Distance Based on Heat Flow</a>, 2013.&#160;<a class="footnote-backref" href="#fnref:crane_2013" title="Jump back to footnote 43 in the text">&#8617;</a></p>
</li>
<li id="fn:bobenko_2005">
<p>Alexander I. Bobenko and Boris A. Springborn. <a href="https://www.google.com/search?q=a+discrete+laplace-beltrami+operator+for+simplicial+surfaces">A discrete Laplace-Beltrami operator for simplicial surfaces</a>, 2005.&#160;<a class="footnote-backref" href="#fnref:bobenko_2005" title="Jump back to footnote 44 in the text">&#8617;</a></p>
</li>
<li id="fn:jiang_2017">
<p>Zhongshi Jiang, Scott Schaefer, Daniele Panozzo. <a href="https://doi.org/10.1145/3130800.3130895">SCAF: Simplicial Complex Augmentation Framework for Bijective Maps</a>, 2017&#160;<a class="footnote-backref" href="#fnref:jiang_2017" title="Jump back to footnote 45 in the text">&#8617;</a></p>
</li>
</ol>
</div>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href=".." title="Home" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Home
              </span>
            </div>
          </a>
        
        
          <a href="../igl_docs/" title="Docs" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Docs
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
  <div class="md-footer-social">
    <link rel="stylesheet" href="../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/geometryprocessing/libigl-python-bindings" class="md-footer-social__link fa fa-github"></a>
    
  </div>

      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.9e1f3b71.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
    
      
    
  </body>
</html>